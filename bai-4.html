<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 4:LỚP INETADDRESS - Blog của tôi</title><meta name="description" content="Các thiết bị kết nối tới Internet được gọi là các nút mạng (node). Nếu nút là máy tính chúng ta gọi là host. Mỗi nút hoặc host được phân biệt với nhau bởi các địa chỉ mạng, chúng ta thường gọi là địa chỉ&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/123VuPhuc/myblog.git/bai-4.html"><link rel="alternate" type="application/atom+xml" href="https://github.com/123VuPhuc/myblog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/123VuPhuc/myblog.git/feed.json"><meta property="og:title" content="Bài 4:LỚP INETADDRESS"><meta property="og:image" content="https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:site_name" content="Blog của tôi"><meta property="og:description" content="Các thiết bị kết nối tới Internet được gọi là các nút mạng (node). Nếu nút là máy tính chúng ta gọi là host. Mỗi nút hoặc host được phân biệt với nhau bởi các địa chỉ mạng, chúng ta thường gọi là địa chỉ&hellip;"><meta property="og:url" content="https://github.com/123VuPhuc/myblog.git/bai-4.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/123VuPhuc/myblog.git/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/123VuPhuc/myblog.git/bai-4.html"},"headline":"Bài 4:LỚP INETADDRESS","datePublished":"2024-12-29T11:11+07:00","dateModified":"2024-12-29T20:37+07:00","image":{"@type":"ImageObject","url":"https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920},"description":"Các thiết bị kết nối tới Internet được gọi là các nút mạng (node). Nếu nút là máy tính chúng ta gọi là host. Mỗi nút hoặc host được phân biệt với nhau bởi các địa chỉ mạng, chúng ta thường gọi là địa chỉ&hellip;","author":{"@type":"Person","name":"Vũ Trần Hoàng Phúc","url":"https://github.com/123VuPhuc/myblog.git/authors/vu-tran-hoang-phuc/"},"publisher":{"@type":"Organization","name":"Vũ Trần Hoàng Phúc","logo":{"@type":"ImageObject","url":"https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="page-template"><a href="/about-me"><label style="color: #007BFF; cursor: pointer;">Click here to read my About Me page</label></a><header class="top js-header"><a class="logo" href="https://github.com/123VuPhuc/myblog.git/"><img src="https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg" alt="Blog của tôi" width="1920" height="1080"></a></header><main class="page"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 4:LỚP INETADDRESS</h1></div></header></div><div class="entry-wrapper content__entry"><p>Các thiết bị kết nối tới Internet được gọi là các <em>nút mạng </em>(node). Nếu nút là máy tính chúng ta gọi là <em>host</em>. Mỗi nút hoặc host được phân biệt với nhau bởi các địa chỉ mạng, chúng ta thường gọi là địa chỉ IP. Hầu hết địa chỉ IP hiện nay là địa chỉ IPv4 (địa chỉ IP phiên bản 4) có độ dài 4 byte. Mặc dù vậy, nhiều tổ chức và cá nhân đang dần chuyển sang sử dụng địa chỉ IPv6 (địa chỉ IP phiên bản 6) có độ dài 16 byte. Cả địa chỉ IPv4 và IPv6 đều bao gồm các byte được sắp thứ tự nhất định (có thể coi đó là một mảng các byte) nhưng chúng thực tế không phải là số.</p><p>     Một địa chỉ IPv4 gồm 4 byte, mỗi byte thường được kí hiệu bằng một số nguyên dương có giá trị nằm trong khoảng từ 0 tới 255. Các byte được ngăn các bởi các dấu chấm để cho chúng ta dễ nhận ra chúng. Ví dụ, địa chỉ IP của trang <em>utb.edu.vn </em>là 117.6.86.168. Cách kí hiệu này thuật ngữ tiếng Anh gọi là định dạng <em>dotted quad</em>.</p><p>Một địa chỉ IPv6 thường được kí hiệu bởi 8 nhóm cách nhau bởi dấu hai chấm, trong đó mỗi nhóm gồm 4 số thập lục phân. Ví dụ, địa chỉ IP của trang <a href="http://www.hamiltonweather.tk/"><em>www.hamiltonweather.tk</em></a><em> </em>là 2400:cb00:2048:0001:0000:0000:6ca2:c665. Những số</p><p>0 ở đầu mỗi nhóm có thể bỏ đi, do đó địa chỉ trên đây có thể viết là</p><p>2400:cb00:2048:1:0:0:6ca2:c665. Nếu trong địa chỉ IPv6 có một dãy các nhóm gồm toàn con số 0, chúng ta có thể dùng hai dấu hai chấm để kí hiệu thay thế. Ví dụ, địa chỉ 2001:4860:4860:0000:0000:0000:0000:8888 có thể được viết ngắn gọn là 2001:4860:4860::8888. Một cách viết địa chỉ IPv6 khác là kết hợp với cách viết địa chỉ IPv4 bằng cách viết 4 byte cuối của địa chỉ IPv6 dưới dạng địa chỉ IPv4. Ví dụ, địa chỉ FEDC:BA98:7654:3210:FEDC:BA98:7654:3210 có thể được viết là FEDC:BA98:7654:3210:FEDC:BA98:118.84.50.16.</p><p>       Địa chỉ IP rất tiện lợi cho máy tính nhưng gây khó khăn cho con người trong việc ghi nhớ chúng. Vào những năm 50 của thế kỉ XX, G. A. Miller đã khám phá ra hầu hết mọi người có thể ghi nhớ một số có bảy chữ số; một vài người có thể nhớ nhiều hơn chín chữ số và một số người không thể nhớ quá năm chữ số. Chi tiết bạn đọc có thể tìm hiểu bài viết “<em>The Magical Number Seven, Plus or Minus Two: Some Limits on Our Capacity for Processing Information</em>” trong cuốn <em>Psychological Review</em>, tập 63, trang 81-97. Điều đó giải thích tại sao số điện thoại chúng ta thường chia thành các nhóm ba hoặc bốn số và bổ sung thêm mã vùng để giảm bớt các con số cần phải ghi nhớ trong mỗi nhóm. Do đó, một địa chỉ IPv4 có thể có tới mười hai chữ số là quá khó khăn cho hầu hết chúng ta để ghi nhớ chúng.</p><p>Để giúp chúng ta dễ dàng hơn trong việc ghi nhớ các địa chỉ mạng, các nhà thiết kế Internet đã phát minh ra các hệ thống DNS - Domain Name System (hệ thống máy chủ tên miền). DNS giúp chúng ta thay thế các kí hiệu theo dãy số bằng những chuỗi kí tự dễ nhớ hơn với con người, chúng ta gọi chúng là <em>hostname</em>. Ví dụ, thay vì phải nhớ địa chỉ 117.6.86.168 chúng ta có thể nhớ địa chỉ <em>utb.edu.vn</em>. Mỗi một máy chủ phải có ít nhất một hostname. Máy khách cũng thường có một hostname nhưng không có một địa chỉ IP cố định nếu IP này được cấp phát lại sau mỗi lần khởi động.</p><p>       Một số thiết bị có thể có nhiều tên. Ví dụ, cả <em>tbit.vn </em>và <em>tuhoctin.net </em>đều nằm trên một máy chủ Linux. Cái tên <em>tbit.vn </em>thực tế chỉ tới một website chứ không phải là tên một máy chủ cụ thể nào đó. Trong quá khứ, khi một website được chuyển từ một máy chủ tới một máy chủ khác thì tên của nó sẽ được gán lại trên máy chủ mới để luôn trỏ về website trên máy chủ hiện tại.</p><p>        Có những trường hợp một tên có thể tương ứng với nhiều địa chỉ IP. Khi đó, máy chủ nào được lựa chọn để phản hồi yêu cầu từ người dùng sẽ được máy chủ DNS lựa chọn ngẫu nhiên. Tính năng này thường được sử dụng với những website có lượng truy cập rất lớn nên cần mở rộng hệ thống theo chiều ngang để phân chia lượng người dùng tới nhiều hệ thống máy chủ khác nhau. Ví dụ, tên miền <em>google.com.vn </em>thường trỏ tới nhiều máy chủ có địa chỉ khác nhau và thay đổi theo từng thời điểm.</p><p>        Tất cả máy tính kết nối tới Internet đều truy cập một thiết bị gọi là <em>máy chủ dịch vụ tên miền </em>(máy chủ DNS). Đây là máy chủ thực hiện ánh xạ giữa tên miền và địa chỉ IP. Hầu hết máy chủ DNS chỉ biết những địa chỉ của những máy tính trong mạng cục bộ của mình và một số ít địa chỉ trên một mạng khác. Nếu máy khách yêu cầu địa chỉ của một máy nằm bên ngoài mạng cục bộ, máy chủ DNS của mạng cục bộ sẽ gửi yêu cầu tới một máy chủ DNS tại mạng khác đợi trả lời để phản hồi lại yêu cầu đó.</p><p>        Hầu như mọi lúc chúng ta có thể sử dụng hostname và đợi máy chủ DNS xử lý trả lại địa chỉ IP. Khi nào kết nối tới máy chủ DNS, chúng ta không cần lo lắng về việc làm thế nào để có thể ánh xạ giữa tên và địa chỉ IP trên máy chủ DNS cục bộ hay các bộ phận khác trên Internet. Mặc dù vậy, chúng ta cần truy cập ít nhất một máy chủ DNS nếu muốn thực hành một số ví dụ trong giáo trình này. Một số ví dụ cần phải kết nối Internet chứ không làm việc trên một máy độc lập được.</p><p>       Lớp <em>java.net.InetAddress </em>là một sự biểu diễn bậc cao của địa chỉ IP, bao gồm cả IPv4 và IPv6. Lớp này được dùng trong hầu hết các lớp khác như <em>Socket</em>, <em>ServerSocket</em>, <em>URL</em>, <em>DatagramSocket</em>, <em>DatagramPacket</em>… <em>InetAddress </em>cũng bao gồm các thông tin cả về hostname và địa chỉ IP.</p><p>      4.3/ Tìm kiếm bằng địa chỉ IP</p><p>          Khi chúng ta gọi phương thức <em>getByName() </em>với tham số là một địa chỉ IP, nó sẽ tạo ra một đối tượng <em>InetAddress </em>tương ứng với địa chỉ IP mà không kiểm tra DNS. Điều đó có nghĩa là nó có thể tạo một đối tượng <em>InetAddress </em>cho một host không thực sự tồn tại và chúng ta không thể kết nối tới nó. <em>Hostname </em>của đối tượng <em>InetAddress </em>đã tạo ra từ một xâu chứa địa chỉ IP được khởi tạo từ chính xâu đó. Một truy vấn DNS chỉ thực sự diễn ra khi có yêu cầu hostname từ đối tượng đó hoặc là qua phương thức <em>getHostName()</em>. Như vậy thì <em>tbit.vn </em>được xác định từ địa chỉ IP 45.117.83.115 như thế nào. Nếu tại thời điểm hostname được yêu cầu và một tìm kiếm DNS được thực hiện, host tương ứng với địa chỉ IP không thể được tìm thấy thì hostname được gán là chuỗi IP được khai báo. Bẫy lỗi <em>UnknownHostException </em>không được thực hiện.</p><p>    Hostname có tính ổn định hơn nhiều so với địa chỉ IP. Một số dịch vụ có thể chạy trên một hostname nhiều năm nhưng đổi địa chỉ IP nhiều lần. Nêu được lựa chọn giữa hostname và IP thì chúng ta nên chọn hostname, chỉ lựa chọn IP khi hostname không có sẵn.</p><p>       4.4/Các phương thức Get</p><p>         Lớp <em>InetAddress </em>chứa bốn phương thức Get để trả lại chuỗi hostname, địa chỉ IP cả dưới dạng chuỗi và dạng mảng byte.</p><p>public String getHostName()</p><p>public String getCanonicalHostName() public byte[] getAddress()</p><p>public String getHostAddress()</p><p>     Không có các phương thức <em>setHostName() </em>và <em>setAddress() </em>tương ứng, có nghĩa là chúng ta không thể thay đổi các trường đó từ bên ngoài gói <em>java.net</em>. Điều đó giúp cho <em>InetAddress </em>được bảo vệ tốt hơn.</p><p>      Phương thức <em>getHostName() </em>trả về một xâu chứa tên của host với địa chỉ IP được đại diện cho đối tượng <em>InetAddress</em>. Nếu thiết bị tương ứng không có hostname hoặc bị ngăn chặn vì vấn đề bảo mật thì phương thức này sẽ trả về xâu địa chỉ IP. Ví dụ:</p><p>InetAddress machine = InetAddress.getLocalHost(); String localhost = machine.getHostName();</p><p>Phương thức <em>getCanonicalHostName() </em>tương tự phương thức trên nhưng nó mạnh hơn một chút trong việc truy vấn DNS. Phương thức <em>getHostName() </em>chỉ thực hiện gọi DNS khi nó không chắc chắn về hostname. Trong khi đó phương thức <em>getCanonicalHostName() </em>gọi DNS khi nó có thể và có thể sẽ thay thế các kết quả trước đó về việc tìm hostname. Ví dụ:</p><p>InetAddress machine = InetAddress.getLocalHost();</p><p>String localhost = machine.getCanonicalHostName();</p><p>Phương thức <em>getCanonicalHostName() </em>hữu ích khi bắt đầu với một địa chỉ IP thay vì hostname. Trong ví dụ ở dưới, địa chỉ IP 45.117.83.115 được dùng để tạo một InetAddress thông qua phương thức <em>getByName() </em>và sau đó phương thức <em>getCanonicalHostName() </em>sẽ được dùng để lấy được hostname.</p><p><strong><em>Ví dụ 4-3</em></strong><em>. Cho địa chỉ, tìm tên miền (tên host).</em></p><p>import java.net.*;</p><p>public class ReverseTest {</p><p>public static void main (String[] args) throws UnknownHostException</p><p>{</p><p>InetAddress ia = InetAddress.getByName("98.138.219.231"); System.out.println(ia.getCanonicalHostName());</p><p>}</p><p>}</p><p>Kết quả sẽ trả về (tại thời điểm viết):</p><p>% java ReverseTest</p><p>media-router-fp1.prod1.media.vip.ne1.yahoo.com</p><p>         Phương thức <em>getHostAddress() </em>sẽ trả về một xâu chứa địa chỉ IP tương ứng. Ví dụ bên dưới là một ví dụ về việc sử dụng phương thức này.</p><p><strong><em>Ví dụ 4-4</em></strong><em>. Tìm địa chỉ IP của máy cục bộ</em></p><p>import java.net.*; public class MyAddress {</p><p>public static void main(String[] args) { try {</p><p>InetAddress me = InetAddress.getLocalHost(); String dottedQuad = me.getHostAddress();</p><p>System.out.println("Địa chỉ máy cục bộ: " + dottedQuad);</p><p>} catch (UnknownHostException ex) { System.out.println("Không tìm thấy kết quả.");</p><p>}</p><p>}</p><p>}</p><p>     Kết quả (khác nhau trên các máy khác nhau kết nối tới các mạng khác nhau):</p><p>% <strong>java MyAddress</strong></p><p>Địa chỉ máy cục bộ: 192.168.1.21</p><p>        Tất nhiên là địa chỉ IP ở kết quả trên phụ thuộc vào nơi mà đoạn mã được thực thi.</p><p>         Nếu muốn biết địa chỉ IP của một máy (hiếm khi dùng) thì chúng ta sử dụng phương thức <em>getAddress(). </em>Phương thức này sẽ trả về một mảng kiểu byte biểu diễn địa chỉ IP của máy. Byte quan trọng nhất (hay byte đầu tiên trong địa chỉ IP) là byte đầu tiên. Nếu muốn biết chiều dài của mảng, hãy sử dụng thuộc tính <em>length </em>của mảng (sử dụng để kiểm tra loại địa chỉ IPv4 hoặc IPv6).</p><p>InetAddress me = InetAddress.getLocalHost();</p><p>byte[] address = me.getAddress();</p><p>        Chúng ta biết là địa chỉ IP được biểu diễn số nguyên không dấu. Nhưng không giống ngôn ngữ C, kiểu <em>byte </em>của Java có phạm vi từ -128 đến 127. Có nghĩa là những số lớn hơn 127 là những số âm trong kiểu <em>byte </em>của Java. Do đó, nếu muốn sử dụng kết quả kiểu <em>byte </em>được trả về bởi phương thức <em>getAddress() </em>để làm gì đó, chúng ta cần chuyển kiểu <em>byte </em>sang kiểu <em>int </em>bằng cách điều chỉnh thích hợp. Ví dụ như sau:</p><p>int unsignedByte = signedByte &lt; 0 ? signedByte + 256 : signedByte;</p><p>        Trong ví dụ trên, <em>signedByte </em>có thể âm hoặc dương. Phép toán điều kiện <em>? </em>sẽ kiểm tra xem nó có âm hay không. Nếu âm, nó sẽ được cộng với 256 để trở thành số dương kiểu <em>byte </em>và ngược lại thì giữ nguyên.</p><p>         Một lý do để sử dụng mảng <em>byte </em>trả về bởi phương thức <em>getAddress() </em>là để xác định loại địa chỉ IPv4 hay IPv6.</p><p><strong><em>    Ví dụ 4-5</em></strong><em>. Xác định địa chỉ IP v4 hay v6.</em></p><p>import java.net.*;</p><p>public class AddressTests {</p><p>public static int getVersion(InetAddress ia) { byte[] address = ia.getAddress();</p><p>if (address.length == 4) return 4;</p><p>else if (address.length == 16) return 6; else return -1;</p><p>}</p><p>}</p><p>        4.5/ Kiểm tra loại địa chỉ</p><p>Một số địa chỉ IP và một số dải địa chỉ IP có ý nghĩa đặc biệt. Ví dụ, địa chỉ 127.0.0.1 luôn là địa chỉ loopback. Địa chỉ loopback, còn gọi là localhost, là địa chỉ trỏ chính máy hiện tại. Địa chỉ IPv4 trong phạm vi 224.0.0.0 tới 239.255.255.255 là địa chỉ multicast dùng để gửi thông điệp tới nhiều host cùng lúc. Java có 10 phương thức dùng để xác định các loại địa chỉ đặc biệt.</p><ul><li><em>public boolean <strong>isAnyLocalAddress</strong>()</em></li><li><em>public boolean <strong>isLoopbackAddress</strong>()</em></li><li><em>public boolean <strong>isLinkLocalAddress</strong>()</em></li><li><em>public boolean <strong>isSiteLocalAddress</strong>()</em></li><li><em>public boolean <strong>isMulticastAddress</strong>()</em></li><li><em>public boolean <strong>isMCGlobal</strong>()</em></li><li><em>public boolean <strong>isMCNodeLocal</strong>()</em></li><li><em>public boolean <strong>isMCLinkLocal</strong>()</em></li><li><em>public boolean <strong>isMCSiteLocal</strong>()</em></li><li><em>public boolean <strong>isMCOrgLocal</strong>()</em></li></ul><p>       Phương thức <em>isAnyLocalAddress() </em>trả về giá trị true nếu địa chỉ là địa chỉ <em>wildcard</em>, ngược lại trả về giá trị false. Địa chỉ <em>wildcard </em>khớp với bất kỳ địa chỉ nào trên hệ thống mạng cục bộ. Điều này sẽ quan trọng khi một hệ thống có nhiều giao diện mạng, như trường hợp hệ thống máy tính có nhiều card Ethernet và/hoặc card WiFi 802.11. Trong IPv4, địa chỉ wildcard là 0.0.0.0. Trong IPv6, địa chỉ wildcard là 0:0:0:0:0:0:0:0 (hoặc kí hiệu là ∷).</p><p>        Phương thức <em>isLinkLocalAddress() </em>trả về giá trị true nếu địa chỉ này là một địa chỉ IPv6 dạng link-local. Đây là một địa chỉ giúp mạng IPv6 tự cấu hình, giống như DHCP trong mạng IPv4 nhưng không nhất thiết phải dùng một Server trong mạng này. Tất cả địa chỉ dạng link-local đều bắt đầu bởi tám byte FE00:0000:0000:0000. Tám byte tiếp theo là địa chỉ cục bộ, thường được sao chép thừ địa chỉ Ethernet MAC được gán bởi nhà sản xuất thiết bị mạng.</p><p>         Phương thức <em>isSiteLocalAddress() </em>trả về giá trị true nếu một địa chỉ IPv6 là địa chỉ site-local. Địa chỉ loại này bắt đầu bởi tám byte FEC0:0000:0000:0000. Tám byte tiếp theo cũng được sao chép từ địa chỉ Ethernet MAC.</p><p>         Phương thức <em>isMulticastAddress() </em>trả về giá trị true nếu địa chỉ là multicast. Những máy có địa chỉ này sẽ gửi nội dung quảng bá tới một số nhất định các máy khác đã đăng kí thay vì chỉ gửi cho một máy nhất định. Trong IPv4, dải địa chỉ multicast từ 224.0.0.0 đến 239.255.255.255. Trong IPv6, chúng luôn được bắt đầu bởi FF.</p><p>          Phương thức <em>isMCGlobal() </em>trả về giá trị true nếu địa chỉ này là địa chỉ multicast toàn cục (global). Địa chỉ multicast toàn cục sẽ quảng bá tới các máy đăng kí trên toàn bộ hệ thống mạng toàn cầu. Tất cả địa chỉ loại này đều bắt đầu bằng FE. Trong IPv6, chúng bắt đầu bởi FF0E hoặc FF1E phụ thuộc vào việc đó là địa chỉ multicast vĩnh viễn hoặc tạm thời. Trong IPv4, tất cả địa chỉ IPv4 đều có phạm vi toàn cầu.</p><p>          Phương thức <em>isMCOrgLocal() </em>trả về giá trị true nếu nó là địa chỉ dạng multicast tổ chức. Địa chỉ multicast loại này là địa chỉ multicast mà tất cả các máy đăng kí thuộc trong cùng một cơ quan, tổ chức chứ không có máy từ bên ngoài. Địa chỉ loại này bắt đầu bưởi FF08 hoặc FF18 phụ thuộc vào địa chỉ multicast là vĩnh viễn hoặc tạm thời.</p><p>          Phương thức <em>isMCSiteLocal() </em>trả về giá trị true nếu nó là địa chỉ dạng multicast site-wide. Những packet tới máy có địa chỉ loại này chỉ được truyền trong mạng cục bộ của nó. Địa chỉ loại này bắt đầu bưởi FF05 hoặc FF15 phụ thuộc vào địa chỉ multicast là vĩnh viễn hoặc tạm thời.</p><p>          Phương thức <em>isMCLinkLocal() </em>trả về giá trị true nếu nó là địa chỉ multicast subnet-wide. Packet tới địa chỉ loại này chỉ được truyền trong nội bộ mạng con (subnet). Địa chỉ loại này bắt đầu bưởi FF02 hoặc FF12 phụ thuộc vào địa chỉ multicast là vĩnh viễn hoặc tạm thời.</p><p>          Phương thức <em>isMCNodeLocal() </em>trả về giá trị true nếu nó là địa chỉ multicast dạng interface-local. Packet tới địa chỉ loại này không thể truyền ra khỏi giao diện mạng của nó, thậm chí không thể tới một giao diện mạng khác trong cùng node. Địa chỉ loại này bắt đầu bởi FF01 hoặc FF11 phụ thuộc vào địa chỉ multicast là vĩnh viễn hoặc tạm thời.</p><p><em>     Ví dụ 4-6 </em>sau đây là một chương trình đơn giản để kiểm tra địa chỉ nhập trực tiếp từ cửa sổ lệnh dùng 10 phương thức trên.</p><p><strong><em>  Ví dụ 4-6</em></strong><em>. Kiểm tra địa chỉ IP đặc trưng</em></p><p>import java.net.*;</p><p> </p><p>public class <strong>IPCharacteristics </strong>{</p><p> </p><p>public static void main(String[] args) { try {</p><p>InetAddress address = InetAddress.getByName(args[0]); if (address.isAnyLocalAddress()) {</p><p>System.out.println(address + " là địa chỉ wildcard.");</p><p>}</p><p>if (address.isLoopbackAddress()) { System.out.println(address + " là địa chỉ loopback.");</p><p>}</p><p>if (address.isLinkLocalAddress()) { System.out.println(address + " là địa chỉ link-local.");</p><p>} else if (address.isSiteLocalAddress()) { System.out.println(address + " là địa chỉ site-local.");</p><p>} else {</p><p>System.out.println(address + " là địa chỉ toàn cục.");</p><p>}</p><p>if (address.isMulticastAddress()) { if (address.isMCGlobal()) {</p><p>System.out.println(address + " là địa chỉ multicast toàn cục.");</p><p>} else if (address.isMCOrgLocal()) {</p><p>System.out.println(address + " là địa chỉ multicast tổ chức.");</p><p>} else if (address.isMCSiteLocal()) {</p><p>System.out.println(address + " là địa chỉ multicast site-wide.");</p><p>} else if (address.isMCLinkLocal()) {</p><p>System.out.println(address + " là địa chỉ multicast subnet-wide.");</p><p>} else if (address.isMCNodeLocal()) {</p><p>System.out.println(address + " là địa chỉ multicast interface-local.");</p><p>} else {</p><p>System.out.println(address + " là địa chỉ multicast</p><p>chưa xác định.");</p><p>}</p><p>} else {</p><p>System.out.println(address + " là địa chỉ unicast.");</p><p>}</p><p>} catch (UnknownHostException ex) { System.err.println("Không phân tích được địa chỉ này.");</p><p>}</p><p>}</p><p>}</p><p>     Dưới đây là một số kết quả khi chạy đoạn mã trên với các địa chỉ IPv4 và IPv6 khác nhau.</p><p><strong>$ java IPCharacteristics 127.0.0.1</strong></p><p>/127.0.0.1 là địa chỉ loopback.</p><p>/127.0.0.1 là địa chỉ toàn cục.</p><p>/127.0.0.1 là địa chỉ unicast.</p><p><strong>$ java IPCharacteristics 192.168.254.32</strong></p><p>/192.168.254.32 là địa chỉ multicast site-wide.</p><p>/192.168.254.32 là địa chỉ unicast.</p><p><strong>$ java IPCharacteristics </strong><a href="http://www.oreilly.com/"><strong>www.oreilly.com</strong></a><strong> </strong><a href="http://www.oreilly.com/208.201.239.37">www.oreilly.com/208.201.239.37</a> là địa chỉ toàn cục. <a href="http://www.oreilly.com/208.201.239.37">www.oreilly.com/208.201.239.37</a> là địa chỉ unicast.</p><p><strong>$ java IPCharacteristics 224.0.2.1</strong></p><p>/224.0.2.1 là địa chỉ toàn cục.</p><p>/224.0.2.1 là địa chỉ multicast toàn cục.</p><p><strong>$ java IPCharacteristics FF01:0:0:0:0:0:0:1</strong></p><p>/ff01:0:0:0:0:0:0:1 là địa chỉ toàn cục.</p><p>/ff01:0:0:0:0:0:0:1 là địa chỉ multicast interface-local.</p><p><strong>$ java IPCharacteristics FF05:0:0:0:0:0:0:101</strong></p><p>/ff05:0:0:0:0:0:0:101 là địa chỉ toàn cục.</p><p>/ff05:0:0:0:0:0:0:101 là địa chỉ multicast site-wide.</p><p><strong>$ java IPCharacteristics 0::1</strong></p><p>/0:0:0:0:0:0:0:1 là địa chỉ loopback.</p><p>/0:0:0:0:0:0:0:1 là địa chỉ toàn cục.</p><p>/0:0:0:0:0:0:0:1 là địa chỉ unicast.</p><p>      4.6/ Kiểm tra khả năng kết nối tốt(reachable)</p><p>             Lớp <em>InetAddress </em>có hai phương thức <em>isReachable() </em>để kiểm tra xem một nút mạng cụ thể có kết nối từ host hiện tại được không. Kết nối có thể bị khóa vì rất nhiều lí do, có thể là firewall, máy chủ proxy, đứt cáp hay host không hoạt động tại thời điểm chúng ta thử kết nối.</p><p>public boolean <strong>isReachable</strong>(int timeout) throws IOException</p><p>public boolean <strong>isReachable</strong>(NetworkInterface interface, int ttl, int timeout) throws IOException</p><p>      Hai phương thức này sử dụng công cụ truy vết <em>traceroute </em>để chỉ ra một địa chỉ có phản hồi hay không. Nếu host được kiểm tra trả lời trong thời gian <em>timeout </em>tính bằng mili giây, phương thức sẽ trả về giá trị <em>true </em>và ngược lại trả về giá trị <em>false</em>. Ngoại lệ <em>IOException </em>sẽ được gọi nếu xảy ra một lỗi mạng. Phương thức thứ hai có thể tham số <em>NetworkInterface </em>để chỉ định giao diện mạng được sử dụng và thời gian tồn tại <em>ttl </em>(time-to-live) là giá trị số lớn nhất xác định thời gian kết nối trước khi nó bị bỏ qua.</p><p>     4.7/ Các phương thức Object</p><p>        Giống như những lớp khác trong Java, <em>java.net.InetAddress </em>kế thừa từ lớp <em>java.lang.Object</em>. Vì vậy, lớp này cũng kế thừa tất cả các phương thức của lớp này. Lớp <em>InetAddress </em>override ba phương thức sau:</p><ul><li><em>public boolean <strong>equals</strong>(Object o)</em></li><li><em>public int <strong>hashCode</strong>()</em></li><li><em>public String <strong>toString</strong>()</em></li></ul><p>Hai object của lớp <em>InetAddress </em>bằng nhau nếu chúng có cùng địa chỉ IP. Ví dụ, một object <em>InetAddress </em>cho <em>tbit.vn </em>sẽ bằng với một object cho <em>tuhoctin.net </em>vì cả hai tên miền này đều được trỏ về địa chỉ một địa chỉ IP. <em>Ví dụ 4-7 </em>sẽ tạo các object tương ứng với hai tên miền này và sẽ cho chúng ta biết chúng cùng một địa chỉ IP nếu không có gì thay đổi.</p><p><strong><em>Ví dụ 4-7</em></strong><em>. Kiểm tra <strong>tbit.vn </strong>và <strong>tuhoctin.net </strong>có cùng địa chỉ IP không?</em></p><p>import java.net.*;</p><p> </p><p>public class <strong>IBiblioAliases </strong>{</p><p>public static void main(String args[]) { try {</p><p>InetAddress ibiblio = InetAddress.getByName("tbit.vn"); InetAddress helios = InetAddress.getByName("tuhoctin.net"); if (ibiblio.equals(helios)) {</p><p>System.out.println("tbit.vn thuộc cùng máy chủ với tuhoctin.net");</p><p>} else {</p><p>System.out.println("tbit.vn không thuộc cùng máy chủ với tuhoctin.net");</p><p>}</p><p>} catch (UnknownHostException ex) { System.out.println("Không tìm thấy host tương ứng.");</p><p>}</p><p>}</p><p>}</p><p>     Kết quả chạy đoạn code trên tại thời điểm viết tài liệu này:</p><p><strong>% java IBiblioAliases</strong></p><p>tbit.vn thuộc cùng máy chủ với tuhoctin.net</p><p>       Phương thức <em>hashcode() </em>trả về một số nguyên tương ứng với địa chỉ IP. Nếu hai object <em>InetAddress </em>cùng địa chỉ IP, chúng sẽ cùng mã hash code, mặc dù hostname có thể khác nhau.</p><p>        Phương thức <em>toString() </em>trả về một đoạn văn bản ngắn mô tả object. <em>Ví dụ 4- 1 </em>và <em>Ví dụ 4-2 </em>đã thực hiện gọi phương thức này. Kết quả trả về của nó dạng:</p><p>hostname/địa chỉ IP</p><p>         Không phải tất cả object <em>InetAddress </em>đều có hostname. Nếu chúng không có hostname, địa chỉ IP sẽ được dùng thay thế trong phiên bản Java 1.3 trở về trước, còn đối với Java 1.4 trở về sau nó sẽ trả về một xâu rỗng.</p><p>       4.8/InetAddress và Inet6Address</p><p>        Java sử dụng hai lớp <em>Inet4Address </em>và <em>Inet6Address </em>để phân biệt địa chỉ IPv4 và địa chỉ IPv6.</p><ul><li><em>public final class <strong>Inet4Address </strong>extends InetAddress</em></li><li><em>public final class <strong>Inet6Address </strong>extends InetAddress</em></li></ul><p>        Hầu hết mọi khi, chúng ta không thực sự nên quan tâm tới địa chỉ IPv4 hay IPv6. Trong tầng ứng dụng, chúng ta không cần phải biết về điều đó. Nhưng cũng có nhiều khi chúng ta cần chúng để làm mọi việc nhanh hơn. Lớp <em>Inet4Address </em>override nhiều phương thức của lớp <em>InetAddress </em>không thay đổi tới các phương thức <em>public</em>. Lớp <em>Inet6Address </em>cũng tương tự nhưng nó thêm một phương thức không có trong lớp cha:</p><p><em>public boolean <strong>isIPv4CompatibleAddress</strong>()</em></p><p>        Phương thức này trả về giá trị đúng nếu và chỉ nếu đó là một địa chỉ IPv4 có thể nằm trong một IPv6, có nghĩa là chỉ có 4 byte cuối là khác không. Do đó, địa chỉ IP sẽ có dạng 0:0:0:0:0:0:0:xxxx. Trong trường hợp này chúng ta cũng có thể tách lấy bốn byte cuối cùng từ phương thức <em>getBytes() </em>để tạo ra một object <em>Inet4Address</em>. Tuy nhiên chúng ta hiếm khi thực hiện điều này.</p><p>      4.9/ Lớp Network Interface</p><p>           Lớp <em>NetwordInterface </em>đại diện cho một địa chỉ IP cục bộ. Nó có thể là một giao diện mạng vật lý như một card Ethernet bổ sung (firewall hoặc router) hay một giao diện mạng ảo của cùng một thiết bị phần cứng với một địa chỉ IP khác. Lớp <em>NetworkInterface </em>liệt kê tất cả các địa chỉ cục bộ và tạo ra các object <em>InetAddress </em>tương ứng. Những object đó sẽ được dùng để tạo socket cho Client hoặc Server.</p><h3>        Một số phương thức</h3><p>           Vì object <em>NetworkInterface </em>đại diện cho một phần cứng vật lý hoặc địa chỉ mạng ảo nên có không được khởi tạo một cách tùy tiện. Giống như lớp <em>InetAddress</em>, có một số phương thức dùng để tạo ra object <em>NetworkInterface </em>với từng giao diện mạng cụ thể. Chúng ta có thể tạo object <em>NetworkInterface </em>từ một địa chỉ IP, từ hostname hoặc enumeration.</p><p><em>public static NetworkInterface <strong>getByName</strong>(String name) throws SocketException</em></p><p>            Phương thức <em>getByName() </em>trả về một object <em>NetworkInterface </em>từ một tên cụ thể. Nếu không có một giao diện mạng nào tương ứng, nó sẽ trả về giá trị <em>null</em>. Rất hiếm khi xảy ra lỗi, nhưng nếu có chúng sẽ được xử lý bởi <em>SocketException</em>.</p><p>             Định dạng tên phụ thuộc vào hệ điều hành. Trên các dòng hệ điều hành Unix, tên của các giao diện Ethernet có dạng eth0, eth1,… Địa chỉ <em>loopback </em>có tên dạng “lo”. Trên dòng hệ điều hành Windows, tên là chuỗi dạng “CE31” và “ELX100” phụ thuộc vào tên của Nhà sản xuất và dòng sản phẩm phần cứng gắn với giao diện mạng. Dưới đây là ví dụ về thao tác với <em>NetworkInterface </em>với dòng hệ điều hành Unix:</p><p>try {</p><p>NetworkInterface ni = NetworkInterface.getByName("eth0"); if (ni == null) {</p><p>System.err.println("No such interface: eth0");</p><p>}</p><p>} catch (SocketException ex) { System.err.println("Could not list sockets.");</p><p>}</p><p><em>         public static NetworkInterface <strong>getByInetAddress</strong>(InetAddress address) throws SocketException</em></p><p>             Phương thức <em>getByInetAddress() </em>trả về một object <em>NetworkInterface </em>tương ứng với một địa chỉ IP cụ thể. Nếu không có giao diện mạng nào tương ứng tại máy cục bộ, nó sẽ trả về giáo trị <em>null</em>. Nếu có lỗi nào đó, nó sẽ throws <em>SocketException</em>. Dưới đây là một ví dụ tìm một giao diện mạng tương ứng với địa chỉ loopback:</p><ul><li><em>public Socket(String host, int port)</em></li></ul><p><em>throws</em><em> </em><em>UnknownHostException,</em><em> </em><em>IOException</em></p><p><em>public static Enumeration <strong>getNetworkInterfaces</strong>() throws SocketException</em></p><p>          Phương thức <em>getNetworkInterfaces() </em>trả về một đối tượng thuộc lớp <em>java.util.Enumeration </em>liệt kê tất cả các giao diện mạng trên máy cục bộ. <em>Ví dụ 4-8 </em>là một chương trình đơn giản để liệt kê các giao diện mạng trên máy cục bộ.</p><p><strong><em>          Ví dụ 4-8</em></strong><em>. Liệt kê các giao diện mạng của máy cục bộ.</em></p><p class="align-center"> </p><p>           Và kết quả với máy có nhiều kết nối mạng sẽ như sau:</p><p><em>try {</em></p><p><em>Socket toYahoo = new Socket("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>", 80);</em></p><p><em>// Hoạt động gửi /nhận dữ liệu</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p><em> </em></p><p><em>System.err.println(ex);</em></p><p><em>}</em></p><p>        Trong kết quả trên chúng ta có thể thấy máy tính có 2 kết nối mạng thông qua Ethernet với địa chỉ IP lần lượt là 192.168.210.122 và 152.2.210.122. Địa chỉ loopback cho localhost luôn là 127.0.0.1.</p><p> </p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/123VuPhuc/myblog.git/authors/vu-tran-hoang-phuc/" rel="author">Vũ Trần Hoàng Phúc</a></h3></div></div></div></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/123VuPhuc/myblog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/123VuPhuc/myblog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>