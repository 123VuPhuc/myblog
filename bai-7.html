<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 7:Kỹ thuật lập trình phân tán RMI - Blog của tôi</title><meta name="description" content="7.1/ Khái niệm chung Lập trình đối tượng phân tán là một vấn đề hấp dẫn của công nghệ phân tán phần mềm ngày này. Java là ngôn ngữ đi tiên phong với RMI (Remote Method Invocation), một kỹ thuật cài đặt các đối tượng&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/123VuPhuc/myblog.git/bai-7.html"><link rel="alternate" type="application/atom+xml" href="https://github.com/123VuPhuc/myblog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/123VuPhuc/myblog.git/feed.json"><meta property="og:title" content="Bài 7:Kỹ thuật lập trình phân tán RMI"><meta property="og:image" content="https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:site_name" content="Blog của tôi"><meta property="og:description" content="7.1/ Khái niệm chung Lập trình đối tượng phân tán là một vấn đề hấp dẫn của công nghệ phân tán phần mềm ngày này. Java là ngôn ngữ đi tiên phong với RMI (Remote Method Invocation), một kỹ thuật cài đặt các đối tượng&hellip;"><meta property="og:url" content="https://github.com/123VuPhuc/myblog.git/bai-7.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/123VuPhuc/myblog.git/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/123VuPhuc/myblog.git/bai-7.html"},"headline":"Bài 7:Kỹ thuật lập trình phân tán RMI","datePublished":"2024-12-29T11:11+07:00","dateModified":"2024-12-29T21:01+07:00","image":{"@type":"ImageObject","url":"https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920},"description":"7.1/ Khái niệm chung Lập trình đối tượng phân tán là một vấn đề hấp dẫn của công nghệ phân tán phần mềm ngày này. Java là ngôn ngữ đi tiên phong với RMI (Remote Method Invocation), một kỹ thuật cài đặt các đối tượng&hellip;","author":{"@type":"Person","name":"Vũ Trần Hoàng Phúc","url":"https://github.com/123VuPhuc/myblog.git/authors/vu-tran-hoang-phuc/"},"publisher":{"@type":"Organization","name":"Vũ Trần Hoàng Phúc","logo":{"@type":"ImageObject","url":"https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="page-template"><a href="/about-me"><label style="color: #007BFF; cursor: pointer;">Click here to read my About Me page</label></a><header class="top js-header"><a class="logo" href="https://github.com/123VuPhuc/myblog.git/"><img src="https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg" alt="Blog của tôi" width="1920" height="1080"></a></header><main class="page"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 7:Kỹ thuật lập trình phân tán RMI</h1></div></header></div><div class="entry-wrapper content__entry"><p>7.1/ Khái niệm chung</p><p>            Lập trình đối tượng phân tán là một vấn đề hấp dẫn của công nghệ phân tán phần mềm ngày này. Java là ngôn ngữ đi tiên phong với RMI (Remote Method Invocation), một kỹ thuật cài đặt các đối tượng phân tán vô cùng hiệu quả và linh hoạt.</p><p>        Thông thường các chương trình của chúng ta được viết dưới dạng thủ tục - hàm và việc các hàm gọi lẫn nhau và truyền tham số chỉ xảy ra ở máy cục bộ. Kỹ thuật RMI - mang ý nghĩa là triệu gọi phương thức từ xa là cách thức giao tiếp giữa các đối tượng trong Java có mã lệnh cài đặt nằm ở trên các máy khác nhau có thể triệu gọi lẫn nhau.</p><ul><li><em>public InetAddress getAddress( ): </em>Phương thức này trả về đối tượng InetAddress của máy</li></ul><p>trạm từ xa chứa trong gói tin nhận.</p><ul><li><em>public int getPort( ): </em>Trả về số hiệu cổng của máy trạm từ xa chứa trong gói</li><li><em>public byte[] getData( )</em>: Trả về dữ liệu chứa trong gói tin dưới dạng mảng</li><li><em>public int getLength( ): </em>Trả về kích cỡ của dữ liệu chưa trong gói tin tính theo số</li></ul><p>Tương ứng với 4 phương thức getXXXX..(), lớp DatagramPacket có 4 phương thức setXXXX..() để thiết lập 4 tham số cho gói tin gửi.</p><p class="align-center"><em>Hình 7.1: Mô hình RMI tổng quát</em></p><p>   7.2/ Kỹ thuật lập trình RMI theo mô hình Client/Server</p><p>        Để giải quyết một số vấn đề trong việc truyền thông giữa Client ó Server. RMI  không gọi trực tiếp mà thông qua lớp trung gian. Lớp này tồn tại ở cả hai phía Client và Server:</p><ul><li>Lớp ở Client gọi là <em>Stub</em></li><li>Lớp ở máy Server gọi là <em>Skel </em>(Skeleton) </li></ul><p>         Các đặc tính của RMI:</p><ul><li>RMI là mô hình đối tượng phân tán của Java, nó giúp cho việc truyền thông giữa các đối tượng phân tán được dễ dàng hơn.</li><li>RMI là API bậc cao được xây dựng dựa trên lập trình</li></ul><ul><li>RMI không những cho phép chúng ta truyền dữ liệu giữa các đối tượng trên các hệ thống máy tính khác nhau và còn gọi được các phương thức trong các đối tượng ở xa.</li><li>Việc truyền dữ liệu giữa các máy khác nhau được sử lý một cách trong suốt bởi máy ảo Java (Java Virtual Machine).</li><li>RMI cung cấp cơ chế callback, nó cho phép Server triệu gọi các phương thức ở Client.</li></ul><figure class="post__image"><img loading="lazy" src="https://github.com/123VuPhuc/myblog.git/media/posts/12/Picture16.png" alt="" width="1515" height="861" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture16-xs.png 640w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture16-sm.png 768w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture16-md.png 1024w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture16-lg.png 1366w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture16-xl.png 1600w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture16-2xl.png 1920w"></figure><p class="align-center"><em>Hình 7.2: Kiến trúc cơ bản của RMI</em></p><p>Kiến trúc của RMI:</p><ul><li>Remote interface: Nên extend từ <em>rmi.Remote</em>. Nó khai báo tất cả các phương thức mà Client có thể triệu gọi. Tất cả các phương thức trong interface này nên <em>throws RemoteException</em>.</li><li>Remote implementation: Được thực thi từ Remote interface và mở rộng từ <em>UnicastRemoteObject</em>. Triển khai các phương thức được khai báo trong interface tại đây. Nó là một Remote Object thực sự. Phát sinh hai lớp trung gian Stub và Skeleton.</li><li>Server class bao gồm:</li></ul><ul style="list-style-type: circle;"><li>      Các class được hiện thực trên</li><li>       RMI registry: Bộ đăng kí này sẽ đăng kí một Remote object với Naming Registry. Giúp các Remote object được chấp nhận khi gọi các phương thức từ xa.</li></ul><ul><li>Client class: Truy vấn trên tên Remote object trên RMI registry, thông qua Stub để gọi các phương thức trên Server.</li></ul><p>Truyền tin trong RMI:</p><ul><li>RMI sử dụng lớp trung gian để truyền tin Skeleton và</li><li>Lớp Stub dùng ở</li><li>Lớp Skeleton dùng ở</li><li>Java tạo ra các lớp trung</li><li>RMI sử dụng các TCP Cách thức hoạt động của RMI:</li><li>Server RMI phải đăng ký với 1 dịch vụ tra tìm và đăng ký tên miền.</li><li>Sau khi Server được đăng ký, nó sẽ chờ các yêu cầu của RMI</li><li>Các ClientRMI sẽ gửi thông điệp RMI để gọi một phương thức trên một đối tượng từ xa.</li><li>Ứng dụng Client yêu cầu một tên dịch vụ cụ thể và nhận một URL trỏ tới tài nguyên từ xa.</li></ul><p>Mô hình lập trình phân tán RMI:</p><figure class="post__image"><img loading="lazy" src="https://github.com/123VuPhuc/myblog.git/media/posts/12/Picture17.png" alt="" width="358" height="182" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture17-xs.png 640w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture17-sm.png 768w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture17-md.png 1024w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture17-lg.png 1366w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture17-xl.png 1600w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture17-2xl.png 1920w"></figure><p class="align-center"><em>Hình 7.3: Các bước lập trình theo kỹ thuật RMI</em></p><ul><li>Bước 1: Tạo project cho Client và</li><li>Bước 2: Tạo Interface dùng chung cho cả Client và</li><li>Bước 3: Hiện thực Interface ở</li><li>Bước 4: Viết chương trình phía</li><li>Bước 5: Viết chương trình phía</li></ul><p>  7.3/ Một số ví dụ</p><p><strong><em>        Ví dụ 7-1</em></strong><em>. Viết chương trình liệt kê các số nguyên tố từ 1 tới N, với N là một số nguyên dương, sử dụng kỹ thuật lập trình RMI. Phương thức kiểm tra số nguyên tố được triệu gọi từ xa.</em></p><p><em>        Bước 1</em>: Tạo 2 project <em>RMI_Prime_Client </em>và <em>RMI_Prime_Server</em>.</p><p><em>        Bước 2</em>: Trong project <em>RMI_Prime_Server </em>tạo một package đặt tên là <em>Core</em>.</p><p>     Trong package này tạo một interface đặt tên là <em>PrimeInterface </em>như sau:</p><p>Giả sử giao diện có tên TT, chúng ta có thể khai báo nó như sau:</p><p><em>//TT.java</em></p><p><em>import java.rmi.*;</em></p><p><em>public interface   TT   extends                   Remote</em></p><p><em>{</em></p><p><em>public int   add(int x,int y) throws       RemoteException;</em></p><p><em>}</em></p><p>           Chú ý rằng trong kỹ thuật lập trình RMI các Interface phải kế thừa lớp <em>Remote</em>, các phương thức của nó phải <em>throws RemoteException</em>.</p><p>            Phương thức <em>isPrime(int x) </em>dùng để kiểm tra một số <em>x </em>có phải là số nguyên tố hay không. Phương thức này chưa được hiện thực mà mới chỉ khai báo.</p><p>            Sao chép package <em>Core </em>sang project <em>RMI_Prime_Client </em>(bao gồm cả <em>PrimeInterface</em>).</p><p><em>         Bước 3</em>: Hiện thực <em>PrimeInterface </em>phía Server. Trong project <em>RMI_Prime_Server </em>tạo một package mới đặt tên là <em>RMI</em>. Trong package này tạo một lớp mới đặt tên là <em>Prime</em>.</p><p>       Hiện thực hóa interface trong lớp này như sau:</p><p><strong>Bước 2: </strong>Khai báo lớp thực thi giao diện TT để cài dặt phương thức add(). Giả sử lớp có tên là TTImpl:</p><p><em>//TTImpl.java </em><em>import java.rmi.*;</em></p><p><em>class TTImpl implements   TT</em></p><p><em>{</em></p><p><em>public int add(int x,int y) throws                  RemoteException</em></p><p><em>{</em></p><p><em>return (x+y);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>          Bước 4</em>: Lập trình cho Server. Trong package <em>RMI </em>tạo class đặt tên là <em>Server</em>. Chúng ta tạo một <em>Registry </em>trên cổng bất kỳ (chẳng hạn 3210) rồi ràng buộc (bind) một <em>PrimeService </em>cho một đối tượng thuộc lớp <em>Prime </em>trên đó.</p><p class="align-center"> </p><p><strong>Bước 3</strong>: Xây dựng chương trình server. Chương trình server phải thực hiện 3 vấn đề cốt lõi sau</p><p>đây:</p><p class="align-center"> </p><ul><li>Tạo đối tượng có phương thức cho phép gọi từ xa và trả về tham chiếu đến giao diện của chúng. Ví dụ:</li></ul><p><em>TT</em><em>    c=new    TTImpl();</em></p><ul><li>Đăng ký đối tượng có phương thức cho phép gọi từ xa với máy ảo java, thông qua trình đăng ký của JDK hoặc do người lập trình tự định nghĩa, bằng cách sử dụng phương thức <em>exportObject() </em>của lớp UnicastRemoteObject thuộc gói java.rmi.server. Phương thưc <em>exportObject() </em>có thể khai báo như sau:</li></ul><p><em>UnicastRemoteObject.exportObject(Obj);</em></p><ul><li>Gán cho đối tượng có phương thức cho phép gọi từ xa một tên dưới dạng chuỗi URL để thông qua chuỗi tên đó, các đối tượng client có thể truy xuất tìm thấy đối tượng trên mạng. Để thực hiện việc đó, lớp java.rmi.Naming cung cấp phương thức <em>bind() </em>hoặc <em>rebind(). </em>Phưong thức <em>bind() </em>có dạng sau:</li></ul><p><em>Naming.bind(“rmi//&lt;host&gt;[:port]/ObjName”,</em><em> </em><em>Obj);</em></p><p><em>          Bước 5</em>: Lập trình cho Client. Trong project <em>RMI_Prime_Client </em>tạo một package đặt tên là <em>RMI</em>. Trong package này tạo một JFrame Form đặt tên là <em>Client</em>. Thiết kế giao diện cho <em>Client </em>như sau:</p><p>Chương trình server được viết như sau:</p><p><em>//TTServer.java </em><em>import java.rmi.*;</em></p><p><em>import java.rmi.serrver.*; class TTServer{</em></p><p><em>public static void main(String[] args)</em></p><p><em>{</em></p><p><em>try{</em></p><p><em>//Tao doi tuong</em></p><p><em>TT</em><em>   c=new   TTImpl();</em></p><p><em>//dang ky voi mays ao java UnicastRemoteObject.exportObject(c);</em></p><p><em>//Gan chuoi URL Naming.bind(“rmi://localhost/Obj”, c); System.out.println(“Server RMI da san sang. ”);</em></p><p><em>}</em></p><p><em>catch(Exception</em><em>   e)</em></p><p><em>{</em></p><p><em>System.out.println(e);</em></p><p><em>}</em></p><p><em>}}</em></p><p class="align-center"><em>Hình 7.4: Thiết kế giao diện liệt kê số nguyên tố</em></p><p>Lập trình cho sự kiện người dùng nhấp chuột vào nút <em>Lấy kết quả </em>như sau:</p><p> </p><p><strong>Bước 4: X</strong>ây dựng chương trình client, giả sử chương trình là lớp TTClient.java.. Chương trình client phải có nhiệm vụ sau:</p><ul><li>Truy xuất tìm đối tượng có phương thức cho phép gọi từ xa thông qua chuỗi tên URL đa được chương trình server gán cho đối tượng. Bằng cách client sử dụng phương thức <em>lookup() </em>của lớp Naming hỏi bộ đăng ký thông qua số cổng cụ thể đã được định nghĩa trong chuỗi URL. Nếu tìm thấy, server sẽ trả về tham chiếu đến đối tượng từ xa có kiểu giao diện của đối tượng.</li><li>Gọi thi hành phương thức từ xa thông qua biến tham chiếu tới đối tượng từ</li></ul><p>Chương trình client:</p><p><em>//TTClient.java </em><em>import java.rmi.*; class TTClient{</em></p><p><em>public static void main(String[] args)</em></p><p><em>{</em></p><p><em>try{</em></p><p><em>TT</em><em> x=(TT)Naming.lookup(“rmi://localhost/Obj”); int a=10, b=20;</em></p><p><em>System.out.println(“Tong</em><em>    cua      a=”+a+”      voi   b=”+b+” la s=”+x.add(a,b));</em></p><p><em>}</em></p><p><em>catch(Exception e)</em></p><p><em>{</em></p><p><em>System.out.println(e);</em></p><p><em>}</em></p><p><em>}}</em></p><p>          Chạy <em>Server </em>trước, sau đó chạy <em>Client</em>. Trong form xuất hiện, nhập giá trị lớn nhất bất kỳ, giả sử là 500. Nhấn nút <em>Lấy kết quả</em>, chúng ta nhận được như hình bên dưới:</p><p><strong>Bước thứ nhất</strong>: Biên dịch các tệp chương trình thành dạng bytecode dùng trình javac.exe. Trong chương trình trên có 4 tệp:</p><p><em>javac.exe</em></p><p><em>TT.java</em><em>            ----------------------------&gt;TT.class        (1)</em></p><p><em>TTImpl.java</em><em>    ----------------------------&gt;TTImpl.class (2)</em></p><p><em>TTServer.java</em><em> </em><em>----------------------------&gt;TTServer.class</em><em>                                                                   (3)</em></p><p><em>TTClient.java</em><em> </em><em>-----------------------------&gt;TTClient.class</em><em>                                                                   (4)</em></p><p class="align-center"><em>Hình 7.5: Kết quả liệt kê số nguyên tố với máy chủ RMI</em></p><p><strong><em>          Ví dụ 7-2</em></strong><em>. Viết chương trình tìm ước số chung lớn nhất và kiểm tra tính nguyên tố của hai số nguyên dương bất kỳ, sử dụng kỹ thuật lập trình RMI. Phương thức kiểm tra số nguyên tố và phương thức tính ước số chung lớn nhất của hai số được triệu gọi từ xa.</em></p><p><em>        Bước 1</em>: Tạo 2 project <em>RMI_XuLySo_Client </em>và <em>RMI_XuLySo_Server</em>.</p><p><em>         Bước 2</em>: Trong project <em>RMI_XuLySo_Server </em>tạo một package đặt tên là <em>Core</em>. Trong package này tạo một interface đặt tên là <em>NumberInterface </em>với nội dung như sau:</p><p><strong>Bước thứ 2: </strong>Phát sinh các tệp đối tượng trung gian _stub và _skel bằng cách sử dụng trình dịch rmic.exe của JDK để dịch tệp đối tượng có phương thức cho phép gọi từ xa TTImpl:</p><p><em>rmic</em><em>         TTImpl         [Enter]</em></p><p>Sau khi dich, 2 tệp mới được tạo ra:</p><p><em>TTImpl_Stub.class</em><em> (5)</em></p><p><em>TTImpl_Skel.class</em><em> (6)</em></p><p>          Phương thức <em>ucln(int a, int b) </em>dùng để dùng để tìm ước số chung lớn nhất của hai số nguyên <em>a </em>và <em>b</em>.</p><p>          Phương thức <em>isPrime(int x) </em>dùng để kiểm tra một số <em>x </em>có phải là số nguyên tố hay không.</p><p>          Sao chép package <em>Core </em>sang project <em>RMI_XuLySo_Client</em>.</p><p><em>          Bước 3</em>: Hiện thực <em>NumberInterface</em>. Trong project <em>RMI_XuLySo_Server </em>tạo một package mới đặt tên là <em>RMI</em>. Trong package này tạo một lớp mới đặt tên là <em>NumberClass</em>.</p><p>          Hiện thực hóa interface trong lớp này như sau:</p><p><strong>Bước 1</strong>: Phân bố các tệp chương trình phù hợp từ (1) đến (6) về máy client và server. Cụ thể:</p><ul><li>Phía client: (1), (4), (5)</li><li>Phía server: (1), (2), (3), (5), (6)</li></ul><p><em>          Bước 4</em>: Lập trình cho Server. Trong package <em>RMI </em>tạo class đặt tên là <em>Server</em>. Chúng ta tạo một <em>Registry </em>trên cổng bất kỳ (chẳng hạn 3210) rồi ràng buộc (bind) một tên là <em>NumberService </em>cho một đối tượng thuộc lớp <em>NumberClass </em>trên đó.</p><p class="align-center"> </p><p><strong>Bước 2: </strong>Chạy chương trình Thực hiện mở 3 của sổ lênh:</p><ul><li>Cửa sổ thứ nhất: Chạy trình đăng ký exe với cú pháp sau:</li></ul><p><em>rmiregistry</em><em>    [porrt]    [Enter]</em></p><ul><li>Của sổ thứ 2: Chạy chương trình server:</li></ul><p><em>java  TTServer        [Enter]</em></p><ul><li>Của sổ thứ 3: Chạy chương trình client:</li></ul><p><em>java  TTClient         [Enter]</em></p><p><em>          Bước 5</em>: Lập trình cho Client. Trong project <em>RMI_XuLySo_Client </em>tạo một package đặt tên là <em>RMI</em>. Trong package này tạo một JFrame Form đặt tên là <em>Client</em>. Thiết kế giao diện cho <em>Client </em>như sau:</p><figure class="post__image"><img loading="lazy" src="https://github.com/123VuPhuc/myblog.git/media/posts/12/Picture18.png" alt="" width="1863" height="752" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture18-xs.png 640w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture18-sm.png 768w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture18-md.png 1024w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture18-lg.png 1366w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture18-xl.png 1600w, https://github.com/123VuPhuc/myblog.git/media/posts/12/responsive/Picture18-2xl.png 1920w"></figure><p class="align-center"><em>Hình 7.9: Thiết kế form xử lý xâu theo kỹ thuật RMI</em></p><p>        Lập trình cho sự kiện người dùng nhấp chuột vào nút <em>Xử lý </em>như sau:</p><p class="align-center"> </p><p><strong>Step 3: </strong>Bộ đăng ký rmiregistry tìm đối tượng, nếu thấy nó trả về tham chiếu đến đối tượng từ xa cho client bằng quá trình 3 thông qua lớp giao diện(interface) mà đối tượng từ xa cung cấp.</p><p><strong>Step 4: </strong>Dựa vào giao diện(TT) đối tượng TTClient sẽ gọi phương thức từ xa của đối tượng trên server(TTImpl) thông qua tham chiếu nhận được ở bước 3 bằng quá trình 4.</p><p><strong>Step 5: </strong>Khi một phương thức được gọi, lời gọi sẽ được chuyển tới đối tượng trung gian _Stub và</p><p>được đóng gói chuyển qua mạng theo giao thức JRMP tời đối tượng _Skel phía server.</p><p><strong>Step 6: </strong>Đối tượng Skel phía server sẽ khôi phục lại lời gọi và gọi thi hành phương thức từ xa bằng quá trình 6.</p><p><strong>Step 7: </strong>Sau khi phương thức tư xa thi hành xong, kết quả sẽ được đối tượng _Skel trả về cho đối tượng client bằng một quá trình truyền thông ngược với quá trình trên.</p><p> </p><p>       Chạy <em>Server </em>trước, sau đó chạy <em>Client</em>. Trong form xuất hiện, nhập một xâu bất kỳ, chọn chức năng cần xử lý và nhấn nút <em>Xử lý</em>, chúng ta nhận được kết quả như hình bên dưới:</p><p><strong>Bước 1: </strong>Xây dựng lớp BOX thực thi giao diện Serializable thuộc gói java.io để đối tượng có thể truyền theo kiểu tham trị.</p><p>//BOX.java import java.io.*:</p><p>class BOX implements Serializable</p><p>{</p><p>int   w,h,d;</p><p>BOX(){</p><p>w=10; h=20; d=15;</p><p>}}</p><p>Các bước 2 trở đi tương tự như kỹ thuật xây dựng chương trình RMI đã khảo sát ở phần trên.</p><p><strong>Bước 2: </strong>Xây dựng giao diện để khai báo phương thức changeOBject() cho phép gọi từ xa</p><p>//BB.java</p><p>import java.rmi.*;</p><p>interface BB extends   Remote</p><p>{</p><p>public BOX   changeObject(BOX              obj) throws              RemoteException;</p><p class="align-center"> </p><p>}</p><p class="align-center"><em>Hình 7.10: Kết quả chuyển xâu thành in hoa</em></p><p>Để nắm được kỹ thuật này, chúng ta xét ví dụ sau: Viết chương trình RMI có cấu trúc sau:</p><ul><li>Phía client cho phép tạo đối tượng BOX có các tham số w, h, d tương ứng là chiều rộng, chiều cao và chiều sâu của hình hộp chữ nhật. Sau đó gọi phương thức từ xa và truyền đối tượng BOX cho phương thức theo kiểu tham trị, nhận kết quả trả về và hiển thị.</li><li>Phía server có đối tượng có phương thức cho phép gọi từ xa với tham số truyền là đối tượng BOX, thực hiện thay đổi w, h, d của đối tượng và trả đối tượng về cho client.</li></ul><p>Quá trình xây dựng chương trình thực hiện các bước sau:</p><p class="align-center"><em>Hình 7.11: Kết quả đếm số từ của xâu</em></p><p> </p><p> </p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/123VuPhuc/myblog.git/authors/vu-tran-hoang-phuc/" rel="author">Vũ Trần Hoàng Phúc</a></h3></div></div></div></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/123VuPhuc/myblog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/123VuPhuc/myblog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>