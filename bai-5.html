<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 5:LẬP TRÌNH VỚI GIAO THỨC TCP - Blog của tôi</title><meta name="description" content="5.1/Khái niệm chung Thuật ngữ lập trình mạng với Java đề cập đến việc viết các chương trình thực hiện trên nhiều thiết bị máy tính, trong đó các thiết bị được kết nối với nhau. Gói java.net của Java chứa một tập hợp các&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://123vuphuc.github.io/myblog/bai-5.html"><link rel="alternate" type="application/atom+xml" href="https://123vuphuc.github.io/myblog/feed.xml"><link rel="alternate" type="application/json" href="https://123vuphuc.github.io/myblog/feed.json"><meta property="og:title" content="Bài 5:LẬP TRÌNH VỚI GIAO THỨC TCP"><meta property="og:image" content="https://123vuphuc.github.io/myblog/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:site_name" content="Blog của tôi"><meta property="og:description" content="5.1/Khái niệm chung Thuật ngữ lập trình mạng với Java đề cập đến việc viết các chương trình thực hiện trên nhiều thiết bị máy tính, trong đó các thiết bị được kết nối với nhau. Gói java.net của Java chứa một tập hợp các&hellip;"><meta property="og:url" content="https://123vuphuc.github.io/myblog/bai-5.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://123vuphuc.github.io/myblog/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://123vuphuc.github.io/myblog/bai-5.html"},"headline":"Bài 5:LẬP TRÌNH VỚI GIAO THỨC TCP","datePublished":"2024-12-29T11:11+07:00","dateModified":"2024-12-29T20:50+07:00","image":{"@type":"ImageObject","url":"https://123vuphuc.github.io/myblog/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920},"description":"5.1/Khái niệm chung Thuật ngữ lập trình mạng với Java đề cập đến việc viết các chương trình thực hiện trên nhiều thiết bị máy tính, trong đó các thiết bị được kết nối với nhau. Gói java.net của Java chứa một tập hợp các&hellip;","author":{"@type":"Person","name":"Vũ Trần Hoàng Phúc","url":"https://123vuphuc.github.io/myblog/authors/vu-tran-hoang-phuc/"},"publisher":{"@type":"Organization","name":"Vũ Trần Hoàng Phúc","logo":{"@type":"ImageObject","url":"https://123vuphuc.github.io/myblog/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="page-template"><a href="/about-me"><label style="color: #007BFF; cursor: pointer;">Click here to read my About Me page</label></a><header class="top js-header"><a class="logo" href="https://123vuphuc.github.io/myblog/"><img src="https://123vuphuc.github.io/myblog/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg" alt="Blog của tôi" width="1920" height="1080"></a></header><main class="page"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 5:LẬP TRÌNH VỚI GIAO THỨC TCP</h1></div></header></div><div class="entry-wrapper content__entry"><p>5.1/Khái niệm chung</p><p>               Thuật ngữ lập trình mạng với Java đề cập đến việc viết các chương trình thực hiện trên nhiều thiết bị máy tính, trong đó các thiết bị được kết nối với nhau.</p><p>          Gói <em>java.net </em>của Java chứa một tập hợp các lớp và giao tiếp cung cấp giao thức truyền thông ở mức độ thấp.</p><p>         Gói <em>java.net </em>được cung cấp hỗ trợ cho hai giao thức mạng phổ biến sau:</p><ul><li><strong>TCP </strong>- Transmission Control Protocol: TCP thường được sử dụng qua giao thức Internet (Internet Protocol), được gọi là TCP/IP. Giao thức này cho phép giao tiếp tin cậy giữa hai ứng dụng.</li><li><strong>UDP </strong>- User Datagram Protocol: một giao thức khác cho phép truyền dữ liệu giữa các ứng dụng. Giao thức này không kiểm tra đến việc gói tin đã được gửi hay chưa nên đây là giao tiếp không tin cậy giữa hai hoặc nhiều ứng dụng. Chúng ta  sẽ tìm hiểu về lập trình với giao thức UDP ở chương</li></ul><p>         TCP và UDP là các giao thức cốt lõi của việc kết nối các thiết bị công nghệ với nhau. Các ứng dụng có thể dùng một trong hai hoặc cả hai giao thức này để trao đổi với các ứng dụng trên máy tính khác thông qua mạng máy tính.</p><p>        5.2/Khái niệm rỗng (port number)</p><p>         Để có thể thực hiện các cuộc giao tiếp, một trong hai quá trình phải công bố số hiệu cổng của socket mà mình sử dụng. Mỗi cổng giao tiếp thể hiện một địa chỉ xác định trong hệ thống. Khi quá trình được gán một số hiệu cổng, nó có thể nhận dữ liệu gửi đến cổng này từ các quá trình khác. Quá trình còn lại cũng được yêu cầu tạo ra một socket.</p><p>         Số hiệu cổng (port number) được sử dụng để xác định tính duy nhất của các ứng dụng khác nhau. Nó hoạt động như một điểm kết nối cuối trong giao tiếp giữa các ứng dụng.</p><p>         Số hiệu cổng gán cho Socket phải duy nhất trên phạm vi máy tính đó, có giá trị trong khoảng từ 0 đến 65535 (16 bit). Trong đó, giá trị cổng:</p><ul><li>Từ 0-1023: là cổng hệ thống (common hay well-known port), được dành riêng cho các quá trình của hệ thống.</li><li>Từ 1024-49151: là cổng phải đăng ký (registered port). Các ứng dụng muốn sử dụng cổng này phải đăng ký với IANA (Internet Assigned Numbers Authority).</li><li>Từ 49152-65535: là cổng dùng riêng hay cổng động (dynamic hay private port). Người sử dụng có thể dùng cho các ứng dụng của mình, không cần phải đăng ký.</li></ul><p>Một số cổng thường được sử dụng:</p><ul><li>21: dịch vụ FTP</li><li>23: dịch vụ Telnet</li><li>25: dịch vụ Email (SMTP)</li><li>80: dịch vụ Web (HTTP)</li><li>110: dịch vụ Email (POP)</li><li>143: dịch vụ Email (IMAP)</li><li>443: dịch vụ SSL (HTTPS)</li><li>1433/1434: cơ sở dữ liệu SQL Server</li><li>3306: cơ sở dữ liệu MySQL</li></ul><p>   5.3/ Lớp Socket</p><p>       Đơn vị truyền và nhận tin bằng phương thức TCP được gọi là Socket.</p><p>      Socket cho phép dữ liệu được trao đổi giữa các thiết bị trong môi trường mạng máy tính.</p><p>      Lớp <em>java.net.Socket </em>trong Java giúp quản lý quá trình truyền và nhận giữa các máy tính trong mạng máy tính bằng giao thức TCP.</p><p>       Một Socket đóng vai trò một đầu-cuối của một kết nối thực. Một Socket vừa có thể của Client để gửi yêu cầu kết nối tới Server vừa có thể được tạo bởi Server để xử lý yêu cầu trao đổi tin từ Client.</p><p>       Chúng ta cùng tìm hiểu các phương thức của lớp <em>Socket</em>.</p><figure class="post__image"><img loading="lazy" src="https://123vuphuc.github.io/myblog/media/posts/10/Picture1.png" alt="" width="321" height="124" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture1-xs.png 640w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture1-sm.png 768w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture1-md.png 1024w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture1-lg.png 1366w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture1-xl.png 1600w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture1-2xl.png 1920w"></figure><p>     5.3.1/ Các phương thức tạo</p><p><em>public <strong>Socket</strong>(String host, int port) throws IOException, UnknownHostException</em></p><p>      Constructor này cố gắng để kết nối với máy chủ được chỉ định tại cổng được chỉ định. Nếu constructor này không ném một ngoại lệ, kết nối thành công và máy khách được kết nối với máy chủ.</p><p><em>public <strong>Socket</strong>(InetAddress host, int port)throws IOException, UnknownHostException</em></p><p>        Constructor này giống hệt với hàm tạo trước đó, ngoại trừ việc máy chủ được chỉ định bởi một đối tượng <em>InetAddress</em>.</p><p><em>public <strong>Socket</strong>(String host, int port, InetAddress localAddress, int localPort)throws IOException</em></p><p>        Kết nối đến máy chủ và cổng được chỉ định, tạo một socket trên máy chủ cục bộ tại địa chỉ và cổng được chỉ định.</p><p><em>public <strong>Socket</strong>(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException</em></p><p>Constructor này giống hệt với constructor trước đó, ngoại trừ máy chủ được chỉ định bởi một đối tượng <em>InetAddress </em>thay vì một <em>String</em>.</p><p><em>public <strong>Socket</strong>()</em></p><p>       Tạo một socket không chỉ định trước kết nối. Sau này chúng ta sử dụng phương thức <em>connect() </em>để kết nối socket này với máy chủ.</p><p>        5.3.2/ Các phương thức kiểm soát vào - ra</p><p><em>public InputStream <strong>getInputStream</strong>() throws IOException</em></p><p>      Trả về dòng đầu vào của socket. Input stream được kết nối với output stream của socket remote.</p><p><em>public OutputStream <strong>getOutputStream</strong>() throws IOException</em></p><p>       Trả về dòng đầu ra của socket. Output stream được kết nối với input stream của socket remote.</p><p>        5.3.3/ Một số phương thức khác</p><p><em>        public void <strong>connect</strong>(SocketAddress host, int timeout) throws IOException</em></p><p>       Phương thức này kết nối socket với máy chủ được chỉ định. Phương thức này là cần thiết chỉ khi chúng ta khởi tạo Socket bằng cách sử dụng constructor không có đối số.</p><p><em>public InetAddress <strong>getInetAddress</strong>()</em></p><p>        Phương thức này trả về địa chỉ mạng của máy chủ mà socket này được kết nối.</p><p><em>public int <strong>getPort</strong>()</em></p><p>        Trả về cổng mà socket bị ràng buộc trên máy remote.</p><p><em>public int <strong>getLocalPort</strong>()</em></p><p>       Trả về cổng mà socket bị ràng buộc trên máy local.</p><p><em>public SocketAddress <strong>getRemoteSocketAddress</strong>()</em></p><p>      Trả về địa chỉ của socket từ xa.</p><p><em>public synchronized void <strong>setSoTimeout</strong>(int timeout) throws SocketException</em></p><p>       Thiết lập thời gian tồn tại của socket. Nếu <em>timeout</em><em> </em>khác <em>0</em>, đây chính là khoảng thời gian (được tính bằng mili giây) mà socket còn hoạt động. Hết thời gian này chương trình socket sẽ tự hủy.</p><p><em>public void <strong>close</strong>() throws IOException</em></p><p>        Đóng socket, làm cho đối tượng <em>Socket </em>này không còn có khả năng kết nối với bất kỳ máy chủ nào.</p><p>      5.4/ Lớp SeverSocket</p><p>        Lớp <em>java.net.ServerSocket </em>được sử dụng bởi các ứng dụng máy chủ để tạo ra một một ứng dụng tại một cổng và lắng nghe các yêu cầu của máy khách.</p><p>        Một đối tượng của lớp <em>ServerSocket </em>được tạo trên phía máy chủ và lắng nghe kết nối từ các máy khách. Đối tượng này luôn tồn tại trong một chương trình ứng dụng mạng đang chạy bằng giao thức TCP phía máy chủ.</p><p>      5.4.1/ Các phương thức tạo</p><p><em>public <strong>ServerSocket</strong>(int port) throws IOException</em></p><p>       Cố gắng tạo một <em>ServerSocket </em>bị ràng buộc vào port được chỉ định. Một ngoại lệ xảy ra nếu <em>port </em>đã bị ràng buộc bởi một ứng dụng khác.</p><p><em>public <strong>ServerSocket</strong>(int port, int backlog) throws IOException</em></p><p>        Tương tự như hàm tạo trước đó, tham số <em>backlog </em>xác định có bao nhiêu máy khách đến để lưu trữ trong một hàng đợi.</p><p><em>public <strong>ServerSocket</strong>(int port, int backlog, InetAddress address) throws IOException</em></p><p>        Tương tự như constructor trước đó, tham số <em>InetAddress </em>chỉ định địa chỉ IP cục bộ để ràng buộc. <em>InetAddress </em>được sử dụng cho các máy chủ có thể có nhiều địa chỉ IP, cho phép máy chủ xác định địa chỉ IP nào để chấp nhận yêu cầu của máy khách.</p><p><em>public <strong>ServerSocket</strong>() throws IOException</em></p><p>          Tạo ra một <em>ServerSocket</em><em> </em>không kết nối. Khi sử dụng constructor này, sử dụng phương thức <em>bind() </em>khi chúng ta muốn ràng buộc socket tới máy chủ.</p><p>      5.4.2/ Các phương thức khác</p><p><em>public Socket <strong>accept</strong>() throws IOException</em></p><p>        Chờ cho một máy khách kết nối đến. Phương thức này ngăn chặn cho đến khi một máy trạm kết nối đến máy chủ trên cổng được chỉ định hoặc socket hết hạn, giả sử rằng giá trị thời gian đã được thiết lập bằng phương thức <em>setSoTimeout()</em>. Nếu không, phương thức này sẽ khóa lại vô thời hạn.</p><p><em>public int <strong>getLocalPort</strong>()</em></p><p>         Trả về cổng mà socket của máy chủ lắng nghe. Phương thức này rất hữu ích nếu chúng ta truyền <em>0 </em>như là số cổng trong một constructor và để cho máy chủ tìm thấy một cổng cho chúng ta.</p><p><em>public void <strong>setSoTimeout</strong>(int timeout)</em></p><p>          Thiết lập giá trị thời gian chờ cho bao lâu socket của máy chủ chờ khách hàng trong suốt quá trình chấp nhận.</p><p><em>public void <strong>bind</strong>(SocketAddress host, int backlog)</em></p><p>          Liên kết socket tới máy chủ và cổng được chỉ định trong đối tượng <em>SocketAddress</em>. Sử dụng phương thức này nếu chúng ta đã tạo ra các <em>ServerSocket </em>bằng cách sử dụng constructor không có đối số.</p><p><em>public void <strong>close</strong>()</em></p><p>           Đóng <em>ServerSocket</em>, ngừng phục vụ. Chúng ta ít khi sử dụng phương thức này vì <em>ServerSocket </em>thường luôn phục vụ phía máy chủ.</p><p>            Khi <em>ServerSocket </em>gọi <em>accept()</em>, phương thức này sẽ không return cho đến khi một máy khách kết nối đến. Sau khi máy khách kết nối, <em>ServerSocket </em>tạo một <em>Socket </em>mới trên một cổng không xác định và trả về một tham chiếu đến <em>Socket </em>mới này và thực hiện kết nối TCP giữa máy khách và máy chủ để có thể truyền tin.</p><p>     5.5/ Lập trình TCP bằng mô hình Cilent/Server</p><p>          Trong mô hình lập trình TCP Client/Server với Java chúng ta sử dụng hai lớp <em>ServerSocket </em>và <em>Socket</em>. Lớp <em>ServerSocket </em>chỉ sử dụng ở phía Server trong khi lớp <em>Socket </em>sử dụng đồng thời ở phía Client và Server để trao đổi dữ liệu.</p><figure class="post__image"><img loading="lazy" src="https://123vuphuc.github.io/myblog/media/posts/10/Picture7.png" alt="" width="186" height="124" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture7-xs.png 640w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture7-sm.png 768w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture7-md.png 1024w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture7-lg.png 1366w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture7-xl.png 1600w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture7-2xl.png 1920w"></figure><p class="align-center"><em>Hình 5.1: Mô hình Client/Server theo kỹ thuật lập trình với giao thức TCP</em></p><p>          Quan sát hình trên chúng ta thấy rằng để tạo một ứng dụng mạng chạy bằng giao thức TCP chúng ta cần thiết lập hai ứng dụng riêng biệt: một ứng dụng Server và một ứng dụng cho Client.</p><p>       Theo trình tự thời gian, ứng dụng phía máy chủ sẽ chạy trước và tạo ra một</p><p><em>ServerSocket </em>trên cổng <em>x </em>để lắng nghe các kết nối từ phía máy khách.</p><p>        Máy khách sẽ tạo ra một <em>Socket </em>để kết nối tới máy chủ <em>hostid </em>qua cổng <em>x</em>.</p><p>        Khi có yêu cầu kết nối, máy chủ sẽ chấp nhận kết nối bằng cách tạo ra một Socket qua phương thức <em>accept()</em>. Sau khi thiết lập kết nối máy chủ và máy khách có thể trao đổi dữ liệu thông qua các phương thức kiểm soát vào-ra của lớp <em>Socket</em>. Kết nối này sẽ tồn tại đến khi nào một trong hai bên hủy bỏ kết nối bằng cách đóng kết nối qua phương thức <em>close() </em>hoặc có sự cố về mạng.</p><p>       5.6/ Xử lý ngoại lệ trong lập trình mạng</p><p>         Trong lập trình mạng nói chung, chúng ta thường xuyên gặp phải một số lỗi nhất định khi chạy chương trình. Có thể kể ra như lỗi xung đột cổng giữa các ứng dụng trên máy chủ, lỗi không kết nối được giữa các máy tính, lỗi không gửi/nhận dữ liệu được qua mạng…</p><p>Java định nghĩa một số ngoại lệ (Exception) để xử lý các sự cố này như:</p><p><em>IOException</em>, <em>UnknownHostException</em>…</p><p>         Để xử lý các ngoại lệ này chúng ta có hai cách:</p><ul><li>Sử dụng cú pháp <em>try-catch</em>: chúng ta nên dùng cách này để chủ động trong việc xử lý lỗi. Khi có lỗi xảy ra, chúng ta có thể có biện pháp khắc phục hợp lý hoặc thông báo lỗi cho người dùng biết.</li><li>Sử dụng cú pháp <em>throws </em>cho các phương thức: sử dụng cách này là chúng ta giao cho các lớp xử lý ngoại lệ của Java xử lý giúp. Cách này chỉ nên dùng với những lỗi đơn giản hoặc ít gặp phải.</li></ul><p>    5.7/ Một số ví dụ</p><p><strong><em>Ví dụ 5-1. </em></strong><em>Viết chương trình kiểm tra một cổng trên máy chủ có đang hoạt động hay không.</em></p><p>     Cổng đang hoạt động được hiểu là cổng đang có một ứng dụng chạy trên đó.</p><p>     Có nghĩa là nó đang đóng vai trò là máy phục vụ trên cổng đó.</p><p>      Việc thiết kế giao diện người dùng trong ví dụ này và các ví dụ sau được thực hiện trong phần mềm NetBeans. Chúng ta có thể sử dụng các công cụ khác để thiết kế hoặc tự sinh các đối tượng đồ họa bằng thư viện Swing và AWT.</p><p>      Dùng Swing hoặc AWT thiết kế giao diện như sau, tên biến của các đối tượng đồ họa được chú thích ở cuối mũi tên.</p><p><em>//AllAddr.java</em><em> </em><em>import java.net.*; public class AllAddr{</em></p><p><em>public static void main (String[] args) { try {</em></p><p><em>InetAddress[] addresses = InetAddress.getAllByName("</em><a href="http://www.microsoft.com/"><em>www.microsoft.com</em></a><em>");</em></p><p><em>for (int i = 0; i &lt; addresses.length; i++) { System.out.println(addresses[i]);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.microsoft.com/"><em>www.microsoft.com")</em></a><em>;</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p class="align-center"><em>Hình 5.2: Thiết kế giao diện kiểm tra cổng mạng</em></p><p>     Xử lý sự kiện khi người dùng bấm nút <em>Kiểm tra </em>như sau:</p><figure class="post__image"><img loading="lazy" src="https://123vuphuc.github.io/myblog/media/posts/10/Anh-chup-man-hinh-2024-12-29-204259.png" alt="" width="1026" height="1107" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204259-xs.png 640w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204259-sm.png 768w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204259-md.png 1024w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204259-lg.png 1366w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204259-xl.png 1600w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204259-2xl.png 1920w"></figure><figure class="post__image"><img loading="lazy" src="https://123vuphuc.github.io/myblog/media/posts/10/Anh-chup-man-hinh-2024-12-29-204341.png" alt="" width="1023" height="930" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204341-xs.png 640w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204341-sm.png 768w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204341-md.png 1024w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204341-lg.png 1366w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204341-xl.png 1600w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Anh-chup-man-hinh-2024-12-29-204341-2xl.png 1920w"></figure><p>Kết quả chúng ta nhận được như sau:</p><figure class="post__image"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture4.jpg" alt="" width="395" height="210" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-xs.jpg 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-sm.jpg 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-md.jpg 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-lg.jpg 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-xl.jpg 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-2xl.jpg 1920w"></figure><p><strong><em>Ví dụ 5-2. </em></strong><em>Viết chương trình quét cổng trên máy chủ.</em></p><p>Chương trình sẽ quét trong một phạm vi cổng nhất định trên máy chủ xem cổng nào đang hoạt động, cổng nào không hoạt động.</p><p>Thiết kế giao diện như hình dưới:</p><p><em>try {</em></p><p><em>Socket toYahoo = new Socket("</em><a href="http://www.yahoo.com/"><em>www.yahoo.com</em></a><em>", 80);</em></p><p><em>// Hoạt động gửi /nhận dữ liệu</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>catch (IOException ex) {</em></p><p><em> </em></p><p><em>System.err.println(ex);</em></p><p><em>}</em></p><p class="align-center"><em>Hình 5.4: Thiết kế giao diện quét cổng mạng</em></p><p>Xử lý sự kiện khi người dùng bấm vào nút <em>btScan </em>như sau:</p><p><em>ServerSocket ss = new ServerSocket( );</em></p><p><em>// set socket options...</em></p><p><em>SocketAddress http = new InetSocketAddress(80); ss.bind(http);</em></p><p>       Trong đoạn mã trên, phương thức <em>isActive(host, port, timeout) </em>dùng để kiểm tra xem cổng <em>port </em>trên máy chủ <em>host </em>có đang hoạt động hay không. Phương thức này sẽ trả về giá trị <em>true </em>nếu chương trình kết nối được với <em>host </em>qua cổng <em>port </em>trong thời gian chờ <em>timeout</em>, ngược lại nó sẽ trả về giá trị <em>false</em>.</p><p class="align-center"> </p><p><strong><em>Ví dụ 5-3</em></strong><em>. Viết chương trình theo mô hình Client/Server. Client gửi một xâu lên Server. Server chuyển xâu thành chữ in hoa rồi gửi trả lại cho Client.</em></p><p><em>Bước 1</em>: Lập trình phía Server.</p><p>- Tạo một project đặt tên là <em>TCP_Server</em>.</p><ul><li>Trong project này tạo một class và đặt tên là <em>Server</em>.</li><li>Viết mã lệnh cho <em>Server </em>như sau:</li></ul><figure class="post__image"><img loading="lazy" src="https://123vuphuc.github.io/myblog/media/posts/10/Picture10.png" alt="" width="564" height="268" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-xs.png 640w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-sm.png 768w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-md.png 1024w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-lg.png 1366w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-xl.png 1600w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-2xl.png 1920w"></figure><p><em>Bước 2</em>: Lập trình phía Client</p><ul><li>Tạo một project khác đặt tên là <em>TCP_Client</em>.</li><li>Trong project này tạo một JFrame Form đặt tên là <em>Client</em>.</li><li>Thiết kế giao diện như hình dưới:</li></ul><p>import java.io.*;</p><p><em>import java.net.*;</em></p><p><em> </em></p><p><em>public class EchoClient {</em></p><p><em>public static void main(String[] args) throws IOException {</em></p><p><em> </em></p><p><em>Socket echoSocket = null; PrintWriter out = null; BufferedReader in = null;</em></p><p><em> </em></p><p><em>try {</em></p><p><em>echoSocket = new Socket("taranis", 7);</em></p><p><em>out = new PrintWriter(echoSocket.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(</em></p><p><em>echoSocket.getInputStream()));</em></p><p><em>} catch (UnknownHostException e) { System.err.println("Don't know about host: taranis."); System.exit(1);</em></p><p><em>} catch (IOException e) { System.err.println("Couldn't get I/O for "</em></p><p><em>+ "the connection to: taranis.");</em></p><p><em>System.exit(1);</em></p><p><em>}</em></p><p><em> </em></p><p><em>BufferedReader stdIn = new BufferedReader(</em></p><p><em>new InputStreamReader(System.in));</em></p><p><em>String userInput;</em></p><p><em> </em></p><p><em>while ((userInput = stdIn.readLine()) != null) { out.println(userInput); System.out.println("echo: " + in.readLine());</em></p><p><em>}</em></p><p><em> </em></p><p><em>out.close();</em></p><p><em>in.close(); stdIn.close(); echoSocket.close();</em></p><p><em>}}</em></p><p class="align-center"><em>Hình 5.6: Thiết kế giao diện Client xử lý xâu</em></p><ul><li>Xử lý sự kiện khi người dùng nhấn vào nút <em>Gửi</em>:</li></ul><p>Giả sử đối tượng Socket được tạo ra với biến tham chiếu là cl.</p><p>- Với luồng nhập:</p><p>+ Tạo luồng nhập cho socket:</p><p><em>InputStream inp=cl.getInputStream();</em></p><p>+ Đọc dữ liệu: Có ba cách</p><p>-/ Đọc mỗi lần một byte: <em>inp.read()</em></p><p>-/Đọc một khối dữ liệu và cất vào mảng b:</p><p><em>byte b=new  byte[1024];</em></p><p><em>inp.read(b) hoặc inp.read(b,offset, len)</em></p><p>- Với luồng xuất:</p><p>+Tạo luồng xuất:</p><p><em>OutputStream outp=cl.getOutputStream();</em></p><p>+ Viết dữ liệu:</p><p>-/Viết mỗi lần một byte b: <em>outp.write(b);</em></p><p>-/ Viết cả khối dữ liệu chứa trong mảng b kiểu byte:</p><p>//byte[]    b;</p><p><em>outp.write(b) </em>hoặc <em>outp.write(b,offset,len);</em></p><p><em>Bước 3</em>: Chạy chương trình</p><ul><li>Chạy Server trước.</li><li>Chạy Client sau, nhập dữ liệu và nhấn nút “Gửi”.</li><li>Kết quả như hình dưới.</li></ul><p>Với luồng nhập:</p><p>+Tạo luồng nhập:</p><p><em>BufferedReader</em><em> </em><em>inp=new</em><em> </em><em>BuferedReader(</em></p><p><em>new</em><em> InputStreamReader(cl.getInputStream()));</em></p><p>+ Đọc dữ liệu:</p><p>-/Đọc từng ký tự:  <em>int  ch=inp.read()</em></p><p>-/ Đọc chuỗi<em>:</em><em>     String  s=inp.readLine();</em></p><p>- Với luồng xuất:</p><p>+ Tạo luồng xuất:</p><p><em>PrintWriter outp=new PrintWriter(cl.getOutputStream(),true);</em></p><p>+ Viết dữ liệu:</p><p class="align-center"> </p><p><em>outp.println(&lt;data&gt;);</em></p><p class="align-center"><em>Hình 5.7: Kết quả xử lý xâu bằng máy chủ TCP</em></p><p>         Trên đây là một ví dụ đơn giản về kỹ thuật lập trình với giao thức TCP để xử lý xâu. Chúng ta thấy rằng việc xử lý xâu hoàn toàn ở phía Server, còn Client chỉ có nhiệm vụ gửi xâu và đợi kết quả. Việc xử lý xâu như thế nào là hoàn toàn do Server quyết định và một Server có thể xử lý yêu cầu của nhiều Client khác nhau.</p><p>          Trong chương trình phía Server chúng ta thấy có vòng lặp <em>while(true)</em>, vòng lặp này không bao giờ dừng trừ khi chúng ta tự tắt chương trình. Việc có vòng lặp này đảm bảo rằng phía Server luôn chạy, nếu không có <em>while(true)</em>chương trình sẽ chỉ phục vụ một lần. Server có thể xử lý yêu cầu từ nhiều Client cùng một lúc.</p><p>          Tuy đơn giản, nhưng ví dụ trên đã minh họa đầy đủ các bước thực hiện một giao tiếp mạng bằng giao thức TCP. Chúng ta có thể xử lý các yêu cầu phức tạp hơn ở phía Server hay gửi nhiều yêu cầu hơn ở phía Client. Đó là những kiến thức thuộc kỹ thuật lập trình, hoàn toàn có thể thực hiện được. Và để gửi nhiều dữ liệu hơn ở phía Client, chúng ta cùng xem xét ví dụ phía dưới.</p><p><strong><em>          Ví dụ 5-4</em></strong><em>. Viết chương trình theo mô hình Client/Server. Client gửi lên Server hai số thực và một trong bốn phép toán: cộng, trừ, nhân, chia. Server xử lý tính toán theo yêu cầu và gửi trả kết quả.</em></p><p><em>    Bước 1</em>: Lập trình phía Client</p><ul><li>Tạo project đặt tên là <em>TCP_Calculator_Client</em>.</li><li>Trong project này tạo một JFrame Form đặt tên là <em>Client</em>.</li><li>Thiết kế giao diện cho <em>Client </em>như sau:</li></ul><figure class="post__image"><img loading="lazy" src="https://123vuphuc.github.io/myblog/media/posts/10/Picture10-2.png" alt="" width="564" height="268" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-2-xs.png 640w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-2-sm.png 768w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-2-md.png 1024w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-2-lg.png 1366w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-2-xl.png 1600w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture10-2-2xl.png 1920w"></figure><p class="align-center"><em>Hình 5.8: Thiết kế giao diện Client xử lý số</em></p><ul style="list-style-type: square;"><li>Xử lý sự kiện người dùng bấm vào nút <em>Tính toán </em>như sau:</li></ul><figure class="post__image"><img loading="lazy" src="https://123vuphuc.github.io/myblog/media/posts/10/Picture12.jpg" alt="" width="596" height="353" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture12-xs.jpg 640w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture12-sm.jpg 768w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture12-md.jpg 1024w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture12-lg.jpg 1366w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture12-xl.jpg 1600w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture12-2xl.jpg 1920w"></figure><p> </p><p><em>    Bước 2</em>: Lập trình phía Server</p><ul><li>Tạo một project đặt tên là <em>TCP_Calculator_Server</em>.</li><li>Trong project này tạo một class và đặt tên là <em>Server</em>.</li><li>Viết mã lệnh cho <em>Server </em>như sau:</li></ul><p><strong>package</strong><strong> </strong>tcp.client;</p><p><strong>import</strong><strong> </strong>java.io.Serializable;</p><p> </p><p><strong>public</strong><strong> </strong><strong>class</strong><strong> </strong>User <strong>implements</strong><strong> </strong>Serializable{</p><p><strong>private</strong><strong> </strong>String userName;</p><p><strong>private</strong><strong> </strong>String password;</p><p> </p><p><strong>public</strong><strong> </strong>User(){</p><p>}</p><p class="align-center"> </p><p><strong>public</strong><strong> </strong>User(String username, String password){</p><p><strong>this</strong>.userName = username;</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getPassword() {</p><p><strong>return</strong><strong> </strong>password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setPassword(String password) {</p><p><strong>this</strong>.password = password;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong>String getUserName() {</p><p><strong>return</strong><strong> </strong>userName;</p><p>}</p><p> </p><p><strong>public</strong><strong> </strong><strong>void</strong><strong> </strong>setUserName(String userName) {</p><p><strong>this</strong>.userName = userName;</p><p>}</p><p>}</p><p> </p><p><em>     Bước 3</em>: Chạy chương trình</p><ul><li>Chạy <em>Server </em>trước.</li><li>Chạy <em>Client </em>sau, nhập dữ liệu và nhấn nút <em>Tính toán</em>.</li><li>Kết quả như hình dưới.</li></ul><figure class="post__image"><img loading="lazy" src="https://123vuphuc.github.io/myblog/media/posts/10/Picture13.jpg" alt="" width="455" height="303" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture13-xs.jpg 640w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture13-sm.jpg 768w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture13-md.jpg 1024w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture13-lg.jpg 1366w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture13-xl.jpg 1600w, https://123vuphuc.github.io/myblog/media/posts/10/responsive/Picture13-2xl.jpg 1920w"></figure><p class="align-center"><em>Hình 5.9: Kết quả xử lý số bằng máy chủ TCP</em></p><p>          Trong đoạn mã phía Client, chúng ta thấy việc gửi dữ liệu (<em>n1</em>, <em>n2</em>, <em>operator</em>) lên Server được thực hiện nối tiếp nhau bằng ba câu lệnh <em>println()</em>. Như là một giao ước, phía bên Server cũng sẽ phải nhận liên tiếp ba giá trị này.</p><p>          Trong kỹ thuật lập trình mạng, sau khi thiết lập kết nối TCP các máy tính có thể thực hiện nhiều lần việc gửi và nhận dữ liệu. Tuy nhiên, chúng ta cần thiết lập quy tắc trao đổi dữ liệu để sao cho một bên gửi thì bên kia nhận dữ liệu. Việc gửi- nhận này cần phải nhịp nhàng, chính xác.</p><p>          Thêm vào đó, thay vì phải gửi liên tiếp ba lần cho ba dữ liệu, chúng ta có thể nối 3 dữ liệu này thành một xâu duy nhất và gửi đi một lần. Phía Server chia tách xâu và xác định lại các dữ liệu cần thiết. Cấu trúc của xâu ghép phải được Client và Server thống nhất với nhau. Giả sử, ở ví dụ trên thay vì thực hiện ghi ba lần liên tiếp lên dòng ra các dữ liệu <em>n1</em>, <em>n2</em>, <em>operator </em>ta chỉ cần nối chúng thành một xâu ngăn cách bởi kí tự đặc biệt và gửi tới máy chủ xâu đó: “<em>n1</em>@<em>n2</em>@<em>operator</em>”.</p><p> </p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://123vuphuc.github.io/myblog/authors/vu-tran-hoang-phuc/" rel="author">Vũ Trần Hoàng Phúc</a></h3></div></div></div></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://123vuphuc.github.io/myblog/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://123vuphuc.github.io/myblog/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>