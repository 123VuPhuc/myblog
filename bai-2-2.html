<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 2:CÁC DÒNG VÀO-RA (STREAM) - Blog của tôi</title><meta name="description" content="2.1/Các dòng ra (output stream) Lớp output cơ bản của Java là java.io.OutputStream, với khai báo như sau: public abstract class OutputStream{ } Lớp này cung cấp các phương thức cơ bản để ghi dữ liệu, đó là: Các lớp con của OutputStream sử dụng&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/123VuPhuc/myblog.git/bai-2-2.html"><link rel="alternate" type="application/atom+xml" href="https://github.com/123VuPhuc/myblog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/123VuPhuc/myblog.git/feed.json"><meta property="og:title" content="Bài 2:CÁC DÒNG VÀO-RA (STREAM)"><meta property="og:image" content="https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:site_name" content="Blog của tôi"><meta property="og:description" content="2.1/Các dòng ra (output stream) Lớp output cơ bản của Java là java.io.OutputStream, với khai báo như sau: public abstract class OutputStream{ } Lớp này cung cấp các phương thức cơ bản để ghi dữ liệu, đó là: Các lớp con của OutputStream sử dụng&hellip;"><meta property="og:url" content="https://github.com/123VuPhuc/myblog.git/bai-2-2.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/123VuPhuc/myblog.git/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/123VuPhuc/myblog.git/bai-2-2.html"},"headline":"Bài 2:CÁC DÒNG VÀO-RA (STREAM)","datePublished":"2024-12-29T11:02+07:00","dateModified":"2024-12-29T12:19+07:00","image":{"@type":"ImageObject","url":"https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920},"description":"2.1/Các dòng ra (output stream) Lớp output cơ bản của Java là java.io.OutputStream, với khai báo như sau: public abstract class OutputStream{ } Lớp này cung cấp các phương thức cơ bản để ghi dữ liệu, đó là: Các lớp con của OutputStream sử dụng&hellip;","author":{"@type":"Person","name":"Vũ Trần Hoàng Phúc","url":"https://github.com/123VuPhuc/myblog.git/authors/vu-tran-hoang-phuc/"},"publisher":{"@type":"Organization","name":"Vũ Trần Hoàng Phúc","logo":{"@type":"ImageObject","url":"https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><a href="/about-me"><label style="color: #007BFF; cursor: pointer;">Click here to read my About Me page</label></a><header class="top js-header"><a class="logo" href="https://github.com/123VuPhuc/myblog.git/"><img src="https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg" alt="Blog của tôi" width="1920" height="1080"></a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 2:CÁC DÒNG VÀO-RA (STREAM)</h1><div class="feed__meta content__meta"><a href="https://github.com/123VuPhuc/myblog.git/authors/vu-tran-hoang-phuc/" class="feed__author">Vũ Trần Hoàng Phúc</a> <time datetime="2024-12-29T11:02" class="feed__date">December 29, 2024</time></div></div></header></div><div class="entry-wrapper content__entry"><p>2.1/Các dòng ra (output stream)</p><p>Lớp output cơ bản của Java là <em>java.io.OutputStream</em>, với khai báo như sau:</p><p>public abstract class OutputStream{</p><p>}</p><p>Lớp này cung cấp các phương thức cơ bản để ghi dữ liệu, đó là:</p><ul><li><em>public abstract void <strong>write</strong>(int b) throws IOException</em></li><li><em>public void <strong>write</strong>(byte[] data) throws IOException</em></li><li><em>public void <strong>write</strong>(byte[] data, int offset, int length) throws IOException</em></li><li><em>public void <strong>flush</strong>() throws IOException</em></li><li><em>public void <strong>close</strong>() throws IOException</em></li></ul><p>Các lớp con của <em>OutputStream </em>sử dụng các phương thức này để ghi dữ liệu lên một</p><p>phương tiện cụ thể. Ví dụ, một <em>FileOutputStream </em>sử dụng các phương thức này để ghi dữ liệu vào một file. Một <em>TelnetOutputStream </em>sử dụng các phương thức để ghi dữ liệu vào một kết nối mạng. Một <em>ByteArrayOutputStream </em>dùng các phương thức để ghi dữ liệu vào một mảng các byte có thể mở rộng được.</p><p>            Phương thức cơ bản của <em>OutputStream </em>là <em>write(int b)</em>. Phương thức này sử dụng một số nguyên có giá trị từ 0 đến 255 như là một đối số và ghi byte tương ứng vào output stream. Phương thức này được mô tả là trừu tượng (abstract) do các lớp con cần thay đổi phương thức này để kiểm soát phương tiện cụ thể. Một <em>ByteArrayOutputStream </em>có thể cài đặt phương thức với mã Java để sao chép byte vào mảng trong Java. Tuy nhiên, một <em>FileOutputStream </em>sẽ cần phải sử dụng mã riêng, mã này biết cách ghi dữ liệu trong các file trên nền của hệ điều hành.</p><p>           Mặc dù phương thức <em>write(int b) </em>sử dụng một số nguyên như là một đối số nhưng khi ghi sẽ ghi một byte không dấu (unsigned byte). Java không có kiểu dữ liệu byte không dấu nên phải sử dụng một số nguyên. Sự khác biệt giữa một byte không dấu và byte có dấu chính là cách diễn giải. </p><p>            Ví dụ: Giao thức bộ sinh ký tự (character-generator protocol) định nghĩa một Server gửi ra các văn bản mã hóa bằng mã ASCII. Một trong các biến thể của giao thức này sẽ gửi các dòng, mỗi dòng chứa 72 ký tự mã hóa bằng mã ASCII có thể in ra được. Các ký tự này có số thứ tự từ 33 đến 126 trong bảng mã ASCII ngoại trừ các ký tự trắng và các ký tự điều khiển.</p><ul><li>Dòng đầu chứa các ký tự từ 33 đến</li><li>Dòng thứ hai chứa các ký tự từ 34 đến</li><li>Dòng thứ ba chứa các ký tự từ 35 đến</li><li>Dòng thứ 29 chứa các ký tự từ 55 đến</li></ul><p>Đến đây, các ký tự được gói xoay vòng sao cho dòng 30 chứa các ký tự từ 56 đến 126 và sau đó lại là ký tự 33.</p><p>Các dòng được kết thúc bằng dấu Enter (ASCII 13) và một mã xuống dòng (ASCII 10).</p><p>Đoạn mã sau sẽ trình bày cách triển khai phương thức <em>write()</em>:</p><figure class="post__image"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-134011-2.png" alt="" width="1215" height="637" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-xs.png 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-sm.png 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-md.png 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-lg.png 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-xl.png 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-2xl.png 1920w"></figure><p>Kết quả của giao thức bộ sinh ký tự là:</p><p>!"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh "#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghi #$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghij</p><p>$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk</p><p>%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl &amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklm '()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn</p><p>         Trong ví dụ trên, một <em>OutputStream </em>được truyền đến phương thức <em>generateCharacters() </em>trong đối số <em>out</em>. Dữ liệu được viết lần lượt từng byte trên <em>out</em>. Các byte này được cho dưới dạng các số nguyên trong một chuỗi xoay vòng từ 33 đến 126. Sau mỗi một chuỗi 72 ký tự được viết dấu Enter (ASCII 13) và một mã xuống dòng (ASCII 10) được viết lên output stream. Ký tự kế tiếp được tính toán và vòng lặp sẽ được lặp lại. Phương thức out sử dụng throw <em>IOException</em>. Điều này rất quan trọng do Server bộ sinh ký tự sẽ chỉ kết thúc khi bên phía Client kết thúc kết nối và mã Java sẽ nhận biết việc kết thúc này như là một <em>IOException</em>.</p><p>         Việc ghi mỗi lần một byte thường không hiệu quả. Ví dụ, mỗi TCP segment chứa ít nhất 40 byte của phần overhead dùng cho việc định tuyến và sửa lỗi. Nếu mỗi lần chỉ gửi một byte ta có thể làm cho mạng phải tải tổng cộng 41 byte. Do đó, hầu hết các cài đặt TCP/IP sử dụng vùng đệm dữ liệu có một kích thước nào đó. Các cài đặt này sẽ tích lũy dữ liệu cần gửi trong vùng đệm (buffer) và chỉ gửi các dữ liệu này đi khi lượng dữ liệu được tích lũy hay thời gian tích lũy đã vượt một ngưỡng cho trước. Sử dụng <em>write(byte[] data) </em>hoặc <em>write(byte[] data, int offset, int length) </em>thường nhanh hơn việc ghi lần lượt từng thành phần của một mảng dữ liệu. Sau đây là ví dụ của việc cài đặt phương thức <em>generateCharacters()</em>, phương thức này gửi mỗi lần một dòng bằng cách đóng gói toàn bộ một dòng trong một mảng các byte:</p><figure class="post__image"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-134342.png" alt="" width="1210" height="590" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-xs.png 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-sm.png 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-md.png 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-lg.png 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-xl.png 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-2xl.png 1920w"></figure><figure class="post__image"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-134357.png" alt="" width="1233" height="200" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-xs.png 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-sm.png 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-md.png 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-lg.png 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-xl.png 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-2xl.png 1920w"></figure><p> Các stream cũng có thể được đưa vào vùng đệm bằng phần mềm như mã Java cũng như là trong phần cứng của mạng. Thông thường, việc đưa dữ liệu vào vùng đệm được thực hiện bằng cách gắn một <em>BufferedOutputStream </em>hay một <em>BufferedWriter </em>vào một stream lớp dưới. Để đưa dữ liệu trong một vùng đệm lên một kết nối ta sử dụng phương thức <em>flush()</em>. Phương thức <em>flush() </em>sẽ yêu cầu dòng phải gửi dữ liệu đã được đưa vào vùng đệm lên kết nối, ngay cả khi vùng đệm chưa đầy. Ta cần phải đưa hết tất cả các dữ liệu trong vùng đệm của các dòng bằng phương thức <em>flush() </em>trước khi ta đóng các dòng này, nếu không thì khi đóng các dòng, dữ liệu trong các vùng đệm sẽ bị mất.</p><figure class="post__image align-center"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Picture3.jpg" alt="" width="558" height="329" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-xs.jpg 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-sm.jpg 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-md.jpg 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-lg.jpg 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-xl.jpg 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-2xl.jpg 1920w"></figure><p>Khi đã làm việc xong với một stream ta có thể đóng stream này bằng cách gọi phương thức <em>close()</em>. Phương thức <em>close() </em>sẽ giải phóng tất cả các tài nguyên được liên kết với stream, chẳng hạn như các đặc tả tập tin (file handle) hay các cổng. Nếu stream có được từ một kết nối mạng thì khi đóng stream sẽ hủy bỏ kết nối mạng. Khi một output stream đã bị đóng việc ghi thêm dữ liệu vào stream sẽ đưa ra <em>IOException</em>. Tuy nhiên một vài kiểu stream vẫn cho phép chúng ta tiếp tục làm việc với đối tượng khi đã đóng stream. Ví dụ, một <em>ByteArrayOutputStream </em>đã bị đóng vẫn có thể được chuyển đổi thành mảng các byte thật sự và một <em>DigestOutputStream </em>đã bị đóng vẫn có thể trả về giá trị digest của nó.</p><p>            Nếu không đóng một stream trong một chương trình lớn có thể làm tiết lộ các đặc tả tập tin, các cổng mạng và các tài nguyên khác. Do đó, với Java 6 và các phiên bản trước đó, ta nên có một khối có tên là <em>finally </em>để đóng các dòng, khối này là khối cuối cùng trong một chương trình. Thông thường, ta khai báo biến <em>stream </em>bên ngoài khối <em>try </em>nhưng nên khởi tạo dòng bên trong khối <em>try</em>. Để tránh gặp phải <em>NullPointerExceptions </em>ta cần kiểm tra xem biến <em>stream </em>có phải là <em>null </em>hay không trước khi ta đóng dòng này. Ví dụ sau minh họa cách viết sử dụng <em>finally</em>:</p><figure class="post__image"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-135039.png" alt="" width="1208" height="509" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-xs.png 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-sm.png 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-md.png 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-lg.png 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-xl.png 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-2xl.png 1920w"></figure><p>Kỹ thuật này đôi khi được gọi là <em>dispose pattern</em>. Dispose pattern phổ biến cho các đối tượng cần phải được dọn dẹp trước khi các dữ liệu không còn sử dụng được thu dọn. Dispose pattern không chỉ được sử dụng cho các đối tượng và còn được sử dụng cho cả các sockets, channels, JDBC connections và các statements.</p><p>        Java 7 giới thiệu cách sử dụng khối <em>try </em>cùng với xây dựng các tài nguyên để thu dọn dữ liệu không còn sử dụng. Với cách này, dòng được khai báo trong một danh sách đối số bên trong khối <em>try</em>. Đoạn mã trên được viết lại như sau:</p><figure class="post__image"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-135212.png" alt="" width="1196" height="188" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-xs.png 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-sm.png 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-md.png 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-lg.png 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-xl.png 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-2xl.png 1920w"></figure><p>        Trong đoạn mã này ta nhận thấy khối <em>finally </em>đã không còn cần thiết. Java sẽ tự động gọi phương thức <em>close() </em>trên bất kỳ đối tượng có thuộc tính <em>AutoCloseable </em>bên trong danh sách đối số của khối <em>try</em>.</p><p>2.1/Các dòng vào (input stream)</p><p>Lớp input cơ bản của Java là <em>java.io.InputStream</em>, với khai báo như sau:</p><p>public abstract class InputStream{</p><p>}</p><p>Lớp này cung cấp các phương thức cơ bản để đọc dữ liệu như là các byte chưa được xử lý còn được gọi là byte thô:</p><ul><li><em>public abstract int <strong>read</strong>() throws IOException</em></li><li><em>public int <strong>read</strong>(byte[] input) throws IOException</em></li><li><em>public int <strong>read</strong>(byte[] input, int offset, int length) throws IOException</em></li><li><em>public long <strong>skip</strong>(long n) throws IOException</em></li><li><em>public int <strong>available</strong>() throws IOException</em></li><li><em>public void <strong>close</strong>() throws IOException</em></li></ul><p>Các lớp con cụ thể của <em>InputStream </em>sử dụng các phương thức này để đọc dữ liệu từ một phương tiện cụ thể. Ví dụ, một <em>FileOutputStream </em>sử dụng các phương thức này để đọc dữ liệu từ một file. Một <em>TelnetOutputStream </em>sử dụng các phương thức này để đọc dữ liệu từ một kết nối mạng. Một <em>ByteArrayOutputStream </em>sử dụng các phương thức này để đọc dữ liệu từ một mảng các byte.</p><p>         Phương thức cơ bản của <em>InputStream </em>là phương thức <em>read() </em>không có đối số. Phương thức <em>read() </em>đọc một byte dữ liệu từ nguồn của một input stream và trả lại một số nguyên nằm trong khoảng từ 0 đến 255. Kết thúc của một stream được báo hiệu bằng cách trả lại giá trị <em>-1</em>. Phương thức <em>read() </em>sẽ chờ và ngăn không cho thực thi bất kỳ đoạn mã nào sau phương thức này cho đến khi một byte dữ liệu sẵn sàng cho việc đọc.</p><p>         Việc đọc và ghi dữ liệu có thể chậm. Do đó nếu chương trình đang phải thực thi một đoạn mã quan trọng thì nên đặt các thao tác I/O trong một luồng (thread) riêng của thao tác I/O.</p><p>          Phương thức <em>read() </em>được mô tả là trừu tượng do các lớp con cần thay đổi phương thức này để quản lý các phương tiện cụ thể. Ví dụ, một <em>ByteArrayInputStream </em>có thể thực thi phương thức này bằng mã Java để sao chép byte từ một mảng. Tuy nhiên, một <em>TelnetInputStream </em>cần sử dụng một thư viện riêng để biết cách đọc dữ liệu từ một giao diện mạng trên nền của hệ điều hành.</p><p>          Đoạn mã sau đọc 10 byte từ <em>InputStream </em>có tên là <em>in </em>và lưu các byte trong một mảng byte có tên <em>input</em>. Trong quá trình đọc nếu phát hiện đã hết dữ liệu thì vòng lặp sẽ được kết thúc sớm hơn:</p><figure class="post__image"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-135708.png" alt="" width="1211" height="223" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-xs.png 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-sm.png 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-md.png 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-lg.png 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-xl.png 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-2xl.png 1920w"></figure><p>       Mặc dù <em>read() </em>chỉ đọc một byte, phương thức này trả lại một số nguyên, nên cần phải thực hiện chuyển đổi một số nguyên thành một byte bằng cast trước khi lưu trữ kết quả trong mảng byte. Vì <em>read() </em>trả lại một giá trị nguyên có phạm vi từ - 128 đến 127 thay vì 0 đến 255 nên ta cần phải chuyển đổi một byte có dấu thành byte không dấu như sau:</p><p>int i = b &gt;= 0 ? b : 256 + b;</p><p>      Cũng tương tự như việc ghi mỗi lần một byte trong <em>OutputStream</em>, việc đọc mỗi lần một byte sẽ là không hiệu quả. Có hai phương thức overloaded là <em>read(byte[] input) </em>và <em>read(byte[] input, int offset, int length)</em>. Hai phương thức này sẽ làm đầy một mảng các byte từ một dòng. Phương thức thứ nhất sẽ cố gắng làm đầy một mảng các byte có tên <em>input</em>. Phương thức thứ hai sẽ cố gắng làm đầy một mảng con các byte của mảng <em>input</em>, bắt đầu từ vị trí <em>offset </em>và sẽ ghi <em>length </em>byte. Việc ghi vào một mảng đôi khi sẽ không thành công vì nhiều lý do khác nhau. Ví dụ, tại một thời điểm, ta cố gắng để đọc 1024 byte từ một kết nối mạng, khi đó ta có thể nhận được 512 byte từ Server còn 512 byte đang được chuyển đến. Để biết được số lượng byte đã được đọc ta sử dụng các phương thức đọc nhiều byte. Đoạn mã sau trình bày cách đọc nhiều byte:</p><p>byte[] input = new byte[1024];</p><p>int bytesRead = in.read(input);</p><p>        Đoạn mã sẽ cố gắng đọc 1024 byte từ <em>InputStream </em>vào một mảng các byte có tên là <em>input</em>. Tuy nhiên, nếu chỉ có 512 byte để đọc thì <em>bytesRead </em>sẽ được thiết lập là 512.</p><p>        Để đảm bào đọc được tất cả các byte ta đặt thao tác đọc vào trong một vòng lặp cho đến khi mảng được làm đầy. Ví dụ:</p><p>int bytesRead = 0;</p><p>int bytesToRead = 1024;</p><p>byte[] input = new byte[bytesToRead]; while (bytesRead &lt; bytesToRead) {</p><p>bytesRead += in.read(input, bytesRead, bytesToRead - bytesRead);</p><p>}</p><p>           Tất cả các phương thức <em>read() </em>sẽ trả lại giá trị -1 để báo hiệu kết thúc một stream. Nếu một stream kết thúc trong khi vẫn còn dữ liệu chưa được đọc thì các phương thức đọc nhiều byte sẽ vẫn đọc dữ liệu cho đến khi vùng đệm trở nên trống. Khi đó việc đọc tiếp sẽ trả lại giá trị <em>-1 </em>và giá trị này sẽ không được ghi vào mảng. Do đó trong mảng chỉ chứa dữ liệu thực sự. Đoạn mã trên chưa cân nhắc đến trường hợp tất cả 1024 byte chưa đến được vùng đệm. Do đó, ta cần kiểm tra giá trị của <em>read() </em>trước khi bổ sung giá trị này vào <em>bytesRead</em>. Ví dụ:</p><p>int bytesRead = 0;</p><p>int bytesToRead = 1024;</p><p>byte[] input = new byte[bytesToRead]; while (bytesRead &lt; bytesToRead) {</p><p>int result = in.read(input, bytesRead, bytesToRead - bytesRead); if (result == -1) break; // end of stream</p><p>bytesRead += result;</p><p>}</p><p>       Ta có thể sử dụng phương thức <em>available() </em>để xác định số lượng byte có thể đọc ngay mà không cần phải chờ. Phương thức này trả lại số lượng byte tối thiểu mà ta có thể đọc. Ví dụ:</p><p>int bytesAvailable = in.available(); byte[] input = new byte[bytesAvailable];</p><p>int bytesRead = in.read(input, 0, bytesAvailable);</p><p>// continue with rest of program immediately...</p><p>       Trong một số ít trường hợp nếu muốn bỏ qua việc đọc dữ liệu, ta sử dụng phương thức <em>skip()</em>. Khi đã đọc xong dữ liệu từ một stream ta nên đóng stream bằng cách gọi phương thức <em>close() </em>của input stream. Phương thức này sẽ giải phóng tất cả các tài nguyên liên kết với dòng như các đặc tả tập tin hay các cổng. Khi một input strream đã bị đóng, các thao tác đọc dữ liệu tiếp theo sẽ đưa ra <em>IOException</em>. Tuy nhiên một vài kiểu stream có thể vẫn cho phép làm một số công việc với đối tượng. Ví dụ, ta sẽ không thể nhận được message digest từ một <em>java.security.DigestInputStream </em>cho đến khi dữ liệu đã được đọc và dòng bị đóng lại.</p><h2>Mark và Reset</h2><p>       Lớp <em>InputStream </em>có ba phương thức ít được sử dụng, các phương thức này cho phép các chương trình sao chép dự phòng (backup) và đọc lại dữ liệu đã được đọc trước đó:</p><ul><li><em>public void <strong>mark</strong>(int readAheadLimit)</em></li><li><em>public void <strong>reset</strong>() throws IOException</em></li><li><em>public boolean <strong>markSupported</strong>()</em></li></ul><p>        Để đọc lại dữ liệu cần đánh dấu (mark) vị trí hiện thời trong dòng bằng phương thức <em>mark()</em>. Sử dụng phương thức <em>reset() </em>để thiết lập lại (reset) dòng tại điểm đã đánh dấu. Các thao tác đọc tiếp theo sẽ trả lại dữ liệu bắt đầu từ điểm đánh dấu. Số lượng các byte có thể đọc từ vị trí đánh dấu được xác định bởi đối số <em>readAheadLimit </em>trong <em>mark()</em>. Nếu ta quay trở lại vượt quá điểm đã đánh dấu thì chương trình sẽ đưa ra <em>IOException</em>. Trong một dòng luôn chỉ tồn tại duy nhất một đánh dấu. Đánh dấu vị trí thứ hai sẽ xóa bỏ đánh dấu thứ nhất.</p><p> </p><p>      Đánh dấu và thiết lập lại thường được thực hiện bằng cách lưu trữ các byte được đọc kể từ vị trí đã được đánh dấu trong một vùng đệm bên trong chương trình. Tuy nhiên không phải tất cả các dòng đều hỗ trợ mark và reset.</p><p>      Để kiểm tra xem một dòng có hỗ trợ mark và reset không ta sử dụng phương thức <em>markSupported()</em>. Nếu phương thức này trả lại giá trị là <em>true </em>thì dòng có hỗ trợ mark và reset. Nếu phương thức này trả lại giá trị là <em>false </em>thì dòng không hỗ trợ mark và reset, khi đó <em>mark() </em>sẽ không làm gì và <em>reset() </em>sẽ đưa ra một <em>IOException</em>.</p><p>       Chỉ có các lớp <em>BufferedInputStream </em>và <em>ByteArrayInputStream </em>trong <em>java.io </em>là luôn hỗ trợ mark và reset. Tuy nhiên các input stream khác chẳng hạn như <em>TelnetInputStream </em>cũng có thể hỗ trợ mark nếu các lớp này lần đầu được gắn vào với một <em>BufferedInputStream</em>.</p><p>          2.3Các dòng filter stream</p><p><em>         InputStream </em>và <em>OutputStream </em>là các lớp tương đối đơn giản. Các lớp này chỉ thực hiện việc đọc và ghi từng byte hay một nhóm các byte. Việc xác định ý nghĩa của các byte, chẳng hạn như các byte có phải là các số nguyên, là các số thực dấu phảy động IEEE 754 hay là văn bản được mã hóa bằng bảng mã Unicode hoàn toàn phụ thuộc vào người lập trình và mã chương trình. Tuy nhiên có một vài định dạng dữ liệu vô cùng phổ biến đã được cài đặt trong thư viện lớp. Ví dụ, rất nhiều các số nguyên được truyền đi như là các phần của các giao thức mạng là các số nguyên 32 bit big-endian; nhiều văn bản được truyền trên web được mã hóa hoặc là ASCII 7-bit, Latin-1 8-bit, hay UTF-8 multibyte; nhiều file được truyền đi bằng giao thức FTP được lưu trữ dưới định dạng ZIP. Java cung cấp một số lượng các lớp lọc (filter classes) có thể được gắn vào các dòng để dịch các byte thô thành các định dạnh khác.</p><p>         Các filter được chia thành hai kiểu: các filter stream reader và writer. Filter stream chủ yếu làm việc với các dữ liệu thô như các byte, chẳng hạn như nén dữ liệu hoặc diễn dịch dữ liệu là các số nhị phân. Reader và writer quản lý trường hợp đặc biệt của văn bản trong nhiều cách mã hóa khác nhau như UTF-8 và ISO 8859-1.</p><p>          Các filter được tổ chức trong một chuỗi (chain). Mỗi liên kết trong chuỗi nhận dữ liệu từ filter trước hoặc từ dòng và truyền dữ liệu đến liên kết kế tiếp trong chuỗi. Sơ đồ sau trình bày chuỗi các filter.</p><figure class="post__image"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Picture4.jpg" alt="" width="307" height="591" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-xs.jpg 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-sm.jpg 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-md.jpg 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-lg.jpg 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-xl.jpg 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-2xl.jpg 1920w"></figure><p>Trong ví dụ trên, một file văn bản đã được mã hóa và được nén được truyền đến thông qua giao diện mạng cục bộ. Mã riêng của chương trình chuyển file này đến <em>TelnetInputStream</em>. Một <em>BufferedInputStream </em>sẽ đưa file vào vùng đệm để tăng tốc toàn bộ quá trình. Một <em>CipherInputStream </em>giải mã dữ liệu và một <em>GZIPInputStream </em>sẽ giải nén dữ liệu. Một <em>InputStreamReader </em>chuyển đổi dữ liệu đã được giải nén thành file văn bản mã hóa bằng mã Unicode. Cuối cùng, file văn bản đã sẵn sảng cho ứng dụng trong lớp ứng dụng và được xử lý.</p><p>Các filter output stream có cùng các phương thức như <em>write()</em>, <em>close() </em>và <em>flush() </em>như <em>java.io.OutputStream</em>. Các filter input stream có cùng các phương thức như <em>read()</em>, <em>close() </em>và <em>available() </em>như <em>java.io.InputStream</em>.</p><p>       2.4/Các lớp Reader and Writer</p><p>             2.4.1/Lớp Writter</p><p>          Lớp <em>Writer </em>tương ứng với lớp <em>java.io.OutputStream</em>. Lớp <em>Writer </em>là <em>abstract </em>và có hai <em>protected constructor</em>. Cũng giống như <em>OutputStream</em>, lớp <em>Writer </em>không bao giờ được sử dụng trực tiếp, thay vào đó lớp này được sử dụng theo kiểu polymorphic thông qua một trong số các lớp con của nó. Lớp <em>Writer </em>có năm phương thức <em>write() </em>và các phương thức <em>flush()</em>, <em>close()</em>:</p><ul><li><em>protected <strong>Writer</strong>()</em></li><li><em>protected <strong>Writer</strong>(Object lock)</em></li><li><em>public abstract void <strong>write</strong>(char[] text, int offset, int length) throws IOException</em></li><li><em>public void <strong>write</strong>(int c) throws IOException</em></li><li><em>public void <strong>write</strong>(char[] text) throws IOException</em></li><li><em>public void <strong>write</strong>(String s) throws IOException</em></li><li><em>public void <strong>write</strong>(String s, int offset, int length) throws IOException</em></li><li><em>public abstract void <strong>flush</strong>() throws IOException</em></li><li><em>public abstract void <strong>close</strong>() throws IOException</em></li></ul><p>           Phương thức <em>write(char[] text, int offset, int length) </em>là phương thức cơ bản để cho bốn phương thức <em>write() </em>còn lại được triển khai. Một lớp con cần phải ít nhất override phương thức này cũng như là override các phương thức <em>flush() </em>và <em>close()</em>.</p><p>              2.4.2/ Lớp OutputStream Writter</p><p><em>         OutputStreamWriter </em>là lớp con cụ thể quan trọng nhất của lớp <em>Writer</em>. Một <em>OutputStreamWriter </em>nhận các ký tự từ một chương trình Java sau đó sẽ chuyển đổi thành các byte dựa trên một cách mã hóa cụ thể và ghi các byte này lên một output stream lớp dưới. Constructor của <em>OutputStreamWriter </em>xác định output stream để ghi vào và cách mã hóa được sử dụng:</p><ul><li><em>public <strong>OutputStreamWriter</strong>(OutputStream out, String encoding) throws UnsupportedEncodingException</em></li></ul><p>           Ngoài các constructor, <em>OutputStreamWriter </em>chỉ có các phương thức <em>Writer </em>thông thường được sử dụng giống như trong lớp <em>Writer </em>và một phương thức để trả về mã hóa của đối tượng:</p><ul><li><em>public String <strong>getEncoding</strong>()</em></li></ul><p>2.4.3/ Lớp Reader</p><p>         Lớp <em>Reader </em>tương ứng với lớp <em>java.io.InputStream</em>. Lớp <em>Reader </em>là <em>abstract </em>và có hai <em>protected constructor</em>. Giống như <em>InputStream </em>và <em>Writer</em>, lớp <em>Reader </em>không bao giờ được dùng trực tiếp và chỉ được sử dụng thông qua một trong số các lớp con của nó. Lớp <em>Reader </em>có ba phương thức <em>read() </em>và các phương thức <em>skip()</em>, <em>close()</em>, <em>ready()</em>, <em>mark()</em>, <em>reset() </em>và <em>markSupported()</em>:</p><ul><li><em>protected <strong>Reader</strong>()</em></li><li><em>protected <strong>Reader</strong>(Object lock)</em></li><li><em>public abstract int <strong>read</strong>(char[] text, int offset, int length) throws IOException</em></li><li><em>public int <strong>read</strong>() throws IOException</em></li><li><em>public int <strong>read</strong>(char[] text) throws IOException</em></li><li><em>public long <strong>skip</strong>(long n) throws IOException</em></li><li><em>public boolean <strong>ready</strong>()</em></li><li><em>public boolean <strong>markSupported</strong>()</em></li><li><em>public void <strong>mark</strong>(int readAheadLimit) throws IOException</em></li><li><em>public void <strong>reset</strong>() throws IOException</em></li><li><em>public abstract void <strong>close</strong>() throws IOException</em></li></ul><p>        Phương thức <em>read(char[] text, int offset, int length) </em>là phương thức cơ bản qua đó hai phương thức <em>read() </em>còn lại được cài đặt. Một lớp con cần phải ít nhất override phương thức này cũng như là override phương thức <em>close()</em>.</p><p><em>         InputStreamReader </em>là lớp con cụ thể quan trọng nhất của <em>Reader</em>. Một <em>InputStreamReader </em>đọc các byte từ một input stream lớp dưới, chẳng hạn như một <em>FileInputStream</em><em> </em>hay <em>TelnetInputStream</em><em> </em>sau đó chuyển đổi các byte này thành các ký tự dựa trên một cách mã hóa cụ thể và trả về các ký tự này. Constructor của <em>InputStreamReader </em>xác định input stream để đọc và cách mã hóa được sử dụng:</p><ul><li><em>public <strong>InputStreamReader</strong>(InputStream in)</em></li><li><em>public <strong>InputStreamReader</strong>(InputStream in, String encoding) throws UnsupportedEncodingException</em></li></ul><p>             2.4.4/ Các lớp Filter Reader và Filter Writter</p><p>Các lớp <em>InputStreamReader </em>và <em>OutputStreamWriter </em>hoạt động trên đỉnh của các input stream và output stream. Các lớp này thay đổi giao diện từ một giao diện hướng byte (byte-oriented interface) thành một giao diện hướng ký tự (character-oriented interface). Sau khi đã thay đổi giao diện, các bộ lọc hướng ký tự (character-oriented filters) bổ sung sẽ được đặt trên đỉnh của reader và writer sử dụng các lớp <em>java.io.FilterReader </em>và <em>java.io.FilterWriter</em>. Cũng như các filter stream, có nhiều lớp con thực hiện các thao tác lọc cụ thể, bao gồm:</p><ul><li><strong><em>BufferedReader</em></strong></li><li><strong><em>BufferedWriter</em></strong></li><li><strong><em>LineNumberReader</em></strong></li><li><strong><em>PushbackReader</em></strong></li><li><strong><em>PrintWriter</em></strong></li></ul><p>Các lớp <em>BufferedReader </em>và <em>BufferedWriter </em>là các lớp dựa trên ký tự (character-based) tương đương với các lớp hướng byte (byte-oriented) <em>BufferedInputStream</em><em> </em>và <em>BufferedOutputStream</em>. Khi một chương trình đọc dữ liệu từ một <em>BufferedReader</em>, văn bản được lấy từ vùng đệm mà không phải được lấy trực tiếp từ input stream lớp dưới hay các nguồn khác. Khi vùng đệm không có dữ liệu, nó sẽ lại được làm đầy với số lượng ký tự càng nhiều càng tốt. Các ký tự này có thể sẽ không được sử dụng ngay mà có thể được sử dụng cho các lần đọc sau. Khi một chương trình ghi vào một <em>BufferedWriter</em>, văn bản sẽ được đưa vào vùng đệm. Văn bản chỉ được chuyển đến output stream lớp dưới hay các đích đến khác khi vùng đệm đã đầy hoặc khi vùng đệm được flush, điều này sẽ làm cho việc ghi trở nên nhanh hơn.</p><p> </p><p><em>BufferedReader </em>và <em>BufferedWriter </em>có những phương thức thông dụng kết hợp với các reader và writer là <em>read()</em>, <em>ready()</em>, <em>write() </em>và <em>close()</em>. Mỗi lớp có hai constructor, các constructor gắn <em>BufferedReader </em>hoặc <em>BufferedWriter </em>với reader hoặc writer lớp dưới và thiết lập kích thước của vùng đệm. Nếu kích thước của vùng đệm không được thiết lập thì kích thước mặc định của vùng đệm sẽ là 8192 ký tự:</p><ul><li><em>public <strong>BufferedReader</strong>(Reader in, int bufferSize)</em></li><li><em>public <strong>BufferedReader</strong>(Reader in)</em></li><li><em>public <strong>BufferedWriter</strong>(Writer out)</em></li><li><em>public <strong>BufferedWriter</strong>(Writer out, int bufferSize)</em></li></ul><p>Lớp <em>BufferedReader </em>cũng có một phương thức <em>readLine() </em>để đọc một dòng văn bản và trả về như một dòng:</p><ul><li><em>public String <strong>readLine</strong>() throws IOException</em></li></ul><p>Phương thức này thay thế cho phương thức đã bị phản đối <em>readLine() </em>trong <em>DataInputStream</em>. Sự khác biệt giữa hai phương thức này khi gắn một <em>BufferedReader </em>vào một <em>InputStreamReader </em>ta có thể đọc chính xác các dòng trong một tập hợp các ký tự thay vì cách mã hóa mặc định của hệ thống.</p><p>Lớp <em>BufferedWriter </em>bổ sung một phương thức mới không có trong lớp cha (superclass), được gọi là <em>newLine()</em>, phương thức này hướng đến việc ghi các dòng:</p><ul><li><em>public void <strong>newLine</strong>() throws IOException</em></li></ul><p>             2.4.5/ Lớp Scanner</p><p>         Lớp <em>Scanner </em>trong Java dùng để quét trên các dòng vào (bàn phím, socket, xâu kí tự…) để lấy được các giá trị mong muốn: xâu kí tự, số nguyên, số thực,…</p><p>Một số phương thức thường được sử dụng của lớp <em>Scanner </em>trong Java:</p><table><tbody><tr><td width="264"><p><strong>Phương thức</strong></p></td><td width="331"><p><strong>Mô tả</strong></p></td></tr><tr><td width="264"><p><em>public String <strong>next</strong>()</em></p></td><td width="331"><p>Trả về một xâu kí tự trước khoảng trắng</p></td></tr><tr><td width="264"><p><em>public String <strong>nextLine</strong>()</em></p></td><td width="331"><p>Trả về kết quả nội dung của một dòng</p></td></tr><tr><td width="264"><p><em>public byte <strong>nextByte</strong>()</em></p></td><td width="331"><p>Trả về kiểu dữ liệu byte</p></td></tr><tr><td width="264"><p><em>public short <strong>nextShort</strong>()</em></p></td><td width="331"><p>Trả về kiểu dữ liệu short</p></td></tr><tr><td width="264"><p><em>public int <strong>nextInt</strong>()</em></p></td><td width="331"><p>Trả về kiểu dữ liệu int</p></td></tr><tr><td width="264"><p><em>public long <strong>nextLong</strong>()</em></p></td><td width="331"><p>Trả về kiểu dữ liệu long</p></td></tr><tr><td width="264"><p><em>public float <strong>nextFloat</strong>()</em></p></td><td width="331"><p>Trả về kiểu dữ liệu float</p></td></tr><tr><td width="264"><p><em>public double <strong>nextDouble</strong>()</em></p></td><td width="331"><p>Trả về kiểu dữ liệu double</p></td></tr></tbody></table><p> </p><p>Đoạn mã sau cho phép nhập một số nguyên từ bàn phím và in ra số đó:</p><figure class="post__image"><img loading="lazy" src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-141146.png" alt="" width="1213" height="329" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-xs.png 640w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-sm.png 768w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-md.png 1024w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-lg.png 1366w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-xl.png 1600w, file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-2xl.png 1920w"></figure><p>      2.4.6/Lớp Printer</p><p>Lớp <em>PrintWriter </em>thay thế cho lớp <em>PrintStream </em>trong Java 1.0. Lớp này thích hợp cho việc kiểm soát các ký tự được mã hóa bằng nhiều byte và các văn bản quốc tế.</p><p>Ngoài các constructor, lớp <em>PrintWriter </em>cũng có một tập hợp các phương thức tương tự như lớp <em>PrintStream</em>, đó là:</p><ul><li><em>public <strong>PrintWriter</strong>(Writer out)</em></li><li><em>public <strong>PrintWriter</strong>(Writer out, boolean autoFlush)</em></li><li><em>public <strong>PrintWriter</strong>(OutputStream out)</em></li><li><em>public <strong>PrintWriter</strong>(OutputStream out, boolean autoFlush)</em></li><li><em>public void <strong>flush</strong>()</em></li><li><em>public void <strong>close</strong>()</em></li><li><em>public boolean <strong>checkError</strong>()</em></li><li><em>public void <strong>write</strong>(int c)</em></li><li><em>public void <strong>write</strong>(char[] text, int offset, int length)</em></li><li><em>public void <strong>write</strong>(char[] text)</em></li><li><em>public void <strong>write</strong>(String s, int offset, int length)</em></li><li><em>public void <strong>write</strong>(String s)</em></li><li><em>public void <strong>print</strong>(boolean b)</em></li><li><em>public void <strong>print</strong>(char c)</em></li><li><em>public void <strong>print</strong>(int i)</em></li><li><em>public void <strong>print</strong>(long l)</em></li><li><em>public void <strong>print</strong>(float f)</em></li><li><em>public void <strong>print</strong>(double d)</em></li><li><em>public void <strong>print</strong>(char[] text)</em></li><li><em>public void <strong>print</strong>(String s)</em></li><li><em>public void <strong>print</strong>(Object o)</em></li><li><em>public void <strong>println</strong>()</em></li><li><em>public void <strong>println</strong>(boolean b)</em></li><li><em>public void <strong>println</strong>(char c)</em></li><li><em>public void <strong>println</strong>(int i)</em></li><li><em>public void <strong>println</strong>(long l)</em></li><li><em>public void <strong>println</strong>(float f)</em></li><li><em>public void <strong>println</strong>(double d)</em></li><li><em>public void <strong>println</strong>(char[] text)</em></li><li><em>public void <strong>println</strong>(String s)</em></li><li><em>public void <strong>println</strong>(Object o)</em></li></ul><p>Hầu hết các phương thức trên hoạt động tương tự như các phương thức trong <em>PrintStream </em>ngoại trừ bốn phương thức <em>write()</em>. Bốn phương thức <em>write() </em>sẽ không ghi các byte mà ghi các ký tự.</p><p>Trong lập trình mạng hiện nay, chúng ta thường dùng lớp <em>Scanner </em>làm input stream và <em>PrintWriter </em>làm output stream vì 2 lớp này hỗ trợ tốt việc đọc và ghi nhiều kiểu dữ liệu khác nhau với các phương thức linh hoạt, hiệu quả.</p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">This article was updated on December 29, 2024</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://github.com/123VuPhuc/myblog.git/assets/svg/svg-map.svg#share"></use></svg> <span>Share It</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/123VuPhuc/myblog.git/authors/vu-tran-hoang-phuc/" rel="author">Vũ Trần Hoàng Phúc</a></h3></div></div></div></footer></article></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/123VuPhuc/myblog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/123VuPhuc/myblog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>