<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 3:LẬP TRÌNH ĐA LUỒNG TRONG JAVA - Blog của tôi</title><meta name="description" content="3.1/Giới thiệu về luồng (thread) Thread (luồng) về cơ bản là một tiến trình con (sub-process). Một đơn vị xử lý nhỏ nhất của máy tính có thể thực hiện một công việc riêng biệt. Trong Java, các luồng được quản lý bởi máy ảo&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://123vuphuc.github.io/myblog/bai-3.html"><link rel="alternate" type="application/atom+xml" href="https://123vuphuc.github.io/myblog/feed.xml"><link rel="alternate" type="application/json" href="https://123vuphuc.github.io/myblog/feed.json"><meta property="og:title" content="Bài 3:LẬP TRÌNH ĐA LUỒNG TRONG JAVA"><meta property="og:image" content="https://123vuphuc.github.io/myblog/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:site_name" content="Blog của tôi"><meta property="og:description" content="3.1/Giới thiệu về luồng (thread) Thread (luồng) về cơ bản là một tiến trình con (sub-process). Một đơn vị xử lý nhỏ nhất của máy tính có thể thực hiện một công việc riêng biệt. Trong Java, các luồng được quản lý bởi máy ảo&hellip;"><meta property="og:url" content="https://123vuphuc.github.io/myblog/bai-3.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://123vuphuc.github.io/myblog/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://123vuphuc.github.io/myblog/bai-3.html"},"headline":"Bài 3:LẬP TRÌNH ĐA LUỒNG TRONG JAVA","datePublished":"2024-12-29T11:11+07:00","dateModified":"2024-12-29T20:36+07:00","image":{"@type":"ImageObject","url":"https://123vuphuc.github.io/myblog/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920},"description":"3.1/Giới thiệu về luồng (thread) Thread (luồng) về cơ bản là một tiến trình con (sub-process). Một đơn vị xử lý nhỏ nhất của máy tính có thể thực hiện một công việc riêng biệt. Trong Java, các luồng được quản lý bởi máy ảo&hellip;","author":{"@type":"Person","name":"Vũ Trần Hoàng Phúc","url":"https://123vuphuc.github.io/myblog/authors/vu-tran-hoang-phuc/"},"publisher":{"@type":"Organization","name":"Vũ Trần Hoàng Phúc","logo":{"@type":"ImageObject","url":"https://123vuphuc.github.io/myblog/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="page-template"><a href="/about-me"><label style="color: #007BFF; cursor: pointer;">Click here to read my About Me page</label></a><header class="top js-header"><a class="logo" href="https://123vuphuc.github.io/myblog/"><img src="https://123vuphuc.github.io/myblog/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg" alt="Blog của tôi" width="1920" height="1080"></a></header><main class="page"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 3:LẬP TRÌNH ĐA LUỒNG TRONG JAVA</h1></div></header></div><div class="entry-wrapper content__entry"><p>3.1/Giới thiệu về luồng (thread)</p><p><em>           Thread </em>(luồng) về cơ bản là một tiến trình con (sub-process). Một đơn vị xử lý nhỏ nhất của máy tính có thể thực hiện một công việc riêng biệt. Trong Java, các luồng được quản lý bởi máy ảo Java (JVM).</p><p><em>      Multi-thread </em>(đa luồng) là một tiến trình thực hiện nhiều luồng đồng thời. Một ứng dụng Java ngoài luồng chính có thể có các luồng khác thực thi đồng thời làm ứng dụng chạy nhanh và hiệu quả hơn.</p><p>Trình duyệt web hay các chương trình chơi nhạc là ví dụ điển hình về đa luồng:</p><p>+ Khi duyệt 1 trang web, có rất nhiều hình ảnh, mã CSS, mã JavaScript… được tải đồng thời bởi các luồng khác nhau.</p><p>+ Khi đang chơi nhạc, chúng ta vẫn có thể tương tác được với nút điều khiển như: play, pause, next, back … vì luồng phát nhạc là luồng riêng biệt với luồng tiếp nhận tương tác của người dùng.</p><p>          3.1.2/Đa nhiệm (multitasking)</p><p><em>               Multitasking </em>là khả năng chạy đồng thời một hoặc nhiều chương trình cùng một lúc trên một hệ điều hành. Hệ điều hành quản lý việc này và sắp xếp lịch phù hợp cho các chương trình đó. Ví dụ, trên hệ điều hành Windows chúng ta có làm việc đồng thời với các chương trình khác nhau như: Word, Excel, Chrome, …</p><p>      Chúng ta sử dụng đa nhiệm để tận dụng tính năng của CPU. Đa nhiệm có thể đạt được bằng hai cách:</p><ol><li><em></em><em>Đa nhiệm dựa trên tiến trình (process) – Đa tiến trình (multiprocessing).</em><ul><li>Mỗi tiến trình có địa chỉ riêng trong bộ nhớ, tức là mỗi tiến trình được phân bổ vùng nhớ riêng biệt.</li><li>Đa nhiệm dựa trên tiến trình là <em>nặng</em>.</li><li>Sự giao tiếp giữa các tiến trình có <em>chi phí cao</em>.</li><li>Chuyển đổi từ tiến trình này sang tiến trình khác đòi hỏi thời gian để đăng ký việc lưu và tải các bản đồ bộ nhớ, các danh sách cập nhật, …</li></ul></li><li><em></em><em>Đa nhiệm dựa trên luồng (thread) – Đa luồng (multithreading).</em><ul><li>Các luồng chia sẻ không gian địa chỉ ô nhớ giống</li><li>Đa nhiệm dựa trên luồng là <em>nhẹ</em>.</li></ul></li></ol><ul><li>Sự giao tiếp giữa các luồng có <em>chi phí thấp</em>.</li></ul><p>        Đa tiến trình (multiprocessing) và đa luồng (multithreading) đều được sử dụng để tạo ra hệ thống đa nhiệm (multitasking). Nhưng chúng ta sử dụng đa luồng nhiều hơn đa tiến trình bởi vì các luồng chia sẻ một vùng bộ nhớ chung. Chúng không phân bổ vùng bộ nhớ riêng biệt để tiết kiệm bộ nhớ, và chuyển đổi ngữ cảnh giữa các luồng mất ít thời gian hơn giữa các tiến trình.</p><p>      3.1.3/ Ưu điểm và nhược điểm đa luồng</p><h2>Ưu điểm:</h2><ul><li>Đa luồng không chặn người sử dụng vì các luồng là độc lập và chúng ta có thể thực hiện nhiều công việc cùng một lúc.</li><li>Mỗi luồng có thể dùng chung và chia sẻ nguồn tài nguyên trong quá trình chạy, nhưng có thể thực hiện một cách độc lập.</li><li>Luồng là độc lập vì vậy nó không ảnh hưởng đến luồng khác nếu ngoại lệ xảy ra trong một luồng duy nhất.</li><li>Chương trình có thể thực hiện nhiều hoạt động với nhau để tiết kiệm thời gian. Ví dụ một ứng dụng có thể được tách thành: luồng chính chạy giao diện người dùng và các luồng phụ gửi kết quả xử lý đến luồng chính.</li></ul><h2>Nhược điểm:</h2><ul><li>Càng nhiều luồng thì xử lý càng phức tạp.</li><li>Xử lý vấn đề về tranh chấp bộ nhớ, đồng bộ dữ liệu khá phức tạp.</li><li>Cần phát hiện tránh các luồng chết (deadlock) - luồng chạy mà không làm gì trong ứng dụng cả. Deadlock xảy ra khi 2 tiến trình đợi nhau hoàn thành trước khi chạy, kết quả của quá trình là cả 2 tiến trình không bao giờ kết thúc.</li></ul><p>        3.2/Vòng đời của một luồng trong Java</p><p>Vòng đời của luồng trong Java được kiểm soát bởi JVM. Java định nghĩa các trạng thái của luồng trong các thuộc tính <em>static </em>của lớp <em>Thread.State</em>:</p><figure class="post__image"><img loading="lazy" src="https://123vuphuc.github.io/myblog/media/posts/8/Anh-chup-man-hinh-2024-12-29-203134.png" alt="" width="645" height="133" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://123vuphuc.github.io/myblog/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-29-203134-xs.png 640w, https://123vuphuc.github.io/myblog/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-29-203134-sm.png 768w, https://123vuphuc.github.io/myblog/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-29-203134-md.png 1024w, https://123vuphuc.github.io/myblog/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-29-203134-lg.png 1366w, https://123vuphuc.github.io/myblog/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-29-203134-xl.png 1600w, https://123vuphuc.github.io/myblog/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-29-203134-2xl.png 1920w"></figure><p><strong>NEW</strong>: Đây là trạng thái khi luồng vừa được khởi tạo bằng phương thức khởi tạo của lớp <em>Thread </em>nhưng chưa được <em>start()</em>. Ở trạng thái này, luồng được tạo ra nhưng chưa được cấp phát tài nguyên và cũng chưa chạy. Nếu luồng đang ở trạng thái này mà ta gọi các phương thức ép buộc <em>stop()</em>, <em>resume()</em>, <em>suspend()</em>… sẽ là nguyên nhân xảy ra ngoại lệ <em>IllegalThreadStateException </em>.</p><p><strong>RUNNABLE</strong>: Sau khi gọi phương thức <em>start() </em>thì luồng đã được cấp phát tài nguyên và các lịch điều phối CPU cho luồng cũng bắt đầu có hiệu lực. Ở đây, chúng ta dùng trạng thái là <em>Runnable </em>chứ không phải Running, vì luồng không thực sự luôn chạy mà tùy vào hệ thống mà có sự điều phối CPU khác nhau.</p><p><strong>BLOCKED</strong>: Đây là 1 dạng của trạng thái <em>Not Runnable</em>. Luồng chờ được unlock mới hoạt động trở lại.</p><p><strong>TERMINATED</strong>: Một luồng ở trong trạng thái terminated hoặc dead khi phương thức <em>run() </em>của nó bị thoát.</p><p><strong>TIMED WAITING</strong>: Luồng chờ trong một thời gian nhất định, hoặc là có một luồng khác đánh thức nó.</p><p><strong>WAITING</strong>: Luồng chờ không giới hạn cho đến khi được một luồng khác đánh thức nó.</p><p>       3.3/Cách tạo luồng trong Java<br>             3.3.1/Tạo luồng bằng cách kế thừa từ lớp Thread</p><p>          Để tạo luồng bằng cách tạo lớp kế thừa từ lớp <em>Thread</em>, ta phải làm các công việc sau :</p><ol><li>Khai báo 1 lớp mới kế thừa từ lớp <em>Thread</em>.</li><li>Override lại phương thức <em>run() </em>ở lớp này, những gì trong phương thức <em>run() </em>sẽ được thực thi khi luồng bắt đầu chạy. Sau khi luồng chạy xong tất cả các câu lệnh trong phương thức <em>run() </em>thì luồng cũng tự hủy.</li><li>Tạo 1 instance (hay 1 đối tượng) của lớp vừa khai báo.</li><li>Sau đó gọi phương thức <em>start() </em>của đối tượng này để bắt đầu thực thi luồng.</li></ol><p>Ví dụ đơn giản về tạo luồng từ lớp <em>Thread</em>:</p><p>package vn.tbit.simple;</p><p> </p><p>public class TheadSimple extends Thread { public void run() {</p><p>System.out.println("Thread đang chạy...");</p><p>}</p><p>public static void main(String args[]) { TheadSimple t1 = new TheadSimple(); t1.start();</p><p>}</p><p>}</p><p>Lưu ý :</p><ul><li>Tuy khai báo những công việc cần làm của luồng trong phương thức <em>run() </em>nhưng khi thực thi luồng ta phải gọi phương thức <em>start()</em>. Vì đây là phương thức đặc biệt mà Java xây dựng sẵn trong lớp <em>Thread</em>, phương thức này sẽ cấp phát tài nguyên cho luồng mới rồi chạy phương thức <em>run() </em>ở luồng này. Vì vậy, nếu ta gọi phương thức <em>run() </em>mà không gọi <em>start() </em>thì cũng tương đương với việc gọi một phương thức của một đối tượng bình thường và phương thức vẫn chạy trên luồng đã gọi phương thức chứ không chạy ở luồng mới tạo Như vậy, vẫn chỉ có một luồng chính làm việc chứ ứng dụng vẫn không phải là đa luồng.</li><li>Sau khi gọi <em>start() </em>một luồng thì không bao giờ có thể gọi <em>start() </em>lại. Nếu làm như vậy, một ngoại lệ <em>IllegalThreadStateException </em>sẽ xảy ra.</li></ul><p>     3.3.2/Tạo luồng bằng cách hiện thực từ giao diện Runable</p><p>           Để tạo luồng bằng cách hiện thực từ <em>Interface Runnable</em>, ta phải làm các công việc sau :</p><ol><li>Khai báo 1 lớp mới <em>implements </em>từ <em>Interface Runnable</em>.</li><li>Hiện thực phương thức <em>run() </em>ở lớp này, những gì trong phương thức <em>run() </em>sẽ được thực thi khi luồng bắt đầu chạy. Sau khi luồng chạy xong tất cả các câu lệnh trong phương thức <em>run() </em>thì luồng cũng tự hủy.</li><li>Tạo 1 instance (hay 1 đối tượng) của lớp vừa khai báo, giả sử là <em>r1</em>.</li><li>Tạo 1 instance của lớp <em>Thread </em>bằng phương thức khởi tạo <em>Thread(Runnable target) </em>trong đó <em>target </em>là 1 đối tượng thuộc lớp được <em>implements </em>từ giao diện <em>Runnable</em>.</li></ol><p>         Ví dụ: <em>Thread t1 = new Thread(r1);</em></p><p>   5.   Gọi phương thức <em>start() </em>của đối tượng <em>t1</em>. </p><p>Ví dụ đơn giản về tạo luồng từ giao diện <em>Runnable</em>:<br><br></p><p>package vn.tbit.simple;</p><p> </p><p>public class RunnableSimple implements Runnable { public void run() {</p><p>System.out.println("Thread đang chạy...");</p><p>}</p><p> </p><p>public static void main(String args[]) { RunnableSimple runable = new RunnableSimple(); Thread t1 = new Thread(runable);</p><p>t1.start();</p><p>}</p><p>}</p><p>Khi nào <em>implements </em>từ <em>Interface Runnable</em>?</p><p>+ Cách hay được sử dụng và được yêu thích là dùng <em>Interface Runnable</em>, bởi vì nó không yêu cầu phải tạo một lớp kế thừa từ lớp <em>Thread</em>. Trong trường hợp ứng dụng thiết kế yêu cầu sử dụng đa kế thừa, chỉ có interface mới có thể giúp giải quyết vấn đề. Ngoài ra nó cũng rất hiệu quả và được cài đặt, sử dụng rất đơn giản.</p><p>+ Trong trường hợp còn lại ta có thể kế thừa từ lớp <em>Thread</em>.</p><p>      3.4/Ví dụ minh hoạ sử dụng đa luồng</p><p><strong><em>Ví dụ 3-1</em></strong><em>. Tạo luồng bằng cách </em><em>extends </em><em>từ lớp </em><em>Thread</em><em>.</em></p><p>Tạo lớp <em>extends </em>từ <em>Thread</em>:</p><p>package vn.tbit.flow;</p><p> </p><p>public class ThreadDemo extends Thread { private Thread t;</p><p>private String threadName;</p><p>ThreadDemo(String name) { threadName = name;</p><p>System.out.println("Creating " + threadName);</p><p>}</p><p> </p><p>@Override</p><p>public void run() {</p><p>System.out.println("Running " + threadName); try {</p><p>for (int i = 4; i &gt; 0; i--) {</p><p>System.out.println("Thread: " + threadName + ", " + i);</p><p>// Thread tạm nghỉ. Thread.sleep(50);</p><p>}</p><p>} catch (InterruptedException e) {</p><p>System.out.println("Thread " + threadName + " interrupted.");</p><p>}</p><p>System.out.println("Thread " + threadName + " exiting.");</p><p>}</p><p> </p><p>public void start() { System.out.println("Starting " + threadName); if (t == null) {</p><p>t = new Thread(this, threadName); t.start();</p><p>}</p><p>}</p><p>}</p><p>         Chương trình sử dụng đa luồng:</p><p>package vn.tbit.flow;</p><p> </p><p>public class ThreadDemoTest {</p><p>public static void main(String args[]) { System.out.println("Main thread running... ");</p><p> </p><p>ThreadDemo T1 = new ThreadDemo("Thread-1-HR-Database"); T1.start();</p><p> </p><p>ThreadDemo T2 = new ThreadDemo("Thread-2-Send-Email"); T2.start();</p><p> </p><p>System.out.println("==&gt; Main thread stopped!!! ");</p><p>}</p><p>}</p><p>         Kết quả thực thi chương trình trên:</p><p>Main thread running...</p><p>Creating Thread-1-HR-Database</p><p>Starting Thread-1-HR-Database</p><p>Creating Thread-2-Send-Email</p><p>Starting Thread-2-Send-Email</p><p>==&gt; Main thread stopped!!!</p><p>Running Thread-1-HR-Database Running Thread-2-Send-Email Thread: Thread-2-Send-Email, 4</p><p>Thread: Thread-1-HR-Database, 4</p><p>Thread: Thread-1-HR-Database, 3</p><p>Thread: Thread-2-Send-Email, 3</p><p>Thread: Thread-2-Send-Email, 2</p><p>Thread: Thread-1-HR-Database, 2</p><p>Thread: Thread-2-Send-Email, 1</p><p>Thread: Thread-1-HR-Database, 1 Thread Thread-2-Send-Email exiting. Thread Thread-1-HR-Database exiting.</p><p>           Kết quả chương trình trên được giải thích thông qua hình bên dưới:</p><p>Ví dụ: Hãy in ra địa chỉ của tất cả các máy trạm trên mạng mà có cùng tên miền <a href="http://www.microsoft.com/">www.microsoft.com:</a></p><p><em>//AllAddr.java</em><em> </em><em>import java.net.*; public class AllAddr{</em></p><p><em>public static void main (String[] args) { try {</em></p><p><em>InetAddress[] addresses = InetAddress.getAllByName("</em><a href="http://www.microsoft.com/"><em>www.microsoft.com</em></a><em>");</em></p><p><em>for (int i = 0; i &lt; addresses.length; i++) { System.out.println(addresses[i]);</em></p><p><em>}</em></p><p><em>}</em></p><p><em>catch (UnknownHostException ex) { System.out.println("Could not find </em><a href="http://www.microsoft.com/"><em>www.microsoft.com")</em></a><em>;</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p><strong><em>Ví dụ 3-2</em></strong><em>. Tạo luồng bằng cách </em><em>implements </em><em>từ giao diện </em><em>Runnable</em><em>.</em></p><p>Tạo lớp <em>implements </em>từ giao diện <em>Runnable</em>:</p><p class="align-center"> </p><p>Ví dụ: Cho địa chỉ, in ra tên máy trạm:</p><p><em>import java.net.*;</em></p><p><em>public class ReverseTest {</em></p><p><em>public static void main (String[] args) { try {</em></p><p><em>InetAddress ia = InetAddress.getByName("208.201.239.37"); System.out.println(ia.getHostName( ));</em></p><p><em>}</em></p><p><em>catch (Exception ex) { System.err.println(ex);</em></p><p><em>}</em></p><p><em>}</em></p><p>}</p><p>Chương trình sử dụng đa luồng:</p><p>Ví dụ: In ra địa chỉ IP của máy cục bộ</p><p><em>import java.net.*; public class MyAddress {</em></p><p><em>public static void main(String[] args) { try {</em></p><p><em>InetAddress me = InetAddress.getLocalHost( ); String dottedQuad = me.getHostAddress( ); System.out.println("My address is " + dottedQuad);</em></p><p class="align-center"> </p><p><em>}</em></p><p><em>catch (UnknownHostException ex) {</em></p><p><em>System.out.println("I'm sorry. I don't know my own address.");</em></p><p><em>}</em></p><p><em>}</em></p><p><em>}</em></p><p>Kết quả thực thi chương trình trên:</p><p>Ví dụ: Phương thức getVersion() lấy phiên bản địa chỉ IP của máy cục bộ:</p><p><em>import java.net.*;</em></p><p><em>public class AddressTests {</em></p><p><em>public static int getVersion(InetAddress ia) { byte[] address = ia.getAddress( );</em></p><p><em>if (address.length == 4) return 4;</em></p><p><em>else if (address.length == 16) return 6; else return -1;</em></p><p><em>}</em></p><p>Kết quả chương trình trên được giải thích thông qua hình bên dưới:</p><p><em>for(int i=0;i&lt;address.length;i++) System.out.println((address[i]&gt;0)?address[i]: (address[i]+256));</em></p><p><em> </em></p><p>     3.5/ Các phương pháp Thread thường được sử dụng</p><ul><li><em>suspend()</em>: phương thức làm tạm dừng hoạt động của 1 luồng nào đó bằng các ngưng cung cấp CPU cho luồng này. Để cung cấp lại CPU cho luồng ta sử dụng phương thức <em>resume()</em>. Cần lưu ý là ta không thể dừng ngay hoạt động của luồng bằng phương thức này. Phương thức <em>suspend() </em>không dừng ngay tức thì hoạt động của luồng mà sau khi luồng này trả CPU về cho hệ điều hành thì không cấp CPU cho luồng nữa.</li><li><em>resume()</em>: phương thức làm cho luồng chạy lại khi luồng bị dừng do phương thức <em>suspend() </em>bên trên. Phương thức này sẽ đưa luồng vào lại lịch điều phối CPU để luồng được cấp CPU chạy lại bình thường.</li><li><em>stop()</em>: phương thức này sẽ kết thúc phương thức <em>run() </em>bằng cách ném ra 1 ngoại lệ <em>ThreadDeath</em>, điều này cũng sẽ làm luồng kết thúc 1 cách ép buộc. Nếu giả sử, trước khi gọi <em>stop() </em>mà luồng đang nắm giữa 1 đối tượng nào đó hoặc 1 tài nguyên nào đó mà luồng khác đang chờ thì có thể dẫn tới việc xảy ra deadlock.</li><li><em>destroy()</em>: dừng hẳn luồng.</li><li><em>isAlive()</em>: phương thức này kiểm tra xem luồng còn <em>active </em>hay không. Phương thức sẽ trả về <em>true </em>nếu luồng đã được <em>start() </em>và chưa rơi vào trạng thái <em>dead</em>. Nếu phương thức trả về <em>false </em>thì luồng đang ở trạng thái <em>New Thread </em>hoặc là đang ở trạng thái <em>dead</em>.</li><li><em>yeild() </em>: hệ điều hành đa nhiệm sẽ phân phối CPU cho các tiến trình, các luồng theo vòng xoay. Mỗi luồng sẽ được cấp CPU trong 1 khoảng thời gian nhấtđịnh, sau đó trả lại CPU cho hệ điều hành, hệ điều hành sẽ cấp CPU cho luồng khác. Khi gọi phương thức này luồng sẽ bị ngừng cấp CPU và nhường cho luồng tiếp theo trong hàng chờ <em style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Ready</em><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">. Luồng không phải ngưng cấp CPU như </span><em style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">suspend() </em><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">mà chỉ ngưng cấp trong lần nhận CPU đó mà thôi.</span></li><li><em>sleep(long)</em>: tạm dừng luồng trong một khoảng thời gian tính bằng mili giây.</li><li><em>join()</em>: thông báo rằng hãy chờ luồng này hoàn thành rồi luồng cha mới được tiếp tục chạy.</li><li><em>join(long)</em>: luồng cha cần phải đợi sau mili giây mới được tiếp tục chạy, kể từ lúc gọi <em>join(long)</em>. Nếu tham số bằng <em>0 </em>nghĩa là đợi cho tới khi luồng này kết thúc.</li><li><em>getName()</em>: trả về tên của luồng.</li><li><em>setName(String name)</em>: thay đổi tên của luồng.</li><li><em>getId()</em>: trả về id của luồng.</li><li><em>getState()</em>: trả về trạng thái của luồng.</li><li><em>currentThread()</em>: trả về tham chiếu của luồngđang được thi hành.</li><li><em>getPriority()</em>: trả về mức độ ưu tiên của luồng.</li><li><em>setPriority(int)</em>: thay đổi mức độ ưu tiên của luồng.</li><li><em>isDaemon()</em>: kiểm tra nếu luồnglà một luồng</li><li><em>setDaemon(boolean)</em>: thiết lập luồnglà một luồng Daemon hay không.</li><li><em>interrupt()</em>: làm gián đoạn một luồng trong Java. Nếu luồng nằm trong trạng thái sleep hoặc wait, nghĩa là <em>sleep() </em>hoặc <em>wait() </em>được gọi ra. Việc gọi phương thức <em>interrupt() </em>trên luồng đó sẽ phá vỡ trạng thái sleep hoặc wait và ném ra ngoại lệ <em>InterruptedException</em>. Nếu luồng không ở trong trạng thái sleep hoặc wait, việc gọi phương thức <em>interrupt() </em>thực hiện hành vi bình thường và không làm gián đoạn luồng nhưng đặt cờ interrupt thành <em>true</em>.</li><li><em>isInterrupted()</em>: kiểm tra luồng nào đó đã bị ngắt hay không.</li><li><em>interrupted()</em>: kiểm tra xem luồng hiện tại đã bị ngắt hay không.</li></ul><p> </p><p> </p><p> </p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://123vuphuc.github.io/myblog/authors/vu-tran-hoang-phuc/" rel="author">Vũ Trần Hoàng Phúc</a></h3></div></div></div></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://123vuphuc.github.io/myblog/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://123vuphuc.github.io/myblog/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>