<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Bài 6:Lập trình giao thức UDP - Blog của tôi</title><meta name="description" content="6.1/ Khái niệm chung UDP là viết tắt của cụm từ User Datagram Protocol. UDP là một phần của bộ giao thức Internet được sử dụng bởi các chương trình chạy trên các máy tính khác nhau trên mạng. Không giống như TCP, UDP được&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://github.com/123VuPhuc/myblog.git/bai-6.html"><link rel="alternate" type="application/atom+xml" href="https://github.com/123VuPhuc/myblog.git/feed.xml"><link rel="alternate" type="application/json" href="https://github.com/123VuPhuc/myblog.git/feed.json"><meta property="og:title" content="Bài 6:Lập trình giao thức UDP"><meta property="og:image" content="https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg"><meta property="og:image:width" content="1920"><meta property="og:image:height" content="1080"><meta property="og:site_name" content="Blog của tôi"><meta property="og:description" content="6.1/ Khái niệm chung UDP là viết tắt của cụm từ User Datagram Protocol. UDP là một phần của bộ giao thức Internet được sử dụng bởi các chương trình chạy trên các máy tính khác nhau trên mạng. Không giống như TCP, UDP được&hellip;"><meta property="og:url" content="https://github.com/123VuPhuc/myblog.git/bai-6.html"><meta property="og:type" content="article"><link rel="stylesheet" href="https://github.com/123VuPhuc/myblog.git/assets/css/style.css?v=94220f119044674b7663d7c550454968"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/123VuPhuc/myblog.git/bai-6.html"},"headline":"Bài 6:Lập trình giao thức UDP","datePublished":"2024-12-29T11:11+07:00","dateModified":"2024-12-29T20:55+07:00","image":{"@type":"ImageObject","url":"https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920},"description":"6.1/ Khái niệm chung UDP là viết tắt của cụm từ User Datagram Protocol. UDP là một phần của bộ giao thức Internet được sử dụng bởi các chương trình chạy trên các máy tính khác nhau trên mạng. Không giống như TCP, UDP được&hellip;","author":{"@type":"Person","name":"Vũ Trần Hoàng Phúc","url":"https://github.com/123VuPhuc/myblog.git/authors/vu-tran-hoang-phuc/"},"publisher":{"@type":"Organization","name":"Vũ Trần Hoàng Phúc","logo":{"@type":"ImageObject","url":"https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg","height":1080,"width":1920}}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="page-template"><a href="/about-me"><label style="color: #007BFF; cursor: pointer;">Click here to read my About Me page</label></a><header class="top js-header"><a class="logo" href="https://github.com/123VuPhuc/myblog.git/"><img src="https://github.com/123VuPhuc/myblog.git/media/website/champions-league-real-madrid-4k-8nnsf8xwhj6fu6u6.jpg" alt="Blog của tôi" width="1920" height="1080"></a></header><main class="page"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Bài 6:Lập trình giao thức UDP</h1></div></header></div><div class="entry-wrapper content__entry"><p>6.1/ Khái niệm chung</p><p>         UDP là viết tắt của cụm từ User Datagram Protocol. UDP là một phần của bộ giao thức Internet được sử dụng bởi các chương trình chạy trên các máy tính khác nhau trên mạng. Không giống như TCP, UDP được sử dụng để gửi các gói tin ngắn gọi là datagram, cho phép truyền nhanh hơn. Tuy nhiên, UDP không cung cấp kiểm tra lỗi nên không đảm bảo toàn vẹn dữ liệu.</p><p>          Giao thức UDP hoạt động tương tự như TCP nhưng nó không tạo ra một kết nối giữa các máy tính và không cung cấp kiểm tra lỗi khi truyền gói tin. Khi một ứng dụng sử dụng UDP, các gói tin chỉ được gửi đến người nhận. Người gửi không đợi để đảm bảo người nhận có nhận được gói tin hay không, mà tiếp tục gửi các gói tiếp theo. Nếu người nhận bỏ lỡ một vài gói tin UDP, gói tin đó bị mất vì người gửi sẽ không gửi lại chúng. Điều này có nghĩa là các thiết bị có thể giao tiếp nhanh hơn.</p><p>         UDP được sử dụng khi tốc độ được ưu tiên và sửa lỗi là không cần thiết. UDP thường được sử dụng cho phát sóng trực tuyến và trò chơi trực tuyến. Ví dụ như khi xem một luồng video trực tiếp, thường được phát bằng UDP thay vì TCP. Máy chủ chỉ gửi một luồng UDP liên tục tới các máy tính đang xem. Nếu bị mất kết nối trong vài giây, video có thể bị ngưng hoặc lag trong chốc lát và sau đó phát tiếp phần hiện tại. Nếu bị mất gói tin nhỏ, video hoặc âm thanh có thể bị méo mó một chút khi video tiếp tục phát mà không có dữ liệu bị mất.</p><p>         Điều này hoạt động tương tự trong các trò chơi trực tuyến. Nếu chúng ta bỏ lỡ một số gói UDP, các nhân vật của người chơi có thể xuất hiện trên bản đồ ở vị trí khác khi nhận được các gói UDP mới hơn.</p><p>          Sự khác nhau giữa TCP và UDP thường được minh họa bằng sự khác nhau giữa hệ thống điện thoại và hệ thống bưu chính. TCP giống với hệ thống điện thoại. Khi chúng ta gọi một số điện thoại nào đó, người đó cần đồng ý kết nối bằng cách nhấc điện thoại (trả lời cuộc gọi). Nếu điện thoại bận hoặc không có ai nhấc máy, chúng ta không liên lạc được. UDP thì giống như hệ thống bưu chính. Bạn gửi thư tay tới một địa chỉ cố định thông qua hệ thống bưu chính. Thư có thể tới nơi hoặc không tới nơi nhưng bạn không thể biết chắc được điều này. Bạn có thể gửi nhiều thư đi cho người nhận, đánh số chúng và yêu cầu họ gửi thư lại xác nhận xem thư nào tới, thư nào chưa tới. Bạn và người nhận phải thực hiện điều này chứ hệ thống bưu chính không thực hiện cho bạn.</p><p>            Cả hệ thống điện thoại và hệ thống bưu chính hiện vẫn đang hoạt động song song cho những mục đích khác nhau. Cũng giống như vậy, TCP và UDP đều có mục đích sử dụng riêng. Chúng ta không thể nói rằng cái nào tốt hơn cái nào. Thay vào đó, với từng ứng dụng cụ thể hay nói chính xác hơn là với từng yêu cầu cụ thể chúng ta sử dụng TCP hay UDP.</p><p>         Trong Java, cả UDP Server và UDP Client đều sử dụng các đối tượng của lớp <em>java.net.DatagramSocket </em>để giao tiếp và <em>java.net.DatagramPacket </em>là lớp được sử dụng để đóng gói dữ liệu để gửi đi và nhận dữ liệu dưới dạng packet. Số lượng byte lớn nhất có thể gửi thông qua UDP là <em>65507 </em>byte cho một lần. Mặc dù vậy, trên các ứng dụng thực chúng ta ít khi sử dụng hết độ dài này mà thường trong khoảng 8.192 bytes (8K). Và khi tiến hành gửi/nhận dữ liệu chúng ta cũng dùng kích thước bé hơn nhiều.</p><figure class="post__image"><img loading="lazy" src="https://github.com/123VuPhuc/myblog.git/media/posts/11/Picture15.jpg" alt="" width="301" height="302" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture15-xs.jpg 640w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture15-sm.jpg 768w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture15-md.jpg 1024w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture15-lg.jpg 1366w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture15-xl.jpg 1600w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture15-2xl.jpg 1920w"></figure><p class="align-center"><em>Hình 6.1: Cấu tạo của DatagramPacket</em></p><p>             Để gửi dữ liệu, chúng ta cần chuyển nó về kiểu <em>byte[]</em>, đưa dữ liệu vào <em>DatagramPacket </em>và gửi nó qua một <em>DatagramSocket</em>. Để nhận dữ liệu, ta nhận một <em>DatagramPacket </em>thông qua một <em>DatagramSocket </em>và tách lấy dữ liệu từ packet. Dữ liệu nhận được là kiểu <em>byte[]</em>, do đó chúng ta cần chuyển nó về kiểu dữ liệu thích hợp để lấy được thông tin cần thiết. <em>DatagramPacket </em>cũng có các phương thức giúp đọc thông tin liên quan tới máy gửi như địa chỉ mạng, cổng,…</p><p>        Việc sử dụng hai lớp <em>DatagramPacket </em>và <em>DatagramSocket </em>tương phản với TCP sử dụng lớp <em>Socket </em>và <em>ServerSocket</em>. Khác biệt thứ nhất giữa TCP và UDP là UDP không thực hiện một kết nối giữa hai máy tính khi gửi/nhận dữ liệu. Một socket có thể gửi và nhận dữ liệu từ nhiều máy tính khác nhau chứ không phụ thuộc vào một kết nối như TCP. Thứ hai, TCP socket sử dụng một kết nối để điều khiển các luồng dữ liệu. Với TCP, chúng ta gửi/nhận thông qua các dòng vào/dòng ra của socket. UDP thì không như vậy, chúng ta làm việc với các datagram packet riêng lẻ. Các packet không liên quan với nhau và khi nhận chúng ta không thể biết packet nào được gửi trước, packet nào được gửi sau.</p><p>       6.2/ Lớp DatagramSocket</p><p>         Không giống như TCP, đối với UDP thì cả bên nhận và bên gửi sẽ cùng sử dụng lớp <em>DatagramSocket </em>để giao tiếp với nhau. Một số phương thức chính:</p><p><em>public <strong>DatagramSocket</strong>() throws SocketException</em></p><p>         Hàm khởi tạo UDP socket cho Client. Khởi tạo UDP socket và chưa chỉ định cổng cụ thể, dùng các cổng còn trống của hệ thống.</p><p><em>public <strong>DatagramSocket</strong>(int port) throws SocketException</em></p><p>         Hàm khởi tạo UDP socket cho Server. Khởi tạo UDP socket và ràng buộc nó vào một <em>port </em>cụ thể được chỉ ra.</p><p><em>public synchronized void <strong>setSoTimeout</strong>(int timeout) throws SocketException</em></p><p>         Phương thức thiết lập thời gian chờ cho <em>DatagramSocket</em>. Hết thời gian chờ này không có phản hồi từ phía máy gửi, socket sẽ tự hủy.</p><p><em>public void <strong>send</strong>(DatagramPacket p) throws IOException</em></p><p>         Gửi <em>DatagramPacket </em>đến host nhận. <em>DatagramPacket </em>chứa dữ liệu cần gửi, độ dài dữ liệu, địa chỉ IP và số hiệu port của host sẽ nhận.</p><p><em>public void <strong>receive</strong>(DatagramPacket p) throws IOException</em></p><p>          Thực hiện nhận về packet từ <em>DatagramSocket</em>. Khi phương thức này được gọi thành công, <em>buf </em>của <em>DatagramPacket </em>sẽ chứa nội dung dữ liệu nhận được. Đồng thời <em>DatagramPacket </em>còn chứa thông tin về địa chỉ IP và port của bên gửi. Phương thức này khi gọi sẽ bị block cho đến khi có 1 <em>DatagramPacket </em>được nhận.</p><p><em>void <strong>bind</strong>(SocketAddress addr) throws SocketException</em></p><p>           Ràng buộc <em>DatagramSocket </em>vào một địa chỉ mạng cụ thể (IP và port). Phương thức này thường được dùng khi tạo <em>DatagramSocket </em>bằng phương thức thứ nhất, tức là không chỉ định rõ cổng cụ thể hoặc là muốn thay đổi địa chỉ mạng cho UDP socket.</p><p><em>public void <strong>close</strong>()</em></p><p>Đóng <em>DatagramSocket</em>.</p><p>      6.3/ Lớp DatagramPacket</p><p>          Lớp <em>DatagramPacket </em>trong Java dùng để đóng gói dữ liệu để gửi đi, đồng thời cũng dùng để nhận dữ liệu từ <em>DatagramSocket</em>. Một số phương thức chính:</p><p><em>public <strong>DatagramPacket</strong>(byte buf[], int length)</em></p><p>           Khởi tạo một <em>DatagramPacket </em>dùng để nhận 1 packet có độ dài là <em>length </em>nhỏ hơn hoặc bằng <em>buf.length</em>; <em>buf[] </em>là vùng nhớ đệm dùng để lưu dữ liệu sắp nhận; <em>length </em>là số lượng byte lớn nhất được dùng để nhận dữ liệu.</p><p><em>public <strong>DatagramPacket</strong>(byte buf[], int length, InetAddress address, int port)</em></p><p>           Khởi tạo một <em>DatagramPacket </em>để gửi 1 packet có độ dài là <em>length </em>đến cổng có số hiệu <em>port </em>trên host cụ thể được chỉ ra trong <em>address</em>; <em>buf[] </em>chính là dữ liệu muốn gửi.</p><p><em>public InetAddress <strong>getAddress</strong>()</em></p><p>          Trả về địa chỉ IP của host đã gởi packet hoặc host sẽ nhận packet.</p><p><em>public int <strong>getPort</strong>()</em></p><p>          Trả về giá trị port của host đã gởi packet hoặc host mà packet sẽ được gởi đến.</p><p><em>public byte[] <strong>getData</strong>()</em></p><p>           Trả về nội dung dữ liệu trong <em>DatagramPacket public int <strong>getLength</strong>()</em></p><p>           Trả về độ dài của dữ liệu trong <em>DatagramPacket. public synchronized int <strong>getOffset</strong>()</em></p><p>           Trả về <em>offset </em>(độ lệch) của dữ liệu trong <em>DatagramPacket</em>.</p><p>     6.4/ Lập trình UDP theo mô hình Client/Server</p><p>             Trong mô hình lập trình UDP Client/Server đều sử dụng hai lớp <em>DatagramSocket</em><em> </em>và <em>DatagramPacket</em><em> </em>cho cả phía Client và Server. Tuy nhiên cách sử dụng hai lớp này ở phía Client và Server là khác nhau trong các constructor.</p><p>        Quan sát mô hình trên <em>Hinh 6.2</em>, ta thấy rằng để tạo một giao tiếp bằng UDP, phía máy chủ sẽ tạo ra một socket và ràng buộc trên một cổng nhất định nào đó.</p><p>         Muốn gửi dữ liệu (hoặc yêu cầu) thì phải biết trước các thông tin liên quan như địa chỉ mạng, cổng kết nối của máy nhận. Máy gửi sẽ tạo ra một socket dùng cho việc gửi dữ liệu. Máy gửi tạo ra một <em>DatagramPacket </em>với các thông tin như dữ liệu,chiều dài dữ liệu, địa chỉ mạng, cổng kết nối của máy nhận. Chúng ta sẽ gọi tới socket đã tạo và gửi packet đi.</p><figure class="post__image"><img loading="lazy" src="https://github.com/123VuPhuc/myblog.git/media/posts/11/Picture16.jpg" alt="" width="601" height="381" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture16-xs.jpg 640w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture16-sm.jpg 768w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture16-md.jpg 1024w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture16-lg.jpg 1366w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture16-xl.jpg 1600w, https://github.com/123VuPhuc/myblog.git/media/posts/11/responsive/Picture16-2xl.jpg 1920w"></figure><p class="align-center"><em>Hình 6.2: Mô hình Client/Server theo kỹ thuật lập trình với giao thức UDP</em></p><p>Đoạn chương trình để gửi dữ liệu bằng giao thức UDP:</p><p class="align-center"> </p><p>          Phía máy nhận muốn nhận dữ liệu thì sẽ tạo ra một socket để gửi/nhận dữ liệu. Nếu đã có socket rồi thì có thể sử dụng lại. Sau đó, máy nhận tạo ra một packet với thông tin về biến nhớ đệm và độ dài dữ liệu. Sau đó, chúng ta sẽ dùng socket để nhận dữ liệu.</p><p>     Đoạn chương trình để gửi dữ liệu bằng giao thức UDP:</p><p>Lớp này cho phép tạo gói tin truyền thông với giao thức UDP. Lớp này kết thừa trực tiếp từ lớp</p><p>Object.</p><p><em>public final class DatagramPacket extends Object</em></p><p>Gói tin là đối tượng của lớp này chứa 4 thành phần quan trọng: Địa chỉ, dữ liệu truyền thật sự,</p><p>kích thước của gói tin và số hiệu cổng chứa trong gói tin.</p><ul><li><em></em><em>Cấu tử</em></li></ul><p>Lớp này có các cấu tử tạo gói tin gửi và gói tin nhận khác nhau:</p><p>* Cấu tử tạo gói tin nhận từ mạng:</p><p><em>public DatagramPacket(byte[] inBuffer, int length)</em></p><p>           Trong đoạn mã trên, <em>65507 </em>được dùng làm kích thước của dữ liệu nhận. Đây là kích thước lớn nhất có thể dùng. Tuy nhiên, trên thực tế khi dùng ta có thể sử dụng số bé hơn.</p><p>        Để đọc thông tin của packet nhận được, ta có đoạn mã sau:</p><p>Tham số:</p><ul><li>inBuffer: Bộ đệm nhập, chứa dữ liệu của gói tin nhận</li><li>length: kích cỡ của dữ liệu của gói tin nhận, nó thường được xác định bằng lệnh: <em>length= length</em>.</li></ul><p>Ví dụ tạo gói tin nhận:</p><p><em>byte[] inBuff=new byte[512];//bộ đệm nhập</em></p><p><em>DatagramPacket</em><em> </em><em>inData=new</em><em> </em><em>DatagramPacket(inBuf,</em><em> </em><em>inBuff.length);</em></p><p>* Cấu tử tạo gói tinh gửi:</p><p><em>public DatagramPacket(byte[] outBuffer , int length,</em></p><p><em>InetAddress destination, int port)</em></p><p>          Thông tin đọc được từ phía máy gửi có thể dùng để gửi lại phản hồi sau này. Nói một cách chính xác thì thông tin địa chỉ mạng và cổng sẽ dùng để đóng gói thông tin qua một <em>DatagramPacket </em>dùng để gửi phản hồi cho máy vừa gửi thông tin. Điều này cũng giống như việc gửi thư, khi nhận được thư ta thường đọc thông tin của người gửi (nếu không biết trước) trên phong bì thư để gửi lại thư phản hồi.</p><p>      6.5/ Một số ví dụ</p><p><strong><em>          Ví dụ 6-1</em></strong><em>. Viết chương trình UDP kiểm tra một xâu có phải là xâu đối xứng hay không. Client sẽ gửi lên Server một xâu. Server sẽ gửi trả kết quả kiểm tra tính đối xứng của xâu.</em></p><p><em>          Bước 1</em>: Lập trình phía Server.</p><ul><li>Tạo một project đặt tên là <em>UDP_Server</em>.</li><li>Trong project này tạo một class và đặt tên là <em>Server</em>.</li><li>Viết mã lệnh cho <em>Server </em>như sau:</li></ul><p class="align-center"> </p><p>Tham số:</p><ul><li>outBuffer: Bộ đệm xuất chưa dữ liệu của gói tin gửi</li><li>length: kích cỡ dữ liệu của gói tin gửi tính theo số byte và thường bằng length.</li></ul><p class="align-center"> </p><ul><li>destination: Địa chỉ nơi nhận gói tin</li><li>port: Số hiệu cổng đích, nơi nhận gói</li></ul><p><em>      Bước 2</em>: Lập trình phía <em>Client</em></p><ul><li>Tạo một project khác đặt tên là <em>UDP_Client</em>.</li><li>Trong project này tạo một JFrame Form đặt tên là <em>Client</em>.</li><li>Thiết kế giao diện như hình dưới:</li></ul><p>Tham số:</p><ul><li>outBuffer: Bộ đệm xuất chưa dữ liệu của gói tin gửi</li><li>length: kích cỡ dữ liệu của gói tin gửi tính theo số byte và thường bằng length.</li></ul><p class="align-center"> </p><ul><li>destination: Địa chỉ nơi nhận gói tin</li><li>port: Số hiệu cổng đích, nơi nhận gói</li></ul><p class="align-center"><em>Hình 6.3: Thiết kế giao diện xử lý xâu bằng UDP</em></p><ul><li>Xử lý sự kiện khi người dùng nhấn vào nút <em>Kiểm tra</em>:</li></ul><p>Ví dụ:</p><p><em>String s=” Hello World!”;</em></p><p><em>//Bộ đệm xuất và gán dữ liệu cho bộ đệm xuất</em></p><p><em>byte[] outBuff=s.getBytes();</em></p><p><em>//Địa chỉ đích</em></p><p><em>InetAddress addrDest=InetAddress.getByName(“localhost”);</em></p><p><em>//Số cổng đích</em></p><p><em>int</em><em>   portDest=3456;</em></p><p><em>//Tạo gói tin gửi</em></p><p><em>DatagramPacket outData=new DatagramPacket(outBuff,</em></p><p><em>outBuff.length, addrDest, portDest);</em></p><p class="align-center"> </p><p><em>          Bước 3</em>: Chạy chương trình</p><ul><li>Chạy <em>Server </em>trước.</li><li>Chạy <em>Client </em>sau, nhập dữ liệu và nhấn nút <em>Kiểm tra</em>.</li><li>Kết quả như hình dưới.</li></ul><ul><li><em>public InetAddress getAddress( ): </em>Phương thức này trả về đối tượng InetAddress của máy</li></ul><p>trạm từ xa chứa trong gói tin nhận.</p><ul><li><em>public int getPort( ): </em>Trả về số hiệu cổng của máy trạm từ xa chứa trong gói</li><li><em>public byte[] getData( )</em>: Trả về dữ liệu chứa trong gói tin dưới dạng mảng</li><li><em>public int getLength( ): </em>Trả về kích cỡ của dữ liệu chưa trong gói tin tính theo số</li></ul><p>Tương ứng với 4 phương thức getXXXX..(), lớp DatagramPacket có 4 phương thức setXXXX..() để thiết lập 4 tham số cho gói tin gửi.</p><p class="align-center"><em>Hình 6.4: Kết quả xử lý xâu bằng máy chủ UDP</em></p><p>          Trên đây là một ví dụ đơn giản về kỹ thuật lập trình với giao thức UDP để xử lý xâu. So với các ví dụ về TCP, rõ ràng chúng ta chương trình không tạo một kết nối giữa Server và Client. Việc giao tiếp giữa chúng được thực hiện thông qua các <em>DatagramSocket</em>. Dữ liệu được gửi/nhận bằng cách tạo ra các <em>DatagramPacket </em>với các phương thức tạo dùng để gửi và để nhận. Các <em>DatagramPacket </em>này được gửi/nhận thông qua các <em>DatagramSocket</em>.</p><p>          Chúng ta có thể làm lại các ví dụ ở chương trước (TCP) với kỹ thuật trao đổi dữ liệu Client/Server theo ví dụ trên.</p><p> </p></div><footer class="content__footer"><div class="entry-wrapper"><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://github.com/123VuPhuc/myblog.git/authors/vu-tran-hoang-phuc/" rel="author">Vũ Trần Hoàng Phúc</a></h3></div></div></div></footer></article></main><footer class="footer"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button onclick="backToTopFunction()" id="backToTop" class="footer__bttop" aria-label="Back to top" title="Back to top"><svg width="20" height="20"><use xlink:href="https://github.com/123VuPhuc/myblog.git/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://github.com/123VuPhuc/myblog.git/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>