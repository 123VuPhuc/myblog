<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>Blog của tôi</title>
    <link href="https://github.com/123VuPhuc/myblog.git/feed.xml" rel="self" />
    <link href="https://github.com/123VuPhuc/myblog.git" />
    <updated>2024-12-29T12:29:21+07:00</updated>
    <author>
        <name>Vũ Trần Hoàng Phúc</name>
    </author>
    <id>https://github.com/123VuPhuc/myblog.git</id>

    <entry>
        <title>Bài 9:Lập trình ứng dụng truyền thông qua mạng điện thoại công cộng( PTSN)</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/bai-9.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/bai-9.html</id>

        <updated>2024-12-29T11:11:52+07:00</updated>
            <summary>
                <![CDATA[
                    KỸ THUẬT LẬP TRÌNH VỚI JTAPI 1. Giới thiệu thư viện JTAPI JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <ol>
<li><strong>KỸ THUẬT LẬP TRÌNH VỚI JTAPI</strong>
<h5>1.  Giới thiệu thư viện JTAPI</h5>
</li>
</ol>
<p>JTAPI là một giao diện lập trình ứng dụng hướng đối tượng cho những ứng dụng máy tính-điện thoại trên nền Java. Tương tự như những giao diện lập trình ứng dụng cho các nền tảng khác như TAPI (Telephony API) trên Microsoft Windows và TSAPI trên Novell Netware. Cấu trúc của thư viện JTAPI được thể hiện như hình sau: Nó gồm bộ cốt lõi và các gói mở rộng chuẩn.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/Picture5.png" alt="" width="755" height="779" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-2xl.png 1920w"></figure>
<p class="align-center">Hình 6.1. Cấu trúc thư viện JTAPI</p>
<p>Tại trung tâm của JTAPI là gói "cốt lõi ". Gói cốt lõi cung cấp khung cơ bản cho mô hình gọi điện thoại và những đặc trưng điện thoại sơ khai ban đầu . Những đặc tính này bao gồm định vị một cuộc gọi, trả lời một gọi, và huỷ một cuộc gọi. Những ứng dụng kỹ thuật điện thoại đơn giản sẽ chỉ cần sử dụng lõi để thực hiện các tác vụ của chúng mà không cần quan tâm tới những chi tiết của những gói khác. Chẳng hạn, gói lõi cho phép người sử dụng dễ dàng thiết kế để thêm đặc tính điện thoại vào một trang Web.</p>
<p>Phân tầng xung quanh gói lõi JTAPI là một số gói "mở rộng chuẩn ". Những gói mở rộng này bổ sung thêm các chức năng điện thoại cho API. Các gói mở rộng chuẩn trong API bao gồm các gói sau:<em>callcontrol, callcenter, media, phone, privatepackages </em>và gói <em>capabilities.</em></p>
<ul>
<li><em>Gói điều khiển gọi – call </em></li>
</ul>
<p>Gói <em>javax.telephony.callcontrol</em>: Mở rộng lõi bằng việc cung cấp các cuộc gọi mức cao hơn bao gồm các đặc tính điều khiển điện thoại như giữ cuộc gọi, chuyển cuộc gọi... Gói này cũng cung cấp một mô hình trạng thái chi tiết hơn của những cuộc gọi. Các lớp tiêu biểu của gói gồm các giao diện sau:</p>
<ul>
<li><u>CallControlAddress</u></li>
<li><u>CallControlAddressObserver</u></li>
<li><u>CallControlCall</u></li>
<li><u>CallControlCallObserver</u></li>
<li><u>CallControlConnection</u></li>
<li><u>CallControlTerminal</u></li>
<li><u>CallControlTerminalConnection</u></li>
<li><u>CallControlTerminalObserver</u></li>
</ul>
<p><em>      Gói callcenter</em></p>
<p>Gói <em>javax.telephony.callcenter </em>cung cấp khả năng thực hiện quản lý các trung tâm cuộc gọi lớn ở mức độ cao. Ví dụ như: định tuyến, phân bố cuộc gọi tự động ACD, dự báo cuộc gọi và liên kết dữ liệu ứng dụng với đối tượng điện thoại. Gói này gồm các lớp sau:</p>
<ul>
<li><u>ACDAddress</u></li>
<li><u>ACDAddressObserver</u></li>
<li><u>ACDConnection</u></li>
<li><u>ACDManagerAddress</u></li>
<li><u>ACDManagerConnection</u></li>
<li><u>AgentTerminal</u></li>
<li><u>AgentTerminalObserver</u></li>
<li><u>CallCenterAddress</u></li>
<li><u>CallCenterCall</u></li>
<li><u>CallCenterCallObserver</u></li>
<li><u>CallCenterProvider</u></li>
<li><u>RouteAddress</u></li>
<li><u>RouteCallback</u></li>
<li><u>RouteSession</u></li>
</ul>
<p><em>     Gói Media</em></p>
<p>Gói <em>javax.telephony.media </em>cho phép truy nhập tới các luồng(stream) phương tiện truyền thông liên quan đến cuộc gọi. Chúng cho phép đọc và viết dữ liệu từ những luồng phương tiện truyền thông này. Gói này gồm các lớp:</p>
<ul>
<li><u>MediaCallObserver</u></li>
<li><u>MediaTerminalConnection</u></li>
</ul>
<p><em>        Gói Phone:</em></p>
<p>Gói <em>javax.telephony.phone </em>cho phép các ứng dụng  điều khiển các đặc tính vật lý của phần cứng điện thoại.</p>
<p>Gói Phone gồm các lớp:</p>
<ul>
<li><u>Component</u></li>
<li><u>ComponentGroup</u></li>
<li><u>PhoneButton</u></li>
<li><u>PhoneDisplay</u></li>
<li><u>PhoneGraphicDisplay</u></li>
<li><u>PhoneHookswitch</u></li>
<li><u>PhoneLamp</u></li>
<li><u>PhoneMicrophone</u></li>
<li><u>PhoneRinger</u></li>
<li><u>PhoneSpeaker</u></li>
<li><u>PhoneTerminal</u></li>
<li><u>PhoneTerminalObserver</u></li>
</ul>
<p><em>         Gói capabilities :</em></p>
<p>Gói <em>javax. telephony.capabilities </em>là gói cung cấp cho các ứng dụng khả năng truy vấn tới hoạt động xác định một khi nó được thực hiện. Và nó gồm các lớp sau :</p>
<ul>
<li><u>AddressCapabilities</u></li>
<li><u>CallCapabilities</u></li>
<li><u>ConnectionCapabilities</u></li>
<li><u>ProviderCapabilities</u></li>
<li><u>TerminalCapabilities</u></li>
<li><u>TerminalConnectionCapabilities</u></li>
</ul>
<p><em>Gói Private Data</em></p>
<p>Gói <em>javax.telephony.privatedata </em>cho phép các ứng dụng truyền trực tiếp dữ liệu trên các chuyển mạch cứng. Dữ liệu này được sử dụng để chỉ dẫn chuyển mạch thực hiện một thao tác chuyển mạch cụ.</p>
<h5>2.  Cơ sở của JTAPI.</h5>
<p>Mục đích của thư viện JTAPI được xây dựng để tạo ra một giao diện cho phép trình ứng dụng Java giao tiếp với hệ thống điện thoại<em>. </em>Điểm giao tiếp này xác định mức độ điều khiển mà một ứng dụng phải có. JTAPI hỗ trợ cả 2 kiểu ứng dụng: first-party và third-party.Trong ứng dụng first- party, giao diện được định vị tại thiết bị đầu cuối. Ứng dụng có cùng mức độ điều khiển như cuộc gọi điện thoại bình thường của người dùng. Trong kịch bản điều khiển third –party, giao diện được xác định bên trong hệ thống điện thoại và phụ thuộc vào hệ thống điện thoại. Sự truy cập bên trong này thường cung cấp cho ứng dụng nhiều khả năng điều khiển hơn kịch bản first- party.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/Picture5-2.png" alt="" width="365" height="178" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-2-2xl.png 1920w"></figure>
<p class="align-center">Hình 6.2. Điều khiển cuộc gọi</p>
<p>JTAPI trong thực tế, thực chất là một tập API. Bộ cốt lõi của API cung cấp mô hình cuộc gọi cơ bản và những đặc trưng điện thoại cơ sở nhất như: định vị cuộc gọi và trả lời các cuộc gọi telephone.</p>
<p>Các đặc trưng của điện thoại Java là:</p>
<ul>
<li>Làm đơn giản hầu hết các ứng dụng điện thoại cơ bản</li>
<li>Cung cấp một khung làm việc mà trải khắp các ứng dụng desktop đối với các ứng dụng điện thoại trung tâm gọi phân tán.</li>
<li>Giao tiếp các ứng dụng trực tiếp với các nơi cung cấp dịch vụ hoặc thực hiện giao tiếp với các API điện thoại tồn tại sẵn như SunXTL, TSAPI, and TAPI.</li>
<li>Dựa trên bộ lõi đơn giản, gia tăng thêm các gói mở rộng chuẩn.</li>
<li>Chạy được trên một phạm vi rộng các cấu hình phần cứng một khi Java run-time được sử dụng.</li>
</ul>
<h5>3.  Các cấu hình cuộc gọi tiêu biểu</h5>
<p>Mục này trình bày những ví dụ cấu hình cuộc gọi được lựa chọn để giải thích mô hình gọi. Nó được bắt đầu với một cuộc gọi 2 phía cơ bản, sau đó mở rộng ví dụ với cuộc gọi, người sử dụng và các thiết bị đầu cuối khác.</p>
<p>Một ví dụ cuộc gọi với hai người tham gia được biểu diễn trong hình 6.3. Những người chưa có kinh nghiệm có thể rất ngạc nhiên trong trường hợp đơn giản này: hai đối tượng kết nối (<em>Connection object</em>) gắn vào đối tượng cuộc gọi (<em>Call object</em>), mỗi đối tượng kết nối cho mỗi người tham gia. Cấu hình này cho phép mở rộng để thực hiện cho cuộc gọi hội thảo với ba hoặc nhiều người tham gia hơn. Cần chú ý rằng mô hình này hoàn toàn cân đối (Nó không phân biệt giữa thực thể cục bộ và thực thể ở xa) bởi vì nó cung cấp cách nhìn third-party</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/Picture11.jpg" alt="" width="463" height="201" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-2xl.jpg 1920w"></figure>
<p class="align-center">Hình 6.3.. Mô hình two- party call</p>
<h5 style="text-indent: 0cm; margin: 3.0pt 0cm .0001pt 35.95pt;"><span lang="vi">Hai<span style="letter-spacing: -.15pt;"> </span>cuộc<span style="letter-spacing: -.15pt;"> </span>gọi<span style="letter-spacing: -.25pt;"> </span>đồng<span style="letter-spacing: -.35pt;"> </span><span style="letter-spacing: -.1pt;">thời:</span></span></h5>
<p>Một ví dụ về một người sử dụng mà có hai cuộc gọi đồng loạt trên cùng thiết bị đầu cuối được đưa vào hình 6.4. Mọi đối tượng liên quan cuộc gọi đã gấp đôi số của họ. Đối tượng địa chỉ (<em>Address object</em>) và đối tượng thiết bị đầu cuối (<em>Terminal object</em>) của người sử dụng có hai cuộc gọi chỉ sinh ra một lần nhưng được gán cho hai đối tượng kết nối (<em>Connection object</em>) và hai đối tượng kết nối đầu cuối (<em>TerminalConnection</em>).</p>
<h5 style="text-align: justify; text-indent: 0cm; margin: 3.0pt 0cm .0001pt 35.95pt;"><span lang="vi">Cài<span style="letter-spacing: -.1pt;"> </span>đặt<span style="letter-spacing: -.25pt;"> </span>cuộc<span style="letter-spacing: 2.8pt;"> </span>gọi<span style="letter-spacing: -.1pt;"> </span>với<span style="letter-spacing: -.2pt;"> </span>hai<span style="letter-spacing: -.3pt;"> </span>thiết bị<span style="letter-spacing: -.3pt;"> </span>đầu<span style="letter-spacing: -.25pt;"> </span><span style="letter-spacing: -.2pt;">cuối:</span></span></h5>
<p>Một ví dụ cuộc gọi hai người với thiết bị đầu cuối có chuông báo được trình bày trong hình 6.5. Trong ví dụ trên, Bob thực hiện nhiều luồng, có nghĩa rằng khi Bob được gọi thì vài thiết bị đầu cuối sẽ đổ chuônốngự thể hiện nhiều luồng được đại diện bởi hai đối tượng kết nối đầu cuối gắn cho kết nối đối tượng của Bob, mỗi đối tượng cho mỗi thiết bị đầu cuối. Khi một trong những thiết bị đầu cuối trả lời cuộc gọi thì thiết bị đầu cuối khác sẽ bị loại ra( trong giới hạn của mô hình cuộc gọi này, đối tượng kết nối đầu cuối được đặt vào trong một trạng thái cấm hoạt động)</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/Picture11-2.jpg" alt="" width="469" height="281" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-2-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-2-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-2-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-2-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-2-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-2-2xl.jpg 1920w"></figure>
<p class="align-center">Hình 6.5. Mô hình Two alerting terminal calls.</p>
<h5 style="text-align: center; text-indent: 0cm; margin: 3.0pt 362.35pt .0001pt 0cm;" align="center"><span lang="vi">Cuộc<span style="letter-spacing: -.15pt;"> </span>gọi 3<span style="letter-spacing: -.3pt;"> </span>thành<span style="letter-spacing: -.2pt;"> viên:</span></span></h5>
<p>Một ví dụ tiêu biểu cho cuộc gọi ba thành viên là cuộc gọi hội nghị với ba người tham gia được thể hiện như hình 6.6. Mô hình cuộc gọi là một sự mở rộng trực tiếp từ mô hình cuộc gọi cơ bản với hai người tham gia. Mô hình đơn giản thêm một thành viên thứ ba với các đối tượng kết nối, địa chỉ, kết nối đầu cuối và thiết bị đầu cuối cho người thứ ba tham gia.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/Picture11-3.jpg" alt="" width="476" height="289" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-3-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-3-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-3-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-3-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-3-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-3-2xl.jpg 1920w"></figure>
<p class="align-center">Hình 6.6. Mô hình Third-party call.</p>
<h6 class="align-left">4.Mô hình cuộc gọi Java</h6>
<h6>4.1 Nguyên tắc</h6>
<p>JTAPI là một mô hình trừu tượng hóa mức độ cao và độc lập về công nghệ. Nó mô tả cuộc gọi như là một tập hữu hạn trạng thái máy mà phải trải qua trạng thái chuyển tiếp đó khi cuộc gọi được thực hiện.</p>
<p>Mô hình cuộc gọi được xây dựng tổng quát, bao trùm nhiều kịch bản cuộc gọi khác nhau. Nó có thể được mô tả bằng ví dụ chẳng hạn :</p>
<ul>
<li>Cuộc gọi giữa hai đối tác.</li>
<li>Nhiều cuộc gọi đồng loạt xảy ra trên cùng thiết bị đầu cuối.</li>
<li>Một cuộc hội thảo nhiều đối tác.</li>
<li>Cài đặt cuộc gọi để thông báo nhiều thiết bị đầu cuối.</li>
</ul>
<p>Mô hình cuộc gọi mô tả việc gọi cũng như những thành phần tham gia cuộc gọi. Tất cả nó định nghĩa trong 5 lớp cơ sở. Hai lớp mô tả những thành phần tham gia cuộc gọi. Những đối tượng duy trì và độc lập của cuộc gọi:</p>
<ul>
<li>Một người sử dụng (<em>user</em>) được đại diện bởi một đối tượng địa chỉ (<em>Address</em>). Thuộc tính chính của đối tượng địa chỉ là định danh người sử dụng (<em style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">user identifier</em><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">).</span></li>
</ul>
<ul>
<li>Một điện thoại đầu cuối được đại diện cho bởi đối tượng đầu cuối (<em>Terminal</em>). Thuộc tính chính của đối tượng thiết bị đầu cuối là địa chỉ của thiết bị đó.</li>
</ul>
<p>Ba lớp khác mô tả một cuộc gọi. Những đối tượng thể hiện của các lớp này không duy trì mà được tạo ra động trong khi cuộc gọi xảy ra. Mỗi đối tượng bao gồm một trạng thái máy hữu hạn:</p>
<ul>
<li>Một đối tượng gọi (<em>Call</em>) được tạo ra cho mỗi cuộc gọi</li>
<li>Một đối tượng kết nối (<em>Connection</em>) được tạo ra cho mỗi người sử dụng tham gia vào cuộc gọi. Nó kết nối đối tượng địa chỉ của người sử dụng với đối tượng gọi.</li>
<li>Một đối tượng kết nối đầu cuối (<em>TerminalConnection</em>) được tạo ra cho mỗi thiết bị đầu cuối tham gia vào cuộc gọi. Nó kết nối đối tượng (<em>Terminal</em>) thiết bị đầu cuối với đối tượng kết nối (<em>Connection</em>).</li>
</ul>
<p>    4.2/ Các đối tượng trong mô hình gọi thoại Java</p>
<p>Các đối tượng trong mô hình gọi thoại Java được thể hiện như hình 6.7.</p>
<ul>
<li><strong>Đối tượng Provider</strong>: là một sự trừu tượng của phần mềm service-provider telephone. Provider có thể quản lý kết nối giữa PBX với server, một card telephony/fax trong máy desktop hoặc một công nghệ mạng máy tính như IP. Provider ẩn tất cả các chi tiết dịch vụ cụ thể của các hệ thống con telephone và cho phép ứng dụng Java hoặc Applet tương tác với các hệ thống con telephone trong cơ chế độc lập thiết bị.</li>
<li><strong>Đối tượng Call</strong>: Đối tượng này thể hiện một cuộc gọi điện thoại là luồng thông tin giữa người cung cấp dịch vụ và các thành viên của cuộc gọi. Một cuộc gọi điện thoại bao gồm một đối tượng Call và không hoặc nhiều kết nối. Trong kiểu gọi two-party gồm một đối tượng Call và 2 kết nối, còn trong kiểu hội thảo thì có 3 hoặc nhiều hơn số kết nối với một đối tượng Call.</li>
<li><strong>Đối tượng Address</strong>: Đối tượng này biểu diễn một số điện thoại. Nó là sự trừu tượng đối với một điểm cuối logic của một cuộc gọi điện thoại. Trong thực tế một số điện thoại có thể tương ứng với một số điểm cuối vật lý.</li>
<li><strong>Đối tượng Connection</strong>: Một đối tượng Connection mô hình hoá liên kết truyền thông giữa đối tượng Call và đối tượng Address. Đối tượng Connection có thể ở trong một trong các trạng thái khác nhau chỉ thị trạng thái quan hệ hiện thời giữa Call và Address.</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/Picture5-3.png" alt="" width="436" height="449" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-3-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-3-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-3-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-3-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-3-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-3-2xl.png 1920w"></figure>
<p class="align-center">Hình 6.7. Mô hình cuộc gọi thoại Java</p>
<ul>
<li><strong>Đối tượng Terminal</strong>: Biểu diễn một thiết bị vật lý như điện thoại và các thuộc tính gắn với nó. Mỗi đối tượng Terminal có một hoặc nhiều đối tượng Address( số điện thoại) gắn kết với nó. Terminal cũng được xem như là điểm cuối vật lý của một cuộc gọi vì nó tương ứng với một phần cứng vật lý.</li>
</ul>
<p><strong><em>4.4/Những trạng thái máy hữu hạn</em></strong></p>
<p>Mỗi đối tượng cuộc gọi được tạo ra mỗi khi thực hiện cuộc gọi. Trạng thái của đối tượng cuộc gọi phụ thuộc vào mã số của đối tượng kết nối và nó gồm các trạng thái thể hiện như hình 6.8.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/Picture11-4.jpg" alt="" width="88" height="208" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-4-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-4-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-4-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-4-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-4-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture11-4-2xl.jpg 1920w"></figure>
<p><em>Trạng thái nhàn rỗi(IDLE): </em>Đây là trạng thái khởi đầu cho mọi cuộc gọi. Trong trạng thái này, cuộc gọi không có kết nối nào.</p>
<p><em>Hoạt động(Active):</em>Đây trạng thái khi một cuộc gọi đang xẩy ra.Các cuộc gọi với một hoặc nhiều kết nối đều phải ở trong trạng thái này.</p>
<p><em>Vô hiệu hóa(Invalid):</em>Đây là trạng thái cuối cùng cho mọi cuộc gọi. Cuộc gọi mà mất tất cả các đối tượng kết nối (thông qua một sự chuyển tiếp của đối tượng kết nối vào trong kết nối - trạng thái ngưng kết nối) sẽ chuyển vào trong trạng thái này. Các cuộc gọi khi ở trong trạng thái này sẽ không có kết nối nào và những đối tượng cuộc gọi này có thể không được sử dụng cho bất kỳ hoạt động nào trong tương lai.</p>
<p>II.CẤU HÌNH HỆ THỐNG</p>
<p>JTAPI chạy trên nhiều cấu hình hệ thống khác nhau, bao gồm trung tâm phục vụ và máy tính mạng từ xa truy nhập tài nguyên điện thoại qua mạng. Trong cấu hình đầu tiên, một máy tính mạng đang chạy ứng dụng JTAPI và đang truy nhập những tài nguyên điện thoại qua một mạng được minh họa trong hình 6.12. Cấu hình thứ hai ứng dụng đang chạy trên một máy tính với những tài nguyên điện thoại riêng được minh họa trong hình 6.13.</p>
<h5><a name="_TOC_250006"></a>1.      Cấu hình máy tính mạng</h5>
<p>Trong cấu hình này, ứng dụng JTAPI hay Java applet chạy trên một trạm từ xa. Trạm làm việc này có thể là một máy tính nối mạng. Nó truy nhập tài nguyên mạng, sử dụng một trung tâm quản lý kỹ thuật điện thoại. JTAPI giao tiếp với bộ phận phục vụ này qua một cơ chế truyền thông từ xa, như RMI của Java, JOE hay một giao thức điện thoại nào đó. Cấu hình này đưwcj thể hiện như hình 6.10.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/Picture5-4.png" alt="" width="270" height="284" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-4-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-4-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-4-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-4-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-4-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-4-2xl.png 1920w"></figure>
<p class="align-center">Hình 6.12. Cấu hình máy tính mạng</p>
<h5>2. Cấu hình desktop</h5>
<p>Trong cấu hình máy để bàn, ứng dụng JTAPI hay Java applet chạy trên cùng trạm làm việc.Cấu hình desktop thể hiện như hình 6.13.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/Picture5-5.png" alt="" width="748" height="419" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-5-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-5-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-5-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-5-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-5-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/11/responsive/Picture5-5-2xl.png 1920w"></figure>
<p class="align-center">Hình 6.13: Cấu hình Máy để bàn</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 8:Lập trình mạng an toàn bảo mật với SSL</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/bai-8.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/bai-8.html</id>

        <updated>2024-12-29T11:11:45+07:00</updated>
            <summary>
                <![CDATA[
                    I/ Giới thiệu SSL và một số khái niệm 1/ Giới thiệu SSL SSL (Secure Socket Layer) là giao thức đa mục đích được thiết kế để tạo ra các giao tiếp giữa hai chương trình ứng dụng trên một cổng định trước (socket 443)&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>I/ Giới thiệu SSL và một số khái niệm</p>
<p>        1/ Giới thiệu SSL</p>
<p>SSL (Secure Socket Layer) là giao thức đa mục đích được thiết kế để tạo ra các giao tiếp giữa hai chương trình ứng dụng trên một cổng định trước (socket 443) nhằm mã hoá toàn bộ thông tin đi/đến, được sử dụng trong giao dịch điện tử như truyền số liệu thẻ tín dụng, mật khẩu, số bí mật cá nhân (PIN) trên Internet.</p>
<p>Trong các giao dịch điện tử trên mạng và trong các giao dịch thanh toán trực tuyến, thông tin/dữ liệu trên môi trường mạng Internet không an toàn thường được bảo đảm bởi cơ chế bảo mật thực hiện trên tầng vận tải có tên Lớp cổng bảo mật SSL (Secure Socket Layer) - một giải pháp kỹ thuật hiện nay được sử dụng khá phổ biến trong các hệ điều hành mạng máy tính trên Internet. Giao thức SSL được hình thành và phát triển đầu tiên nǎm 1994 bởi nhóm nghiên cứu Netscape dẫn dắt bởi Elgammal, và ngày nay đã trở thành chuẩn bảo mật thực hành trên mạng Internet. Phiên bản SSL hiện nay là 3.0 và vẫn đang tiếp tục được bổ sung và hoàn thiện. Tương tự như SSL, một giao thức khác có tên là Công nghệ truyền thông riêng tư PCT (Private Communication Technology) được đề xướng bởi Microsoft, hiện nay cũng được sử dụng rộng rãi trong các mạng máy tính chạy trên hệ điều hành Windows NT. Ngoài ra, một chuẩn của Nhóm đặc trách kỹ thuật Internet IETF (Internet Engineering Task Force) có tên là Bảo mật lớp giao vận TLS (Transport Layer Security) dựa trên SSL cũng được hình thành và xuất bản dưới khuôn khổ nghiên cứu của IETF Internet Draft được tích hợp và hỗ trợ trong sản phẩm của Netscape.</p>
<p> 2/ Khoá-Key</p>
<p>Định nghĩa Khoá</p>
<p style="margin-right: 44.05pt; text-align: justify; line-height: 130%;"><span lang="vi">Khóa (key) là một thông tin quan trọng dùng để mã hóa thông tin hoặc giải mã thông<span style="letter-spacing: -.3pt;"> </span>tin<span style="letter-spacing: -.3pt;"> </span>đã bị<span style="letter-spacing: -.1pt;"> </span>mã hóa. Có<span style="letter-spacing: -.1pt;"> </span>thể hiểu<span style="letter-spacing: -.05pt;"> </span>nôm<span style="letter-spacing: -.35pt;"> </span>na khóa giống<span style="letter-spacing: -.05pt;"> </span>như là mật<span style="letter-spacing: -.1pt;"> </span></span><span lang="vi">khẩu(password</span><strong><span lang="vi">).</span></strong></p>
<p><em>Độ dài khóa – Key Length</em></p>
<p>Độ dài khóa được tính theo bit: 128 bits, 1024 bits hay 2048 bits,... Khóa càng dài thì càng khó phá. Chằng hạn như khóa RSA 1024 bits đồng nghĩa với việc chọn 1 trong 2<sup>1024</sup> khả năng.</p>
<p><em>Password và PassParse</em></p>
<p>Password và passparse gần giống nhau. Password không bao giờ hết hạn(expire). Passparse chỉ có hiệu lực trong một khoảng thời gian nhất định có thể là 5 năm, 10 năm hay chỉ là vài ba ngày. Sau thời gian đó, phải thay đổi lại mật khẩu mới. Nói chung, mọi thứ trong SSL như passparse, khóa, giấy chứng nhận, chữ kí số (sẽ nói sau), ... đều chỉ có thời hạn sử dụng nhất định. Passparse được dùng để mở (mã hóa/giải mã) khóa riêng.</p>
<p>   3/ Thuật toán mã hoá</p>
<p>Mã hóa (encrypt) và giải mã (decrypt) thông tin dùng các hàm toán học đặt biệt. Được biết đến với cái tên là thuật toán mã hóa (cryptographic algorithm) và thường được gọi tắt là cipher. Các thuật toán mã hoá và xác thực của SSL được sử dụng bao gồm (phiên bản 3.0):</p>
<ul>
<li>DES - Chuẩn mã hoá dữ liệu (ra đời năm 1977), phát minh và sử dụng của chính phủ Mỹ.</li>
<li>DSA - Thuật toán chữ ký điện tử, chuẩn xác thực điện tử, phát</li>
</ul>
<p>minh và sử dụng của chính phủ Mỹ.</p>
<ul>
<li>KEA - Thuật toán trao đổi khoá, phát minh và sử dụng của chính</li>
</ul>
<p>phủ Mỹ.</p>
<ul>
<li>MD5 - Thuật toán tạo giá trị "bǎm" (message digest), phát minh</li>
</ul>
<p>bởi Rivest.</p>
<ul>
<li>RC2, RC4 - Mã hoá Rivest, phát triển bởi công ty RSA Data</li>
<li>RSA - Thuật toán khoá công khai, cho mã hoá và xác thực, phát</li>
</ul>
<p>triển bởi Rivest, Shamir và Adleman.</p>
<ul>
<li>RSA key exchange - Thuật toán trao đổi khoá cho SSL dựa trên thuật toán RSA.</li>
</ul>
<ul>
<li>SHA-1 - Thuật toán hàm băm an toàn, phát triển và sử dụng bởi</li>
</ul>
<p>chính phủ Mỹ.</p>
<ul>
<li>SKIPJACK - Thuật toán khoá đối xứng phân loại được thực hiện</li>
</ul>
<p>trong phần cứng Fortezza, sử dụng bởi chính phủ Mỹ;</p>
<ul>
<li>Triple-DES - Mã hoá DES ba lần.</li>
</ul>
<p><strong>Các phương pháp mã hóa</strong></p>
<p><strong> </strong></p>
<p>Có hai phương pháp mã hóa được sử dụng phổ biến hiện nay là mã hóa bằng khóa đối xứng và mã hóa dùng cặp khóa chung - khóa riêng..</p>
<p><em>Mã hóa bằng khóa đối xứng (symmetric-key)</em></p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/Picture1.png" alt="" width="460" height="333" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture1-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture1-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture1-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture1-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture1-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture1-2xl.png 1920w"></figure>
<p>         Khóa dùng để mã hóa cũng là khóa dùng để giải mã.Một khe hở trong mã hóa đối xứng là bạn phải chuyển khóa cho người nhận để họ có thể giải mã. Việc chuyển khóa không được mã hóa qua mạng là một điều cực kì mạo hiểm. Nhỡ như khóa này rơi vào tay người khác thế là họ có thể giải mã được thông tin mà đã chuyển đi. Phương pháp mã hóa bằng khóa chung - khóa riêng ra đời nhằm giải quyết vấn đề này.</p>
<p>          Thay vì chỉ có một khóa duy nhất dùng chung cho mã hóa và giải mã, sẽ có một cặp khóa gồm khóa chung chỉ dùng để mã hóa và khóa riêng chỉ dùng để giải mã.</p>
<p>      Khi người A muốn gửi thông điệp cho người B thì người B cần biết khóa chung của người A. (Khóa này được người A công bố công khai). Người B mã hóa các thông tin gởi đến người A bằng khóa chung của người A. Chỉ có người A mới có khóa riêng để giải mã các thông tin này. Nhỡ như thông tin này có rơi vào tay người khác thì họ cũng không thể giải mã được vì chỉ có người A mới có khóa riêng dành cho việc giải mã đúng thông điệp trên.</p>
<p><em>Mã</em><em> </em><em>hóa</em><em> </em><em>dùng</em><em> </em><em>c</em><em>p</em><em> </em><em>khóa</em><em> </em><em>chung</em><em> </em><em>–</em><em> </em><em>khóa</em><em> </em><em>riêng</em></p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/Picture11.jpg" alt="" width="564" height="261" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-2xl.jpg 1920w"></figure>
<p style="text-align: center; margin: 0cm 35.95pt .0001pt 28.15pt;" align="center"><span lang="vi">Hình<span style="letter-spacing: -.35pt;"> </span>7.2. Mã hoá<span style="letter-spacing: -.05pt;"> </span>công<span style="letter-spacing: -.35pt;"> </span><span style="letter-spacing: -.2pt;">khai</span></span></p>
<p class="align-left" align="center">4 Cơ chế làm việc của SSL - SSL Protocol</p>
<p>Điểm cơ bản của SSL là được thiết kế độc lập với tầng ứng dụng để đảm bảo tính bí mật, an toàn và chống giả mạo luồng thông tin qua Internet giữa hai ứng dụng bất kỳ, thí dụ như webserver và các trình duyệt (browser), do đó được sử dụng rộng rãi trong nhiều ứng dụng khác nhau trên môi trường Internet. Toàn bộ cơ chế hoạt động và hệ thống thuật toán mã hoá sử dụng trong SSL được phổ biến công khai, trừ khóa chia sẻ tạm thời được sinh ra tại thời điểm trao đổi giữa hai ứng dụng là tạo ngẫu nhiên và bí mật đối với người quan sát trên mạng máy tính. Ngoài ra, giao thức SSL còn đòi hỏi ứng dụng chủ phải được chứng thực bởi một đối tượng lớp thứ ba (CA) thông qua chứng chỉ điện tử (digital certificate) dựa trên mật mã công khai (thí dụ RSA).</p>
<p>Sau đây ta xem xét một cách khái quát cơ chế hoạt động của SSL để phân tích cấp độ an toàn của nó và các khả nǎng áp dụng trong các ứng dụng nhạy cảm, đặc biệt là các ứng dụng về thương mại và thanh toán điện tử.</p>
<p>Giao thức SSL dựa trên hai nhóm con giao thức là giao thức "bắt tay" (handshake protocol) và giao thức "bản ghi" (record protocol). Giao thức bắt tay xác định các tham số giao dịch giữa hai đối tượng có nhu cầu trao đổi thông tin hoặc dữ liệu, còn giao thức bản ghi xác định khuôn dạng cho tiến hành mã hoá và truyền tin hai chiều giữa hai đối tượng đó. Khi hai ứng dụng máy tính, thí dụ giữa một trình duyệt web và máy chủ web, làm việc với nhau, máy chủ và máy khách sẽ trao đổi "lời chào" (hello) dưới dạng các thông điệp cho nhau với xuất phát đầu tiên chủ động từ máy chủ, đồng thời xác định các chuẩn về thuật toán mã hoá và nén số liệu có thể được áp dụng giữa hai ứng dụng. Ngoài ra, các ứng dụng còn trao đổi "số nhận dạng/khoá theo phiên" (session ID, session key) duy nhất cho lần làm việc đó. Sau đó ứng dụng khách (trình duyệt) yêu cầu có chứng chỉ điện tử (digital certificate) xác thực của ứng dụng chủ (web server).</p>
<p>Chứng chỉ điện tử thường được xác nhận rộng rãi bởi một cơ quan trung gian (Thẩm quyền xác nhận CA - Certificate Authority) như RSA Data Sercurity hay VeriSign Inc., một dạng tổ chức độc lập, trung lập và có uy tín. Các tổ chức này cung cấp dịch vụ "xác nhận" số nhận dạng của một công ty và phát hành chứng chỉ duy nhất cho công ty đó như là bằng chứng nhận dạng (identity) cho các giao dịch trên mạng, ở đây là các máy chủ webserver.</p>
<p>Sau khi kiểm tra chứng chỉ điện tử của máy chủ (sử dụng thuật toán mật mã công khai, như RSA tại trình máy trạm), ứng dụng máy trạm sử dụng các thông tin trong chứng chỉ điện tử để mã hoá thông điệp gửi lại máy chủ mà chỉ có máy chủ đó có thể giải mã. Trên cơ sở đó, hai ứng dụng trao đổi khoá chính (master key) - khoá bí mật hay khoá đối xứng - để làm cơ sở cho việc mã hoá luồng thông tin/dữ liệu qua lại giữa hai ứng dụng chủ khách. Toàn bộ cấp độ bảo mật và an toàn của thông tin/dữ liệu phụ thuộc vào một số tham số:</p>
<ul>
<li>Số nhận dạng theo phiên làm việc ngẫu nhiên.</li>
<li>Cấp độ bảo mật của các thuật toán bảo mật áp dụng cho</li>
<li>Độ dài của khoá chính (key length) sử dụng cho lược đồ mã hoá thông</li>
</ul>
<p>5/ Bảo mật giao thức SSL</p>
<p>Mức độ bảo mật của SSL như trên mô tả phụ thuộc chính vào độ dài khoá hay phụ thuộc vào việc sử dụng phiên bản mã hoá 40 bits và 128bits. Phương pháp mã hoá 40 bits được sử dụng rộng rãi không hạn chế ngoài nước Mỹ và phiên bản mã hoá 128 bits chỉ được sử dụng trong nước Mỹ và Canada. Theo luật pháp Mỹ, các mật mã "mạnh" được phân loại vào nhóm "vũ khí" (weapon) và do đó khi sử dụng ngoài Mỹ (coi như là xuất khẩu vũ khí) phải được phép của chính phủ Mỹ hay phải được cấp giấy phép của Bộ Quốc phòng Mỹ (DoD). Đây là một lợi điểm cho quá trình thực hiện các dịch vụ thương mại và thanh toán điện tử trong Mỹ và các nước đồng minh phương Tây và là điểm bất lợi cho việc sử dụng các sản phẩm cần có cơ chế bảo mật và an toàn trong giao dịch điện tử nói chung và thương mại điện tử nói riêng trong các nước khác.</p>
<p>Các phương thức tấn công (hay bẻ khoá) của các thuật toán bảo mật thường dùng dựa trên phương pháp "tấn công vét cạn" (brute-force attack) bằng cách thử-sai miền không gian các giá trị có thể của khoá. Số phép thử-sai tǎng lên khi độ dài khoá tăng và dẫn đến vượt quá khả nǎng và công suất tính toán, kể cả các siêu máy tính hiện đại nhất. Thí dụ, với độ dài khoá là 40 bits, thì số phép thử sẽ là 2<sup>40</sup>=1,099,511,627,776 tổ hợp. Tuy nhiên độ dài khoá lớn kéo theo tốc độ tính toán giảm (theo luỹ thừa nghịch đảo) và dẫn đến khó có khả nǎng áp dụng trong thực tiễn. Một khi khoá bị phá, toàn bộ thông tin giao dịch trên mạng sẽ bị kiểm soát toàn bộ. Tuy nhiên do độ dài khoá lớn (thí dụ 128 bits, 256 bits), số phép thử-sai trở nên "không thể thực hiện" vì phải mất hàng năm hoặc thậm chí hàng nghìn nǎm với công suất và nǎng lực tính toán của máy tính mạnh nhất hiện nay.</p>
<p>Ngay từ năm 1995, bản mã hoá 40 bits đã bị phá bởi sử dụng thuật toán vét cạn. Ngoài ra, một số thuật toán bảo mật (như DES 56 bits, RC4, MD4,...) hiện nay cũng bị coi là không an toàn khi áp dụng một số phương pháp và thuật toán tấn công đặc biệt. Đã có một số đề nghị thay đổi trong luật pháp Mỹ nhằm cho phép sử dụng rộng rãi các phần mềm mã hoá sử dụng mã hoá 56 bits song hiện nay vẫn chưa được chấp thuận.</p>
<p>II. Lập trình mạng an toàn bảo mật SSL</p>
<h6>1.   Thư viện java hỗ trợ lập trình SSL</h6>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/Picture11-2.jpg" alt="" width="624" height="284" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-2-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-2-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-2-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-2-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-2-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-2-2xl.jpg 1920w"></figure>
<p class="align-center">Hình 7.3. Kiến trúc JDK</p>
<p>Java™ security bao gồm tập hợp rất nhiều APIs, công cụ, và cài đặt của các thuật toán bảo mật thông dụng (commonly-used security algorithms), các cơ chế (mechanisms) và các giao thức (protocols). Java security APIs được sử dụng rộng rãi. Bao gồm mã hóa (cryptography), hạ tầng khóa chung (public key infrastructure), trao đổi bảo mật (secure communication), xác thực (authentication), và điều khiển truy cập (access control). Bao gồm rất nhiều lớp thư viện như Java Authentication and Authorization Service (JAAS), Java Cryptography Extension (JCE), Java Secure Socket Extension (JSSE)… Tuy nhiên trong báo cáo này chỉ tập trung vào JSSE. Và cụ thể hơn là JSSE hỗ trợ SSL. Các gói thư viện hỗ trợ lập trình với SSL:</p>
<ul>
<li>Gói net.ssl (JSSE)</li>
<li>Gói rmi.ssl (SSL/TLS-based RMI Socket Factories)</li>
</ul>
<p>    1.1 Lớp SSL</p>
<p>       Để truyền thông an toàn, cả 2 phía của kết nối đều phải sử dụng SSL. Trong java, các lớp điểm cuối của kết nối là SSLSocket và SSLEngine. Hình 7.4. cho thấy các lớp chính được sử dụng để tạo ra SSLSocket/SSLEngines.</p>
<figure class="post__image align-right"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/Picture11-3.jpg" alt="" width="571" height="431" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-3-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-3-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-3-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-3-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-3-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-3-2xl.jpg 1920w"></figure>
<p class="align-center">Hình 7.4. Các lớp java SSL</p>
<p>2/ Ví dụ về sử dụng lớp SSL</p>
<p>Chương trình ví dụ có mã lệnh cho phép server và client có thể xác thực nhau. Muốn vậy thì client phải có chứng chỉ của server ( thực tế là một tập (chain) chứng chỉ). Trường hợp ví dụ chứng chỉ của server là chứng chỉ tự ký (self-certificate). Sau đó khi chạy chương trình thì trỏ tới nó.Sau khi đánh lệnh trên thì sẽ hiện ra các thông tin để điền vào như mật khẩu, tên cá nhân, tên tổ chức, thành phố,…</p>
<p><em>Server source code (EchoServer.java)</em></p>
<p>import javax.net.ssl.SSLServerSocket;</p>
<p>import javax.net.ssl.SSLServerSocketFactory; import javax.net.ssl.SSLSocket;</p>
<p>import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; public class EchoServer {</p>
<p>public      static    void main(String[] arstring) { try {</p>
<p>SSLServerSocketFactory sslserversocketfactory = (SSLServerSocketFactory)</p>
<p>SSLServerSocketFactory.getDefault();</p>
<p>SSLServerSocket sslserversocket = (SSLServerSocket)</p>
<p>sslserversocketfactory.createServerSocket(9999);</p>
<p>SSLSocket sslsocket = (SSLSocket) sslserversocket.accept(); InputStream inputstream = sslsocket.getInputStream(); InputStreamReader inputstreamreader        =      new</p>
<p>InputStreamReader(inputstream);</p>
<p>BufferedReader       bufferedreader                    =                  new BufferedReader(inputstreamreader);</p>
<p>String string = null;</p>
<p>while ((string = bufferedreader.readLine()) != null) { System.out.println(string);</p>
<p>System.out.flush();</p>
<p>}</p>
<p>} catch (Exception exception) { exception.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><strong><em>Client source code (EchoClient.java)</em></strong></p>
<p>import javax.net.ssl.SSLSocket; import javax.net.ssl.SSLSocketFactory; import java.io.*;</p>
<p>public class EchoClient {</p>
<p>public        static    void main(String[] arstring) { try {</p>
<p>SSLSocketFactory       sslsocketfactory        = (SSLSocketFactory) SSLSocketFactory.getDefault();</p>
<p>SSLSocket              sslsocket              = (SSLSocket) sslsocketfactory.createSocket("localhost", 9999);</p>
<p>InputStream inputstream = System.in;</p>
<p>InputStreamReader      inputstreamreader                      =                    new InputStreamReader(inputstream);</p>
<p>BufferedReader         bufferedreader                      =                    new BufferedReader(inputstreamreader);</p>
<p>OutputStream outputstream = sslsocket.getOutputStream(); OutputStreamWriter outputstreamwriter          =        new</p>
<p>OutputStreamWriter(outputstream);</p>
<p>BufferedWriter         bufferedwriter                      =                    new BufferedWriter(outputstreamwriter);</p>
<p>String string = null;</p>
<p>while ((string = bufferedreader.readLine()) != null) { bufferedwriter.write(string + '\n');</p>
<p>bufferedwriter.flush();</p>
<p>}</p>
<p>} catch (Exception exception) { exception.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p><em>}</em></p>
<p>Sau khi dịch chạy chương trình , đựoc kết quả sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/Picture11-4.jpg" alt="" width="623" height="314" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-4-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-4-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-4-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-4-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-4-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/10/responsive/Picture11-4-2xl.jpg 1920w"></figure>
<h2>Giải thích:</h2>
<p>-genkey: Lệnh tạo key</p>
<p>-keystore mySrvKeystore: Tên key là mySrvKeystore</p>
<p>-keyalg RSA: Thuật toán dùng để mã hóa là RSA</p>
<h6>Về phần ứng dụng qua giao diện dòng lệnh thì sử dụng chương trình mẫu giống như ở trên. Chạy như sau:</h6>
<p>Tạo chứng nhận:</p>
<p>keytool -genkey -keystore mySrvKeystore -keyalg RSA Mật khẩu sẽ điền là 123456</p>
<p>Sau khi tạo xong chứng chỉ thì copy file key vào trong thư mục chứa file</p>
<p>Phía server thì chứng chỉ được lưu trong keyStore</p>
<p>Chạy chương trình:java                               -Djavax.net.ssl.keyStore=mySrvKeystore                                      - Djavax.net.ssl.keyStorePassword=123456 EchoServer</p>
<p>Phía Client thì chứng chỉ được lưu trong trustStore</p>
<p>Chạy chương trình:java                               -Djavax.net.ssl.trustStore=mySrvKeystore                                     - Djavax.net.ssl.trustStorePassword=123456 EchoClient</p>
<p>III/ Kết luận</p>
<p style="text-align: justify; line-height: 130%; margin: 4.55pt 43.75pt .0001pt 35.95pt;"><span lang="vi">           Chương này bước đầu đề cập đến vấn đề lập trình mạng an toàn bảo mật mà chủ yếu với<span style="letter-spacing: -.15pt;"> </span>SSL, là giao thức được sử dụng rộng<span style="letter-spacing: -.1pt;"> </span>rãi nhất cho việc cài<span style="letter-spacing: -.15pt;"> </span>đặt mã hoá trong Web. Với cách tiếp cận này, sinh viên có thể tự nghiên cứu khai thác các kỹ thuật lập trình mạng an toàn bảo mật khác nhau, khai thác các hỗ trợ khác nhau của các môi trường Java, .NET...(bảo mật trong java, phương thức SOCKS, JCA, JCE...).</span></p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 7:Kỹ thuật lập trình phân tán RMI</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/bai-7.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/bai-7.html</id>

        <updated>2024-12-29T11:11:39+07:00</updated>
            <summary>
                <![CDATA[
                    7.1/ Khái niệm chung Lập trình đối tượng phân tán là một vấn đề hấp dẫn của công nghệ phân tán phần mềm ngày này. Java là ngôn ngữ đi tiên phong với RMI (Remote Method Invocation), một kỹ thuật cài đặt các đối tượng&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>7.1/ Khái niệm chung</p>
<p>            Lập trình đối tượng phân tán là một vấn đề hấp dẫn của công nghệ phân tán phần mềm ngày này. Java là ngôn ngữ đi tiên phong với RMI (Remote Method Invocation), một kỹ thuật cài đặt các đối tượng phân tán vô cùng hiệu quả và linh hoạt.</p>
<p>        Thông thường các chương trình của chúng ta được viết dưới dạng thủ tục - hàm và việc các hàm gọi lẫn nhau và truyền tham số chỉ xảy ra ở máy cục bộ. Kỹ thuật RMI - mang ý nghĩa là triệu gọi phương thức từ xa là cách thức giao tiếp giữa các đối tượng trong Java có mã lệnh cài đặt nằm ở trên các máy khác nhau có thể triệu gọi lẫn nhau.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Picture5.png" alt="" width="399" height="228" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 7.1: Mô hình RMI tổng quát</em></p>
<p>   7.2/ Kỹ thuật lập trình RMI theo mô hình Client/Server</p>
<p>        Để giải quyết một số vấn đề trong việc truyền thông giữa Client ó Server. RMI  không gọi trực tiếp mà thông qua lớp trung gian. Lớp này tồn tại ở cả hai phía Client và Server:</p>
<ul>
<li>Lớp ở Client gọi là <em>Stub</em></li>
<li>Lớp ở máy Server gọi là <em>Skel </em>(Skeleton) </li>
</ul>
<p>         Các đặc tính của RMI:</p>
<ul>
<li>RMI là mô hình đối tượng phân tán của Java, nó giúp cho việc truyền thông giữa các đối tượng phân tán được dễ dàng hơn.</li>
<li>RMI là API bậc cao được xây dựng dựa trên lập trình</li>
</ul>
<ul>
<li>RMI không những cho phép chúng ta truyền dữ liệu giữa các đối tượng trên các hệ thống máy tính khác nhau và còn gọi được các phương thức trong các đối tượng ở xa.</li>
<li>Việc truyền dữ liệu giữa các máy khác nhau được sử lý một cách trong suốt bởi máy ảo Java (Java Virtual Machine).</li>
<li>RMI cung cấp cơ chế callback, nó cho phép Server triệu gọi các phương thức ở Client.</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Picture5-2.png" alt="" width="309" height="369" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-2-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 7.2: Kiến trúc cơ bản của RMI</em></p>
<p>Kiến trúc của RMI:</p>
<ul>
<li>Remote interface: Nên extend từ <em>rmi.Remote</em>. Nó khai báo tất cả các phương thức mà Client có thể triệu gọi. Tất cả các phương thức trong interface này nên <em>throws RemoteException</em>.</li>
<li>Remote implementation: Được thực thi từ Remote interface và mở rộng từ <em>UnicastRemoteObject</em>. Triển khai các phương thức được khai báo trong interface tại đây. Nó là một Remote Object thực sự. Phát sinh hai lớp trung gian Stub và Skeleton.</li>
<li>Server class bao gồm:</li>
</ul>
<ul style="list-style-type: circle;">
<li>      Các class được hiện thực trên</li>
<li>       RMI registry: Bộ đăng kí này sẽ đăng kí một Remote object với Naming Registry. Giúp các Remote object được chấp nhận khi gọi các phương thức từ xa.</li>
</ul>
<ul>
<li>Client class: Truy vấn trên tên Remote object trên RMI registry, thông qua Stub để gọi các phương thức trên Server.</li>
</ul>
<p>Truyền tin trong RMI:</p>
<ul>
<li>RMI sử dụng lớp trung gian để truyền tin Skeleton và</li>
<li>Lớp Stub dùng ở</li>
<li>Lớp Skeleton dùng ở</li>
<li>Java tạo ra các lớp trung</li>
<li>RMI sử dụng các TCP Cách thức hoạt động của RMI:</li>
<li>Server RMI phải đăng ký với 1 dịch vụ tra tìm và đăng ký tên miền.</li>
<li>Sau khi Server được đăng ký, nó sẽ chờ các yêu cầu của RMI</li>
<li>Các ClientRMI sẽ gửi thông điệp RMI để gọi một phương thức trên một đối tượng từ xa.</li>
<li>Ứng dụng Client yêu cầu một tên dịch vụ cụ thể và nhận một URL trỏ tới tài nguyên từ xa.</li>
</ul>
<p>Mô hình lập trình phân tán RMI:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-175836.png" alt="" width="1262" height="229" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-175836-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-175836-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-175836-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-175836-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-175836-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-175836-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 7.3: Các bước lập trình theo kỹ thuật RMI</em></p>
<ul>
<li>Bước 1: Tạo project cho Client và</li>
<li>Bước 2: Tạo Interface dùng chung cho cả Client và</li>
<li>Bước 3: Hiện thực Interface ở</li>
<li>Bước 4: Viết chương trình phía</li>
<li>Bước 5: Viết chương trình phía</li>
</ul>
<p>  7.3/ Một số ví dụ</p>
<p><strong><em>        Ví dụ 7-1</em></strong><em>. Viết chương trình liệt kê các số nguyên tố từ 1 tới N, với N là một số nguyên dương, sử dụng kỹ thuật lập trình RMI. Phương thức kiểm tra số nguyên tố được triệu gọi từ xa.</em></p>
<p><em>        Bước 1</em>: Tạo 2 project <em>RMI_Prime_Client </em>và <em>RMI_Prime_Server</em>.</p>
<p><em>        Bước 2</em>: Trong project <em>RMI_Prime_Server </em>tạo một package đặt tên là <em>Core</em>.</p>
<p>     Trong package này tạo một interface đặt tên là <em>PrimeInterface </em>như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-180023.png" alt="" width="1249" height="114" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180023-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180023-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180023-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180023-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180023-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180023-2xl.png 1920w"></figure>
<p>           Chú ý rằng trong kỹ thuật lập trình RMI các Interface phải kế thừa lớp <em>Remote</em>, các phương thức của nó phải <em>throws RemoteException</em>.</p>
<p>            Phương thức <em>isPrime(int x) </em>dùng để kiểm tra một số <em>x </em>có phải là số nguyên tố hay không. Phương thức này chưa được hiện thực mà mới chỉ khai báo.</p>
<p>            Sao chép package <em>Core </em>sang project <em>RMI_Prime_Client </em>(bao gồm cả <em>PrimeInterface</em>).</p>
<p><em>         Bước 3</em>: Hiện thực <em>PrimeInterface </em>phía Server. Trong project <em>RMI_Prime_Server </em>tạo một package mới đặt tên là <em>RMI</em>. Trong package này tạo một lớp mới đặt tên là <em>Prime</em>.</p>
<p>       Hiện thực hóa interface trong lớp này như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-180207.png" alt="" width="1250" height="520" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180207-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180207-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180207-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180207-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180207-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180207-2xl.png 1920w"></figure>
<p><em>          Bước 4</em>: Lập trình cho Server. Trong package <em>RMI </em>tạo class đặt tên là <em>Server</em>. Chúng ta tạo một <em>Registry </em>trên cổng bất kỳ (chẳng hạn 3210) rồi ràng buộc (bind) một <em>PrimeService </em>cho một đối tượng thuộc lớp <em>Prime </em>trên đó.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-180304.png" alt="" width="1246" height="401" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180304-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180304-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180304-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180304-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180304-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180304-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-180328.png" alt="" width="1255" height="148" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180328-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180328-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180328-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180328-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180328-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180328-2xl.png 1920w"></figure>
<p><em>          Bước 5</em>: Lập trình cho Client. Trong project <em>RMI_Prime_Client </em>tạo một package đặt tên là <em>RMI</em>. Trong package này tạo một JFrame Form đặt tên là <em>Client</em>. Thiết kế giao diện cho <em>Client </em>như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Picture11.jpg" alt="" width="375" height="312" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-2xl.jpg 1920w"></figure>
<p class="align-center"><em>Hình 7.4: Thiết kế giao diện liệt kê số nguyên tố</em></p>
<p>Lập trình cho sự kiện người dùng nhấp chuột vào nút <em>Lấy kết quả </em>như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-180525.png" alt="" width="1244" height="846" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180525-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180525-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180525-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180525-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180525-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180525-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-180615.png" alt="" width="1249" height="300" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180615-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180615-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180615-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180615-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180615-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180615-2xl.png 1920w"></figure>
<p>          Chạy <em>Server </em>trước, sau đó chạy <em>Client</em>. Trong form xuất hiện, nhập giá trị lớn nhất bất kỳ, giả sử là 500. Nhấn nút <em>Lấy kết quả</em>, chúng ta nhận được như hình bên dưới:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Picture5-3.png" alt="" width="372" height="345" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-3-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-3-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-3-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-3-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-3-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture5-3-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 7.5: Kết quả liệt kê số nguyên tố với máy chủ RMI</em></p>
<p><strong><em>          Ví dụ 7-2</em></strong><em>. Viết chương trình tìm ước số chung lớn nhất và kiểm tra tính nguyên tố của hai số nguyên dương bất kỳ, sử dụng kỹ thuật lập trình RMI. Phương thức kiểm tra số nguyên tố và phương thức tính ước số chung lớn nhất của hai số được triệu gọi từ xa.</em></p>
<p><em>        Bước 1</em>: Tạo 2 project <em>RMI_XuLySo_Client </em>và <em>RMI_XuLySo_Server</em>.</p>
<p><em>         Bước 2</em>: Trong project <em>RMI_XuLySo_Server </em>tạo một package đặt tên là <em>Core</em>. Trong package này tạo một interface đặt tên là <em>NumberInterface </em>với nội dung như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-180922.png" alt="" width="1248" height="143" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180922-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180922-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180922-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180922-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180922-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-180922-2xl.png 1920w"></figure>
<p>          Phương thức <em>ucln(int a, int b) </em>dùng để dùng để tìm ước số chung lớn nhất của hai số nguyên <em>a </em>và <em>b</em>.</p>
<p>          Phương thức <em>isPrime(int x) </em>dùng để kiểm tra một số <em>x </em>có phải là số nguyên tố hay không.</p>
<p>          Sao chép package <em>Core </em>sang project <em>RMI_XuLySo_Client</em>.</p>
<p><em>          Bước 3</em>: Hiện thực <em>NumberInterface</em>. Trong project <em>RMI_XuLySo_Server </em>tạo một package mới đặt tên là <em>RMI</em>. Trong package này tạo một lớp mới đặt tên là <em>NumberClass</em>.</p>
<p>          Hiện thực hóa interface trong lớp này như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-181035.png" alt="" width="1251" height="964" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181035-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181035-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181035-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181035-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181035-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181035-2xl.png 1920w"></figure>
<p><em>          Bước 4</em>: Lập trình cho Server. Trong package <em>RMI </em>tạo class đặt tên là <em>Server</em>. Chúng ta tạo một <em>Registry </em>trên cổng bất kỳ (chẳng hạn 3210) rồi ràng buộc (bind) một tên là <em>NumberService </em>cho một đối tượng thuộc lớp <em>NumberClass </em>trên đó.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-181126.png" alt="" width="1257" height="246" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181126-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181126-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181126-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181126-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181126-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181126-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-181157.png" alt="" width="1246" height="292" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181157-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181157-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181157-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181157-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181157-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-181157-2xl.png 1920w"></figure>
<p><em>          Bước 5</em>: Lập trình cho Client. Trong project <em>RMI_XuLySo_Client </em>tạo một package đặt tên là <em>RMI</em>. Trong package này tạo một JFrame Form đặt tên là <em>Client</em>. Thiết kế giao diện cho <em>Client </em>như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Picture11-3.jpg" alt="" width="369" height="120" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-3-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-3-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-3-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-3-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-3-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-3-2xl.jpg 1920w"></figure>
<p class="align-center"><em>Hình 7.9: Thiết kế form xử lý xâu theo kỹ thuật RMI</em></p>
<p>        Lập trình cho sự kiện người dùng nhấp chuột vào nút <em>Xử lý </em>như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-182901.png" alt="" width="1251" height="284" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182901-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182901-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182901-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182901-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182901-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182901-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Anh-chup-man-hinh-2024-12-27-182935.png" alt="" width="1257" height="1036" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182935-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182935-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182935-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182935-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182935-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Anh-chup-man-hinh-2024-12-27-182935-2xl.png 1920w"></figure>
<p>       Chạy <em>Server </em>trước, sau đó chạy <em>Client</em>. Trong form xuất hiện, nhập một xâu bất kỳ, chọn chức năng cần xử lý và nhấn nút <em>Xử lý</em>, chúng ta nhận được kết quả như hình bên dưới:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Picture11-4.jpg" alt="" width="294" height="153" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-4-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-4-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-4-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-4-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-4-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-4-2xl.jpg 1920w"></figure>
<p class="align-center"><em>Hình 7.10: Kết quả chuyển xâu thành in hoa</em></p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/Picture11-5.jpg" alt="" width="280" height="157" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-5-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-5-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-5-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-5-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-5-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/9/responsive/Picture11-5-2xl.jpg 1920w"></figure>
<p class="align-center"><em>Hình 7.11: Kết quả đếm số từ của xâu</em></p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 6:Lập trình giao thức UDP</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/bai-6.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/bai-6.html</id>

        <updated>2024-12-29T11:11:32+07:00</updated>
            <summary>
                <![CDATA[
                    6.1/ Khái niệm chung UDP là viết tắt của cụm từ User Datagram Protocol. UDP là một phần của bộ giao thức Internet được sử dụng bởi các chương trình chạy trên các máy tính khác nhau trên mạng. Không giống như TCP, UDP được&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>6.1/ Khái niệm chung</p>
<p>         UDP là viết tắt của cụm từ User Datagram Protocol. UDP là một phần của bộ giao thức Internet được sử dụng bởi các chương trình chạy trên các máy tính khác nhau trên mạng. Không giống như TCP, UDP được sử dụng để gửi các gói tin ngắn gọi là datagram, cho phép truyền nhanh hơn. Tuy nhiên, UDP không cung cấp kiểm tra lỗi nên không đảm bảo toàn vẹn dữ liệu.</p>
<p>          Giao thức UDP hoạt động tương tự như TCP nhưng nó không tạo ra một kết nối giữa các máy tính và không cung cấp kiểm tra lỗi khi truyền gói tin. Khi một ứng dụng sử dụng UDP, các gói tin chỉ được gửi đến người nhận. Người gửi không đợi để đảm bảo người nhận có nhận được gói tin hay không, mà tiếp tục gửi các gói tiếp theo. Nếu người nhận bỏ lỡ một vài gói tin UDP, gói tin đó bị mất vì người gửi sẽ không gửi lại chúng. Điều này có nghĩa là các thiết bị có thể giao tiếp nhanh hơn.</p>
<p>         UDP được sử dụng khi tốc độ được ưu tiên và sửa lỗi là không cần thiết. UDP thường được sử dụng cho phát sóng trực tuyến và trò chơi trực tuyến. Ví dụ như khi xem một luồng video trực tiếp, thường được phát bằng UDP thay vì TCP. Máy chủ chỉ gửi một luồng UDP liên tục tới các máy tính đang xem. Nếu bị mất kết nối trong vài giây, video có thể bị ngưng hoặc lag trong chốc lát và sau đó phát tiếp phần hiện tại. Nếu bị mất gói tin nhỏ, video hoặc âm thanh có thể bị méo mó một chút khi video tiếp tục phát mà không có dữ liệu bị mất.</p>
<p>         Điều này hoạt động tương tự trong các trò chơi trực tuyến. Nếu chúng ta bỏ lỡ một số gói UDP, các nhân vật của người chơi có thể xuất hiện trên bản đồ ở vị trí khác khi nhận được các gói UDP mới hơn.</p>
<p>          Sự khác nhau giữa TCP và UDP thường được minh họa bằng sự khác nhau giữa hệ thống điện thoại và hệ thống bưu chính. TCP giống với hệ thống điện thoại. Khi chúng ta gọi một số điện thoại nào đó, người đó cần đồng ý kết nối bằng cách nhấc điện thoại (trả lời cuộc gọi). Nếu điện thoại bận hoặc không có ai nhấc máy, chúng ta không liên lạc được. UDP thì giống như hệ thống bưu chính. Bạn gửi thư tay tới một địa chỉ cố định thông qua hệ thống bưu chính. Thư có thể tới nơi hoặc không tới nơi nhưng bạn không thể biết chắc được điều này. Bạn có thể gửi nhiều thư đi cho người nhận, đánh số chúng và yêu cầu họ gửi thư lại xác nhận xem thư nào tới, thư nào chưa tới. Bạn và người nhận phải thực hiện điều này chứ hệ thống bưu chính không thực hiện cho bạn.</p>
<p>            Cả hệ thống điện thoại và hệ thống bưu chính hiện vẫn đang hoạt động song song cho những mục đích khác nhau. Cũng giống như vậy, TCP và UDP đều có mục đích sử dụng riêng. Chúng ta không thể nói rằng cái nào tốt hơn cái nào. Thay vào đó, với từng ứng dụng cụ thể hay nói chính xác hơn là với từng yêu cầu cụ thể chúng ta sử dụng TCP hay UDP.</p>
<p>         Trong Java, cả UDP Server và UDP Client đều sử dụng các đối tượng của lớp <em>java.net.DatagramSocket </em>để giao tiếp và <em>java.net.DatagramPacket </em>là lớp được sử dụng để đóng gói dữ liệu để gửi đi và nhận dữ liệu dưới dạng packet. Số lượng byte lớn nhất có thể gửi thông qua UDP là <em>65507 </em>byte cho một lần. Mặc dù vậy, trên các ứng dụng thực chúng ta ít khi sử dụng hết độ dài này mà thường trong khoảng 8.192 bytes (8K). Và khi tiến hành gửi/nhận dữ liệu chúng ta cũng dùng kích thước bé hơn nhiều.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Picture5.png" alt="" width="626" height="305" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 6.1: Cấu tạo của DatagramPacket</em></p>
<p>             Để gửi dữ liệu, chúng ta cần chuyển nó về kiểu <em>byte[]</em>, đưa dữ liệu vào <em>DatagramPacket </em>và gửi nó qua một <em>DatagramSocket</em>. Để nhận dữ liệu, ta nhận một <em>DatagramPacket </em>thông qua một <em>DatagramSocket </em>và tách lấy dữ liệu từ packet. Dữ liệu nhận được là kiểu <em>byte[]</em>, do đó chúng ta cần chuyển nó về kiểu dữ liệu thích hợp để lấy được thông tin cần thiết. <em>DatagramPacket </em>cũng có các phương thức giúp đọc thông tin liên quan tới máy gửi như địa chỉ mạng, cổng,…</p>
<p>        Việc sử dụng hai lớp <em>DatagramPacket </em>và <em>DatagramSocket </em>tương phản với TCP sử dụng lớp <em>Socket </em>và <em>ServerSocket</em>. Khác biệt thứ nhất giữa TCP và UDP là UDP không thực hiện một kết nối giữa hai máy tính khi gửi/nhận dữ liệu. Một socket có thể gửi và nhận dữ liệu từ nhiều máy tính khác nhau chứ không phụ thuộc vào một kết nối như TCP. Thứ hai, TCP socket sử dụng một kết nối để điều khiển các luồng dữ liệu. Với TCP, chúng ta gửi/nhận thông qua các dòng vào/dòng ra của socket. UDP thì không như vậy, chúng ta làm việc với các datagram packet riêng lẻ. Các packet không liên quan với nhau và khi nhận chúng ta không thể biết packet nào được gửi trước, packet nào được gửi sau.</p>
<p>       6.2/ Lớp DatagramSocket</p>
<p>         Không giống như TCP, đối với UDP thì cả bên nhận và bên gửi sẽ cùng sử dụng lớp <em>DatagramSocket </em>để giao tiếp với nhau. Một số phương thức chính:</p>
<p><em>public <strong>DatagramSocket</strong>() throws SocketException</em></p>
<p>         Hàm khởi tạo UDP socket cho Client. Khởi tạo UDP socket và chưa chỉ định cổng cụ thể, dùng các cổng còn trống của hệ thống.</p>
<p><em>public <strong>DatagramSocket</strong>(int port) throws SocketException</em></p>
<p>         Hàm khởi tạo UDP socket cho Server. Khởi tạo UDP socket và ràng buộc nó vào một <em>port </em>cụ thể được chỉ ra.</p>
<p><em>public synchronized void <strong>setSoTimeout</strong>(int timeout) throws SocketException</em></p>
<p>         Phương thức thiết lập thời gian chờ cho <em>DatagramSocket</em>. Hết thời gian chờ này không có phản hồi từ phía máy gửi, socket sẽ tự hủy.</p>
<p><em>public void <strong>send</strong>(DatagramPacket p) throws IOException</em></p>
<p>         Gửi <em>DatagramPacket </em>đến host nhận. <em>DatagramPacket </em>chứa dữ liệu cần gửi, độ dài dữ liệu, địa chỉ IP và số hiệu port của host sẽ nhận.</p>
<p><em>public void <strong>receive</strong>(DatagramPacket p) throws IOException</em></p>
<p>          Thực hiện nhận về packet từ <em>DatagramSocket</em>. Khi phương thức này được gọi thành công, <em>buf </em>của <em>DatagramPacket </em>sẽ chứa nội dung dữ liệu nhận được. Đồng thời <em>DatagramPacket </em>còn chứa thông tin về địa chỉ IP và port của bên gửi. Phương thức này khi gọi sẽ bị block cho đến khi có 1 <em>DatagramPacket </em>được nhận.</p>
<p><em>void <strong>bind</strong>(SocketAddress addr) throws SocketException</em></p>
<p>           Ràng buộc <em>DatagramSocket </em>vào một địa chỉ mạng cụ thể (IP và port). Phương thức này thường được dùng khi tạo <em>DatagramSocket </em>bằng phương thức thứ nhất, tức là không chỉ định rõ cổng cụ thể hoặc là muốn thay đổi địa chỉ mạng cho UDP socket.</p>
<p><em>public void <strong>close</strong>()</em></p>
<p>Đóng <em>DatagramSocket</em>.</p>
<p>      6.3/ Lớp DatagramPacket</p>
<p>          Lớp <em>DatagramPacket </em>trong Java dùng để đóng gói dữ liệu để gửi đi, đồng thời cũng dùng để nhận dữ liệu từ <em>DatagramSocket</em>. Một số phương thức chính:</p>
<p><em>public <strong>DatagramPacket</strong>(byte buf[], int length)</em></p>
<p>           Khởi tạo một <em>DatagramPacket </em>dùng để nhận 1 packet có độ dài là <em>length </em>nhỏ hơn hoặc bằng <em>buf.length</em>; <em>buf[] </em>là vùng nhớ đệm dùng để lưu dữ liệu sắp nhận; <em>length </em>là số lượng byte lớn nhất được dùng để nhận dữ liệu.</p>
<p><em>public <strong>DatagramPacket</strong>(byte buf[], int length, InetAddress address, int port)</em></p>
<p>           Khởi tạo một <em>DatagramPacket </em>để gửi 1 packet có độ dài là <em>length </em>đến cổng có số hiệu <em>port </em>trên host cụ thể được chỉ ra trong <em>address</em>; <em>buf[] </em>chính là dữ liệu muốn gửi.</p>
<p><em>public InetAddress <strong>getAddress</strong>()</em></p>
<p>          Trả về địa chỉ IP của host đã gởi packet hoặc host sẽ nhận packet.</p>
<p><em>public int <strong>getPort</strong>()</em></p>
<p>          Trả về giá trị port của host đã gởi packet hoặc host mà packet sẽ được gởi đến.</p>
<p><em>public byte[] <strong>getData</strong>()</em></p>
<p>           Trả về nội dung dữ liệu trong <em>DatagramPacket public int <strong>getLength</strong>()</em></p>
<p>           Trả về độ dài của dữ liệu trong <em>DatagramPacket. public synchronized int <strong>getOffset</strong>()</em></p>
<p>           Trả về <em>offset </em>(độ lệch) của dữ liệu trong <em>DatagramPacket</em>.</p>
<p>     6.4/ Lập trình UDP theo mô hình Client/Server</p>
<p>             Trong mô hình lập trình UDP Client/Server đều sử dụng hai lớp <em>DatagramSocket</em><em> </em>và <em>DatagramPacket</em><em> </em>cho cả phía Client và Server. Tuy nhiên cách sử dụng hai lớp này ở phía Client và Server là khác nhau trong các constructor.</p>
<p>        Quan sát mô hình trên <em>Hinh 6.2</em>, ta thấy rằng để tạo một giao tiếp bằng UDP, phía máy chủ sẽ tạo ra một socket và ràng buộc trên một cổng nhất định nào đó.</p>
<p>         Muốn gửi dữ liệu (hoặc yêu cầu) thì phải biết trước các thông tin liên quan như địa chỉ mạng, cổng kết nối của máy nhận. Máy gửi sẽ tạo ra một socket dùng cho việc gửi dữ liệu. Máy gửi tạo ra một <em>DatagramPacket </em>với các thông tin như dữ liệu,chiều dài dữ liệu, địa chỉ mạng, cổng kết nối của máy nhận. Chúng ta sẽ gọi tới socket đã tạo và gửi packet đi.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Picture5-2.png" alt="" width="464" height="435" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-2-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 6.2: Mô hình Client/Server theo kỹ thuật lập trình với giao thức UDP</em></p>
<p>Đoạn chương trình để gửi dữ liệu bằng giao thức UDP:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Anh-chup-man-hinh-2024-12-27-174219.png" alt="" width="1247" height="227" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174219-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174219-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174219-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174219-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174219-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174219-2xl.png 1920w"></figure>
<p>          Phía máy nhận muốn nhận dữ liệu thì sẽ tạo ra một socket để gửi/nhận dữ liệu. Nếu đã có socket rồi thì có thể sử dụng lại. Sau đó, máy nhận tạo ra một packet với thông tin về biến nhớ đệm và độ dài dữ liệu. Sau đó, chúng ta sẽ dùng socket để nhận dữ liệu.</p>
<p>     Đoạn chương trình để gửi dữ liệu bằng giao thức UDP:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Anh-chup-man-hinh-2024-12-27-174324.png" alt="" width="1248" height="154" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174324-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174324-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174324-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174324-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174324-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174324-2xl.png 1920w"></figure>
<p>           Trong đoạn mã trên, <em>65507 </em>được dùng làm kích thước của dữ liệu nhận. Đây là kích thước lớn nhất có thể dùng. Tuy nhiên, trên thực tế khi dùng ta có thể sử dụng số bé hơn.</p>
<p>        Để đọc thông tin của packet nhận được, ta có đoạn mã sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Anh-chup-man-hinh-2024-12-27-174413.png" alt="" width="1253" height="187" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174413-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174413-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174413-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174413-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174413-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174413-2xl.png 1920w"></figure>
<p>          Thông tin đọc được từ phía máy gửi có thể dùng để gửi lại phản hồi sau này. Nói một cách chính xác thì thông tin địa chỉ mạng và cổng sẽ dùng để đóng gói thông tin qua một <em>DatagramPacket </em>dùng để gửi phản hồi cho máy vừa gửi thông tin. Điều này cũng giống như việc gửi thư, khi nhận được thư ta thường đọc thông tin của người gửi (nếu không biết trước) trên phong bì thư để gửi lại thư phản hồi.</p>
<p>      6.5/ Một số ví dụ</p>
<p><strong><em>          Ví dụ 6-1</em></strong><em>. Viết chương trình UDP kiểm tra một xâu có phải là xâu đối xứng hay không. Client sẽ gửi lên Server một xâu. Server sẽ gửi trả kết quả kiểm tra tính đối xứng của xâu.</em></p>
<p><em>          Bước 1</em>: Lập trình phía Server.</p>
<ul>
<li>Tạo một project đặt tên là <em>UDP_Server</em>.</li>
<li>Trong project này tạo một class và đặt tên là <em>Server</em>.</li>
<li>Viết mã lệnh cho <em>Server </em>như sau:</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Anh-chup-man-hinh-2024-12-27-174516.png" alt="" width="1263" height="710" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174516-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174516-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174516-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174516-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174516-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174516-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Anh-chup-man-hinh-2024-12-27-174541.png" alt="" width="1253" height="664" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174541-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174541-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174541-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174541-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174541-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174541-2xl.png 1920w"></figure>
<p><em>      Bước 2</em>: Lập trình phía <em>Client</em></p>
<ul>
<li>Tạo một project khác đặt tên là <em>UDP_Client</em>.</li>
<li>Trong project này tạo một JFrame Form đặt tên là <em>Client</em>.</li>
<li>Thiết kế giao diện như hình dưới:</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Picture5-3.png" alt="" width="286" height="187" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-3-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-3-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-3-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-3-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-3-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-3-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 6.3: Thiết kế giao diện xử lý xâu bằng UDP</em></p>
<ul>
<li>Xử lý sự kiện khi người dùng nhấn vào nút <em>Kiểm tra</em>:</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Anh-chup-man-hinh-2024-12-27-174828.png" alt="" width="1247" height="518" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174828-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174828-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174828-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174828-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174828-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174828-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Anh-chup-man-hinh-2024-12-27-174904.png" alt="" width="1251" height="698" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174904-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174904-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174904-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174904-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174904-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Anh-chup-man-hinh-2024-12-27-174904-2xl.png 1920w"></figure>
<p><em>          Bước 3</em>: Chạy chương trình</p>
<ul>
<li>Chạy <em>Server </em>trước.</li>
<li>Chạy <em>Client </em>sau, nhập dữ liệu và nhấn nút <em>Kiểm tra</em>.</li>
<li>Kết quả như hình dưới.</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/Picture5-4.png" alt="" width="253" height="181" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-4-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-4-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-4-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-4-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-4-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/8/responsive/Picture5-4-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 6.4: Kết quả xử lý xâu bằng máy chủ UDP</em></p>
<p>          Trên đây là một ví dụ đơn giản về kỹ thuật lập trình với giao thức UDP để xử lý xâu. So với các ví dụ về TCP, rõ ràng chúng ta chương trình không tạo một kết nối giữa Server và Client. Việc giao tiếp giữa chúng được thực hiện thông qua các <em>DatagramSocket</em>. Dữ liệu được gửi/nhận bằng cách tạo ra các <em>DatagramPacket </em>với các phương thức tạo dùng để gửi và để nhận. Các <em>DatagramPacket </em>này được gửi/nhận thông qua các <em>DatagramSocket</em>.</p>
<p>          Chúng ta có thể làm lại các ví dụ ở chương trước (TCP) với kỹ thuật trao đổi dữ liệu Client/Server theo ví dụ trên.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 5:LẬP TRÌNH VỚI GIAO THỨC TCP</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/bai-5.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/bai-5.html</id>

        <updated>2024-12-29T11:11:26+07:00</updated>
            <summary>
                <![CDATA[
                    5.1/Khái niệm chung Thuật ngữ lập trình mạng với Java đề cập đến việc viết các chương trình thực hiện trên nhiều thiết bị máy tính, trong đó các thiết bị được kết nối với nhau. Gói java.net của Java chứa một tập hợp các&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>5.1/Khái niệm chung</p>
<p>               Thuật ngữ lập trình mạng với Java đề cập đến việc viết các chương trình thực hiện trên nhiều thiết bị máy tính, trong đó các thiết bị được kết nối với nhau.</p>
<p>          Gói <em>java.net </em>của Java chứa một tập hợp các lớp và giao tiếp cung cấp giao thức truyền thông ở mức độ thấp.</p>
<p>         Gói <em>java.net </em>được cung cấp hỗ trợ cho hai giao thức mạng phổ biến sau:</p>
<ul>
<li><strong>TCP </strong>- Transmission Control Protocol: TCP thường được sử dụng qua giao thức Internet (Internet Protocol), được gọi là TCP/IP. Giao thức này cho phép giao tiếp tin cậy giữa hai ứng dụng.</li>
<li><strong>UDP </strong>- User Datagram Protocol: một giao thức khác cho phép truyền dữ liệu giữa các ứng dụng. Giao thức này không kiểm tra đến việc gói tin đã được gửi hay chưa nên đây là giao tiếp không tin cậy giữa hai hoặc nhiều ứng dụng. Chúng ta  sẽ tìm hiểu về lập trình với giao thức UDP ở chương</li>
</ul>
<p>         TCP và UDP là các giao thức cốt lõi của việc kết nối các thiết bị công nghệ với nhau. Các ứng dụng có thể dùng một trong hai hoặc cả hai giao thức này để trao đổi với các ứng dụng trên máy tính khác thông qua mạng máy tính.</p>
<p>        5.2/Khái niệm rỗng (port number)</p>
<p>         Để có thể thực hiện các cuộc giao tiếp, một trong hai quá trình phải công bố số hiệu cổng của socket mà mình sử dụng. Mỗi cổng giao tiếp thể hiện một địa chỉ xác định trong hệ thống. Khi quá trình được gán một số hiệu cổng, nó có thể nhận dữ liệu gửi đến cổng này từ các quá trình khác. Quá trình còn lại cũng được yêu cầu tạo ra một socket.</p>
<p>         Số hiệu cổng (port number) được sử dụng để xác định tính duy nhất của các ứng dụng khác nhau. Nó hoạt động như một điểm kết nối cuối trong giao tiếp giữa các ứng dụng.</p>
<p>         Số hiệu cổng gán cho Socket phải duy nhất trên phạm vi máy tính đó, có giá trị trong khoảng từ 0 đến 65535 (16 bit). Trong đó, giá trị cổng:</p>
<ul>
<li>Từ 0-1023: là cổng hệ thống (common hay well-known port), được dành riêng cho các quá trình của hệ thống.</li>
<li>Từ 1024-49151: là cổng phải đăng ký (registered port). Các ứng dụng muốn sử dụng cổng này phải đăng ký với IANA (Internet Assigned Numbers Authority).</li>
<li>Từ 49152-65535: là cổng dùng riêng hay cổng động (dynamic hay private port). Người sử dụng có thể dùng cho các ứng dụng của mình, không cần phải đăng ký.</li>
</ul>
<p>Một số cổng thường được sử dụng:</p>
<ul>
<li>21: dịch vụ FTP</li>
<li>23: dịch vụ Telnet</li>
<li>25: dịch vụ Email (SMTP)</li>
<li>80: dịch vụ Web (HTTP)</li>
<li>110: dịch vụ Email (POP)</li>
<li>143: dịch vụ Email (IMAP)</li>
<li>443: dịch vụ SSL (HTTPS)</li>
<li>1433/1434: cơ sở dữ liệu SQL Server</li>
<li>3306: cơ sở dữ liệu MySQL</li>
</ul>
<p>   5.3/ Lớp Socket</p>
<p>       Đơn vị truyền và nhận tin bằng phương thức TCP được gọi là Socket.</p>
<p>      Socket cho phép dữ liệu được trao đổi giữa các thiết bị trong môi trường mạng máy tính.</p>
<p>      Lớp <em>java.net.Socket </em>trong Java giúp quản lý quá trình truyền và nhận giữa các máy tính trong mạng máy tính bằng giao thức TCP.</p>
<p>       Một Socket đóng vai trò một đầu-cuối của một kết nối thực. Một Socket vừa có thể của Client để gửi yêu cầu kết nối tới Server vừa có thể được tạo bởi Server để xử lý yêu cầu trao đổi tin từ Client.</p>
<p>       Chúng ta cùng tìm hiểu các phương thức của lớp <em>Socket</em>.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture1.png" alt="" width="236" height="221" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture1-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture1-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture1-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture1-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture1-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture1-2xl.png 1920w"></figure>
<p>     5.3.1/ Các phương thức tạo</p>
<p><em>public <strong>Socket</strong>(String host, int port) throws IOException, UnknownHostException</em></p>
<p>      Constructor này cố gắng để kết nối với máy chủ được chỉ định tại cổng được chỉ định. Nếu constructor này không ném một ngoại lệ, kết nối thành công và máy khách được kết nối với máy chủ.</p>
<p><em>public <strong>Socket</strong>(InetAddress host, int port)throws IOException, UnknownHostException</em></p>
<p>        Constructor này giống hệt với hàm tạo trước đó, ngoại trừ việc máy chủ được chỉ định bởi một đối tượng <em>InetAddress</em>.</p>
<p><em>public <strong>Socket</strong>(String host, int port, InetAddress localAddress, int localPort)throws IOException</em></p>
<p>        Kết nối đến máy chủ và cổng được chỉ định, tạo một socket trên máy chủ cục bộ tại địa chỉ và cổng được chỉ định.</p>
<p><em>public <strong>Socket</strong>(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException</em></p>
<p>Constructor này giống hệt với constructor trước đó, ngoại trừ máy chủ được chỉ định bởi một đối tượng <em>InetAddress </em>thay vì một <em>String</em>.</p>
<p><em>public <strong>Socket</strong>()</em></p>
<p>       Tạo một socket không chỉ định trước kết nối. Sau này chúng ta sử dụng phương thức <em>connect() </em>để kết nối socket này với máy chủ.</p>
<p>        5.3.2/ Các phương thức kiểm soát vào - ra</p>
<p><em>public InputStream <strong>getInputStream</strong>() throws IOException</em></p>
<p>      Trả về dòng đầu vào của socket. Input stream được kết nối với output stream của socket remote.</p>
<p><em>public OutputStream <strong>getOutputStream</strong>() throws IOException</em></p>
<p>       Trả về dòng đầu ra của socket. Output stream được kết nối với input stream của socket remote.</p>
<p>        5.3.3/ Một số phương thức khác</p>
<p><em>        public void <strong>connect</strong>(SocketAddress host, int timeout) throws IOException</em></p>
<p>       Phương thức này kết nối socket với máy chủ được chỉ định. Phương thức này là cần thiết chỉ khi chúng ta khởi tạo Socket bằng cách sử dụng constructor không có đối số.</p>
<p><em>public InetAddress <strong>getInetAddress</strong>()</em></p>
<p>        Phương thức này trả về địa chỉ mạng của máy chủ mà socket này được kết nối.</p>
<p><em>public int <strong>getPort</strong>()</em></p>
<p>        Trả về cổng mà socket bị ràng buộc trên máy remote.</p>
<p><em>public int <strong>getLocalPort</strong>()</em></p>
<p>       Trả về cổng mà socket bị ràng buộc trên máy local.</p>
<p><em>public SocketAddress <strong>getRemoteSocketAddress</strong>()</em></p>
<p>      Trả về địa chỉ của socket từ xa.</p>
<p><em>public synchronized void <strong>setSoTimeout</strong>(int timeout) throws SocketException</em></p>
<p>       Thiết lập thời gian tồn tại của socket. Nếu <em>timeout</em><em> </em>khác <em>0</em>, đây chính là khoảng thời gian (được tính bằng mili giây) mà socket còn hoạt động. Hết thời gian này chương trình socket sẽ tự hủy.</p>
<p><em>public void <strong>close</strong>() throws IOException</em></p>
<p>        Đóng socket, làm cho đối tượng <em>Socket </em>này không còn có khả năng kết nối với bất kỳ máy chủ nào.</p>
<p>      5.4/ Lớp SeverSocket</p>
<p>        Lớp <em>java.net.ServerSocket </em>được sử dụng bởi các ứng dụng máy chủ để tạo ra một một ứng dụng tại một cổng và lắng nghe các yêu cầu của máy khách.</p>
<p>        Một đối tượng của lớp <em>ServerSocket </em>được tạo trên phía máy chủ và lắng nghe kết nối từ các máy khách. Đối tượng này luôn tồn tại trong một chương trình ứng dụng mạng đang chạy bằng giao thức TCP phía máy chủ.</p>
<p>      5.4.1/ Các phương thức tạo</p>
<p><em>public <strong>ServerSocket</strong>(int port) throws IOException</em></p>
<p>       Cố gắng tạo một <em>ServerSocket </em>bị ràng buộc vào port được chỉ định. Một ngoại lệ xảy ra nếu <em>port </em>đã bị ràng buộc bởi một ứng dụng khác.</p>
<p><em>public <strong>ServerSocket</strong>(int port, int backlog) throws IOException</em></p>
<p>        Tương tự như hàm tạo trước đó, tham số <em>backlog </em>xác định có bao nhiêu máy khách đến để lưu trữ trong một hàng đợi.</p>
<p><em>public <strong>ServerSocket</strong>(int port, int backlog, InetAddress address) throws IOException</em></p>
<p>        Tương tự như constructor trước đó, tham số <em>InetAddress </em>chỉ định địa chỉ IP cục bộ để ràng buộc. <em>InetAddress </em>được sử dụng cho các máy chủ có thể có nhiều địa chỉ IP, cho phép máy chủ xác định địa chỉ IP nào để chấp nhận yêu cầu của máy khách.</p>
<p><em>public <strong>ServerSocket</strong>() throws IOException</em></p>
<p>          Tạo ra một <em>ServerSocket</em><em> </em>không kết nối. Khi sử dụng constructor này, sử dụng phương thức <em>bind() </em>khi chúng ta muốn ràng buộc socket tới máy chủ.</p>
<p>      5.4.2/ Các phương thức khác</p>
<p><em>public Socket <strong>accept</strong>() throws IOException</em></p>
<p>        Chờ cho một máy khách kết nối đến. Phương thức này ngăn chặn cho đến khi một máy trạm kết nối đến máy chủ trên cổng được chỉ định hoặc socket hết hạn, giả sử rằng giá trị thời gian đã được thiết lập bằng phương thức <em>setSoTimeout()</em>. Nếu không, phương thức này sẽ khóa lại vô thời hạn.</p>
<p><em>public int <strong>getLocalPort</strong>()</em></p>
<p>         Trả về cổng mà socket của máy chủ lắng nghe. Phương thức này rất hữu ích nếu chúng ta truyền <em>0 </em>như là số cổng trong một constructor và để cho máy chủ tìm thấy một cổng cho chúng ta.</p>
<p><em>public void <strong>setSoTimeout</strong>(int timeout)</em></p>
<p>          Thiết lập giá trị thời gian chờ cho bao lâu socket của máy chủ chờ khách hàng trong suốt quá trình chấp nhận.</p>
<p><em>public void <strong>bind</strong>(SocketAddress host, int backlog)</em></p>
<p>          Liên kết socket tới máy chủ và cổng được chỉ định trong đối tượng <em>SocketAddress</em>. Sử dụng phương thức này nếu chúng ta đã tạo ra các <em>ServerSocket </em>bằng cách sử dụng constructor không có đối số.</p>
<p><em>public void <strong>close</strong>()</em></p>
<p>           Đóng <em>ServerSocket</em>, ngừng phục vụ. Chúng ta ít khi sử dụng phương thức này vì <em>ServerSocket </em>thường luôn phục vụ phía máy chủ.</p>
<p>            Khi <em>ServerSocket </em>gọi <em>accept()</em>, phương thức này sẽ không return cho đến khi một máy khách kết nối đến. Sau khi máy khách kết nối, <em>ServerSocket </em>tạo một <em>Socket </em>mới trên một cổng không xác định và trả về một tham chiếu đến <em>Socket </em>mới này và thực hiện kết nối TCP giữa máy khách và máy chủ để có thể truyền tin.</p>
<p>     5.5/ Lập trình TCP bằng mô hình Cilent/Server</p>
<p>          Trong mô hình lập trình TCP Client/Server với Java chúng ta sử dụng hai lớp <em>ServerSocket </em>và <em>Socket</em>. Lớp <em>ServerSocket </em>chỉ sử dụng ở phía Server trong khi lớp <em>Socket </em>sử dụng đồng thời ở phía Client và Server để trao đổi dữ liệu.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture2.png" alt="" width="435" height="323" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 5.1: Mô hình Client/Server theo kỹ thuật lập trình với giao thức TCP</em></p>
<p>          Quan sát hình trên chúng ta thấy rằng để tạo một ứng dụng mạng chạy bằng giao thức TCP chúng ta cần thiết lập hai ứng dụng riêng biệt: một ứng dụng Server và một ứng dụng cho Client.</p>
<p>       Theo trình tự thời gian, ứng dụng phía máy chủ sẽ chạy trước và tạo ra một</p>
<p><em>ServerSocket </em>trên cổng <em>x </em>để lắng nghe các kết nối từ phía máy khách.</p>
<p>        Máy khách sẽ tạo ra một <em>Socket </em>để kết nối tới máy chủ <em>hostid </em>qua cổng <em>x</em>.</p>
<p>        Khi có yêu cầu kết nối, máy chủ sẽ chấp nhận kết nối bằng cách tạo ra một Socket qua phương thức <em>accept()</em>. Sau khi thiết lập kết nối máy chủ và máy khách có thể trao đổi dữ liệu thông qua các phương thức kiểm soát vào-ra của lớp <em>Socket</em>. Kết nối này sẽ tồn tại đến khi nào một trong hai bên hủy bỏ kết nối bằng cách đóng kết nối qua phương thức <em>close() </em>hoặc có sự cố về mạng.</p>
<p>       5.6/ Xử lý ngoại lệ trong lập trình mạng</p>
<p>         Trong lập trình mạng nói chung, chúng ta thường xuyên gặp phải một số lỗi nhất định khi chạy chương trình. Có thể kể ra như lỗi xung đột cổng giữa các ứng dụng trên máy chủ, lỗi không kết nối được giữa các máy tính, lỗi không gửi/nhận dữ liệu được qua mạng…</p>
<p>Java định nghĩa một số ngoại lệ (Exception) để xử lý các sự cố này như:</p>
<p><em>IOException</em>, <em>UnknownHostException</em>…</p>
<p>         Để xử lý các ngoại lệ này chúng ta có hai cách:</p>
<ul>
<li>Sử dụng cú pháp <em>try-catch</em>: chúng ta nên dùng cách này để chủ động trong việc xử lý lỗi. Khi có lỗi xảy ra, chúng ta có thể có biện pháp khắc phục hợp lý hoặc thông báo lỗi cho người dùng biết.</li>
<li>Sử dụng cú pháp <em>throws </em>cho các phương thức: sử dụng cách này là chúng ta giao cho các lớp xử lý ngoại lệ của Java xử lý giúp. Cách này chỉ nên dùng với những lỗi đơn giản hoặc ít gặp phải.</li>
</ul>
<p>    5.7/ Một số ví dụ</p>
<p><strong><em>Ví dụ 5-1. </em></strong><em>Viết chương trình kiểm tra một cổng trên máy chủ có đang hoạt động hay không.</em></p>
<p>     Cổng đang hoạt động được hiểu là cổng đang có một ứng dụng chạy trên đó.</p>
<p>     Có nghĩa là nó đang đóng vai trò là máy phục vụ trên cổng đó.</p>
<p>      Việc thiết kế giao diện người dùng trong ví dụ này và các ví dụ sau được thực hiện trong phần mềm NetBeans. Chúng ta có thể sử dụng các công cụ khác để thiết kế hoặc tự sinh các đối tượng đồ họa bằng thư viện Swing và AWT.</p>
<p>      Dùng Swing hoặc AWT thiết kế giao diện như sau, tên biến của các đối tượng đồ họa được chú thích ở cuối mũi tên.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture2-2.png" alt="" width="351" height="132" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture2-2-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 5.2: Thiết kế giao diện kiểm tra cổng mạng</em></p>
<p>     Xử lý sự kiện khi người dùng bấm nút <em>Kiểm tra </em>như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Anh-chup-man-hinh-2024-12-27-143846-2.png" alt="" width="1213" height="81" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-143846-2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-143846-2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-143846-2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-143846-2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-143846-2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-143846-2-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Anh-chup-man-hinh-2024-12-26-150602.png" alt="" width="1203" height="401" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-26-150602-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-26-150602-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-26-150602-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-26-150602-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-26-150602-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-26-150602-2xl.png 1920w"></figure>
<p>Kết quả chúng ta nhận được như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture4.jpg" alt="" width="395" height="210" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-2xl.jpg 1920w"></figure>
<p><strong><em>Ví dụ 5-2. </em></strong><em>Viết chương trình quét cổng trên máy chủ.</em></p>
<p>Chương trình sẽ quét trong một phạm vi cổng nhất định trên máy chủ xem cổng nào đang hoạt động, cổng nào không hoạt động.</p>
<p>Thiết kế giao diện như hình dưới:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture5.jpg" alt="" width="387" height="273" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-2xl.jpg 1920w"></figure>
<p class="align-center"><em>Hình 5.4: Thiết kế giao diện quét cổng mạng</em></p>
<p>Xử lý sự kiện khi người dùng bấm vào nút <em>btScan </em>như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Anh-chup-man-hinh-2024-12-27-144622.png" alt="" width="1210" height="862" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-144622-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-144622-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-144622-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-144622-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-144622-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-144622-2xl.png 1920w"></figure>
<p>       Trong đoạn mã trên, phương thức <em>isActive(host, port, timeout) </em>dùng để kiểm tra xem cổng <em>port </em>trên máy chủ <em>host </em>có đang hoạt động hay không. Phương thức này sẽ trả về giá trị <em>true </em>nếu chương trình kết nối được với <em>host </em>qua cổng <em>port </em>trong thời gian chờ <em>timeout</em>, ngược lại nó sẽ trả về giá trị <em>false</em>.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture5-3.jpg" alt="" width="318" height="237" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-3-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-3-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-3-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-3-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-3-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-3-2xl.jpg 1920w"></figure>
<p><strong><em>Ví dụ 5-3</em></strong><em>. Viết chương trình theo mô hình Client/Server. Client gửi một xâu lên Server. Server chuyển xâu thành chữ in hoa rồi gửi trả lại cho Client.</em></p>
<p><em>Bước 1</em>: Lập trình phía Server.</p>
<p>- Tạo một project đặt tên là <em>TCP_Server</em>.</p>
<ul>
<li>Trong project này tạo một class và đặt tên là <em>Server</em>.</li>
<li>Viết mã lệnh cho <em>Server </em>như sau:</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Anh-chup-man-hinh-2024-12-27-171323.png" alt="" width="1198" height="922" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171323-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171323-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171323-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171323-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171323-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171323-2xl.png 1920w"></figure>
<p><em>Bước 2</em>: Lập trình phía Client</p>
<ul>
<li>Tạo một project khác đặt tên là <em>TCP_Client</em>.</li>
<li>Trong project này tạo một JFrame Form đặt tên là <em>Client</em>.</li>
<li>Thiết kế giao diện như hình dưới:</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture7.png" alt="" width="406" height="204" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 5.6: Thiết kế giao diện Client xử lý xâu</em></p>
<ul>
<li>Xử lý sự kiện khi người dùng nhấn vào nút <em>Gửi</em>:</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Anh-chup-man-hinh-2024-12-27-171523.png" alt="" width="1193" height="600" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171523-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171523-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171523-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171523-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171523-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-171523-2xl.png 1920w"></figure>
<p><em>Bước 3</em>: Chạy chương trình</p>
<ul>
<li>Chạy Server trước.</li>
<li>Chạy Client sau, nhập dữ liệu và nhấn nút “Gửi”.</li>
<li>Kết quả như hình dưới.</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture7-2.png" alt="" width="352" height="193" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture7-2-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 5.7: Kết quả xử lý xâu bằng máy chủ TCP</em></p>
<p>         Trên đây là một ví dụ đơn giản về kỹ thuật lập trình với giao thức TCP để xử lý xâu. Chúng ta thấy rằng việc xử lý xâu hoàn toàn ở phía Server, còn Client chỉ có nhiệm vụ gửi xâu và đợi kết quả. Việc xử lý xâu như thế nào là hoàn toàn do Server quyết định và một Server có thể xử lý yêu cầu của nhiều Client khác nhau.</p>
<p>          Trong chương trình phía Server chúng ta thấy có vòng lặp <em>while(true)</em>, vòng lặp này không bao giờ dừng trừ khi chúng ta tự tắt chương trình. Việc có vòng lặp này đảm bảo rằng phía Server luôn chạy, nếu không có <em>while(true)</em>chương trình sẽ chỉ phục vụ một lần. Server có thể xử lý yêu cầu từ nhiều Client cùng một lúc.</p>
<p>          Tuy đơn giản, nhưng ví dụ trên đã minh họa đầy đủ các bước thực hiện một giao tiếp mạng bằng giao thức TCP. Chúng ta có thể xử lý các yêu cầu phức tạp hơn ở phía Server hay gửi nhiều yêu cầu hơn ở phía Client. Đó là những kiến thức thuộc kỹ thuật lập trình, hoàn toàn có thể thực hiện được. Và để gửi nhiều dữ liệu hơn ở phía Client, chúng ta cùng xem xét ví dụ phía dưới.</p>
<p><strong><em>          Ví dụ 5-4</em></strong><em>. Viết chương trình theo mô hình Client/Server. Client gửi lên Server hai số thực và một trong bốn phép toán: cộng, trừ, nhân, chia. Server xử lý tính toán theo yêu cầu và gửi trả kết quả.</em></p>
<p><em>    Bước 1</em>: Lập trình phía Client</p>
<ul>
<li>Tạo project đặt tên là <em>TCP_Calculator_Client</em>.</li>
<li>Trong project này tạo một JFrame Form đặt tên là <em>Client</em>.</li>
<li>Thiết kế giao diện cho <em>Client </em>như sau:</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture5-2.jpg" alt="" width="370" height="241" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-2-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-2-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-2-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-2-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-2-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture5-2-2xl.jpg 1920w"></figure>
<p class="align-center"><em>Hình 5.8: Thiết kế giao diện Client xử lý số</em></p>
<ul style="list-style-type: square;">
<li>Xử lý sự kiện người dùng bấm vào nút <em>Tính toán </em>như sau:</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Anh-chup-man-hinh-2024-12-27-172602.png" alt="" width="1195" height="560" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172602-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172602-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172602-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172602-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172602-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172602-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Anh-chup-man-hinh-2024-12-27-172706.png" alt="" width="1198" height="253" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172706-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172706-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172706-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172706-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172706-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172706-2xl.png 1920w"></figure>
<p><em>    Bước 2</em>: Lập trình phía Server</p>
<ul>
<li>Tạo một project đặt tên là <em>TCP_Calculator_Server</em>.</li>
<li>Trong project này tạo một class và đặt tên là <em>Server</em>.</li>
<li>Viết mã lệnh cho <em>Server </em>như sau:</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Anh-chup-man-hinh-2024-12-27-172938.png" alt="" width="830" height="962" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172938-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172938-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172938-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172938-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172938-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-172938-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Anh-chup-man-hinh-2024-12-27-173034-2.png" alt="" width="1254" height="79" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-173034-2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-173034-2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-173034-2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-173034-2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-173034-2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Anh-chup-man-hinh-2024-12-27-173034-2-2xl.png 1920w"></figure>
<p><em>     Bước 3</em>: Chạy chương trình</p>
<ul>
<li>Chạy <em>Server </em>trước.</li>
<li>Chạy <em>Client </em>sau, nhập dữ liệu và nhấn nút <em>Tính toán</em>.</li>
<li>Kết quả như hình dưới.</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/Picture4.png" alt="" width="347" height="246" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/7/responsive/Picture4-2xl.png 1920w"></figure>
<p class="align-center"><em>Hình 5.9: Kết quả xử lý số bằng máy chủ TCP</em></p>
<p>          Trong đoạn mã phía Client, chúng ta thấy việc gửi dữ liệu (<em>n1</em>, <em>n2</em>, <em>operator</em>) lên Server được thực hiện nối tiếp nhau bằng ba câu lệnh <em>println()</em>. Như là một giao ước, phía bên Server cũng sẽ phải nhận liên tiếp ba giá trị này.</p>
<p>          Trong kỹ thuật lập trình mạng, sau khi thiết lập kết nối TCP các máy tính có thể thực hiện nhiều lần việc gửi và nhận dữ liệu. Tuy nhiên, chúng ta cần thiết lập quy tắc trao đổi dữ liệu để sao cho một bên gửi thì bên kia nhận dữ liệu. Việc gửi- nhận này cần phải nhịp nhàng, chính xác.</p>
<p>          Thêm vào đó, thay vì phải gửi liên tiếp ba lần cho ba dữ liệu, chúng ta có thể nối 3 dữ liệu này thành một xâu duy nhất và gửi đi một lần. Phía Server chia tách xâu và xác định lại các dữ liệu cần thiết. Cấu trúc của xâu ghép phải được Client và Server thống nhất với nhau. Giả sử, ở ví dụ trên thay vì thực hiện ghi ba lần liên tiếp lên dòng ra các dữ liệu <em>n1</em>, <em>n2</em>, <em>operator </em>ta chỉ cần nối chúng thành một xâu ngăn cách bởi kí tự đặc biệt và gửi tới máy chủ xâu đó: “<em>n1</em>@<em>n2</em>@<em>operator</em>”.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 4:LỚP INETADDRESS</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/bai-4.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/bai-4.html</id>

        <updated>2024-12-29T11:11:19+07:00</updated>
            <summary>
                <![CDATA[
                    Các thiết bị kết nối tới Internet được gọi là các nút mạng (node). Nếu nút là máy tính chúng ta gọi là host. Mỗi nút hoặc host được phân biệt với nhau bởi các địa chỉ mạng, chúng ta thường gọi là địa chỉ&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Các thiết bị kết nối tới Internet được gọi là các <em>nút mạng </em>(node). Nếu nút là máy tính chúng ta gọi là <em>host</em>. Mỗi nút hoặc host được phân biệt với nhau bởi các địa chỉ mạng, chúng ta thường gọi là địa chỉ IP. Hầu hết địa chỉ IP hiện nay là địa chỉ IPv4 (địa chỉ IP phiên bản 4) có độ dài 4 byte. Mặc dù vậy, nhiều tổ chức và cá nhân đang dần chuyển sang sử dụng địa chỉ IPv6 (địa chỉ IP phiên bản 6) có độ dài 16 byte. Cả địa chỉ IPv4 và IPv6 đều bao gồm các byte được sắp thứ tự nhất định (có thể coi đó là một mảng các byte) nhưng chúng thực tế không phải là số.</p>
<p>     Một địa chỉ IPv4 gồm 4 byte, mỗi byte thường được kí hiệu bằng một số nguyên dương có giá trị nằm trong khoảng từ 0 tới 255. Các byte được ngăn các bởi các dấu chấm để cho chúng ta dễ nhận ra chúng. Ví dụ, địa chỉ IP của trang <em>utb.edu.vn </em>là 117.6.86.168. Cách kí hiệu này thuật ngữ tiếng Anh gọi là định dạng <em>dotted quad</em>.</p>
<p>Một địa chỉ IPv6 thường được kí hiệu bởi 8 nhóm cách nhau bởi dấu hai chấm, trong đó mỗi nhóm gồm 4 số thập lục phân. Ví dụ, địa chỉ IP của trang <a href="http://www.hamiltonweather.tk/"><em>www.hamiltonweather.tk</em></a><em> </em>là 2400:cb00:2048:0001:0000:0000:6ca2:c665. Những số</p>
<p>0 ở đầu mỗi nhóm có thể bỏ đi, do đó địa chỉ trên đây có thể viết là</p>
<p>2400:cb00:2048:1:0:0:6ca2:c665. Nếu trong địa chỉ IPv6 có một dãy các nhóm gồm toàn con số 0, chúng ta có thể dùng hai dấu hai chấm để kí hiệu thay thế. Ví dụ, địa chỉ 2001:4860:4860:0000:0000:0000:0000:8888 có thể được viết ngắn gọn là 2001:4860:4860::8888. Một cách viết địa chỉ IPv6 khác là kết hợp với cách viết địa chỉ IPv4 bằng cách viết 4 byte cuối của địa chỉ IPv6 dưới dạng địa chỉ IPv4. Ví dụ, địa chỉ FEDC:BA98:7654:3210:FEDC:BA98:7654:3210 có thể được viết là FEDC:BA98:7654:3210:FEDC:BA98:118.84.50.16.</p>
<p>       Địa chỉ IP rất tiện lợi cho máy tính nhưng gây khó khăn cho con người trong việc ghi nhớ chúng. Vào những năm 50 của thế kỉ XX, G. A. Miller đã khám phá ra hầu hết mọi người có thể ghi nhớ một số có bảy chữ số; một vài người có thể nhớ nhiều hơn chín chữ số và một số người không thể nhớ quá năm chữ số. Chi tiết bạn đọc có thể tìm hiểu bài viết “<em>The Magical Number Seven, Plus or Minus Two: Some Limits on Our Capacity for Processing Information</em>” trong cuốn <em>Psychological Review</em>, tập 63, trang 81-97. Điều đó giải thích tại sao số điện thoại chúng ta thường chia thành các nhóm ba hoặc bốn số và bổ sung thêm mã vùng để giảm bớt các con số cần phải ghi nhớ trong mỗi nhóm. Do đó, một địa chỉ IPv4 có thể có tới mười hai chữ số là quá khó khăn cho hầu hết chúng ta để ghi nhớ chúng.</p>
<p>Để giúp chúng ta dễ dàng hơn trong việc ghi nhớ các địa chỉ mạng, các nhà thiết kế Internet đã phát minh ra các hệ thống DNS - Domain Name System (hệ thống máy chủ tên miền). DNS giúp chúng ta thay thế các kí hiệu theo dãy số bằng những chuỗi kí tự dễ nhớ hơn với con người, chúng ta gọi chúng là <em>hostname</em>. Ví dụ, thay vì phải nhớ địa chỉ 117.6.86.168 chúng ta có thể nhớ địa chỉ <em>utb.edu.vn</em>. Mỗi một máy chủ phải có ít nhất một hostname. Máy khách cũng thường có một hostname nhưng không có một địa chỉ IP cố định nếu IP này được cấp phát lại sau mỗi lần khởi động.</p>
<p>       Một số thiết bị có thể có nhiều tên. Ví dụ, cả <em>tbit.vn </em>và <em>tuhoctin.net </em>đều nằm trên một máy chủ Linux. Cái tên <em>tbit.vn </em>thực tế chỉ tới một website chứ không phải là tên một máy chủ cụ thể nào đó. Trong quá khứ, khi một website được chuyển từ một máy chủ tới một máy chủ khác thì tên của nó sẽ được gán lại trên máy chủ mới để luôn trỏ về website trên máy chủ hiện tại.</p>
<p>        Có những trường hợp một tên có thể tương ứng với nhiều địa chỉ IP. Khi đó, máy chủ nào được lựa chọn để phản hồi yêu cầu từ người dùng sẽ được máy chủ DNS lựa chọn ngẫu nhiên. Tính năng này thường được sử dụng với những website có lượng truy cập rất lớn nên cần mở rộng hệ thống theo chiều ngang để phân chia lượng người dùng tới nhiều hệ thống máy chủ khác nhau. Ví dụ, tên miền <em>google.com.vn </em>thường trỏ tới nhiều máy chủ có địa chỉ khác nhau và thay đổi theo từng thời điểm.</p>
<p>        Tất cả máy tính kết nối tới Internet đều truy cập một thiết bị gọi là <em>máy chủ dịch vụ tên miền </em>(máy chủ DNS). Đây là máy chủ thực hiện ánh xạ giữa tên miền và địa chỉ IP. Hầu hết máy chủ DNS chỉ biết những địa chỉ của những máy tính trong mạng cục bộ của mình và một số ít địa chỉ trên một mạng khác. Nếu máy khách yêu cầu địa chỉ của một máy nằm bên ngoài mạng cục bộ, máy chủ DNS của mạng cục bộ sẽ gửi yêu cầu tới một máy chủ DNS tại mạng khác đợi trả lời để phản hồi lại yêu cầu đó.</p>
<p>        Hầu như mọi lúc chúng ta có thể sử dụng hostname và đợi máy chủ DNS xử lý trả lại địa chỉ IP. Khi nào kết nối tới máy chủ DNS, chúng ta không cần lo lắng về việc làm thế nào để có thể ánh xạ giữa tên và địa chỉ IP trên máy chủ DNS cục bộ hay các bộ phận khác trên Internet. Mặc dù vậy, chúng ta cần truy cập ít nhất một máy chủ DNS nếu muốn thực hành một số ví dụ trong giáo trình này. Một số ví dụ cần phải kết nối Internet chứ không làm việc trên một máy độc lập được.</p>
<p>       Lớp <em>java.net.InetAddress </em>là một sự biểu diễn bậc cao của địa chỉ IP, bao gồm cả IPv4 và IPv6. Lớp này được dùng trong hầu hết các lớp khác như <em>Socket</em>, <em>ServerSocket</em>, <em>URL</em>, <em>DatagramSocket</em>, <em>DatagramPacket</em>… <em>InetAddress </em>cũng bao gồm các thông tin cả về hostname và địa chỉ IP.</p>
<p>      4.3/ Tìm kiếm bằng địa chỉ IP</p>
<p>          Khi chúng ta gọi phương thức <em>getByName() </em>với tham số là một địa chỉ IP, nó sẽ tạo ra một đối tượng <em>InetAddress </em>tương ứng với địa chỉ IP mà không kiểm tra DNS. Điều đó có nghĩa là nó có thể tạo một đối tượng <em>InetAddress </em>cho một host không thực sự tồn tại và chúng ta không thể kết nối tới nó. <em>Hostname </em>của đối tượng <em>InetAddress </em>đã tạo ra từ một xâu chứa địa chỉ IP được khởi tạo từ chính xâu đó. Một truy vấn DNS chỉ thực sự diễn ra khi có yêu cầu hostname từ đối tượng đó hoặc là qua phương thức <em>getHostName()</em>. Như vậy thì <em>tbit.vn </em>được xác định từ địa chỉ IP 45.117.83.115 như thế nào. Nếu tại thời điểm hostname được yêu cầu và một tìm kiếm DNS được thực hiện, host tương ứng với địa chỉ IP không thể được tìm thấy thì hostname được gán là chuỗi IP được khai báo. Bẫy lỗi <em>UnknownHostException </em>không được thực hiện.</p>
<p>    Hostname có tính ổn định hơn nhiều so với địa chỉ IP. Một số dịch vụ có thể chạy trên một hostname nhiều năm nhưng đổi địa chỉ IP nhiều lần. Nêu được lựa chọn giữa hostname và IP thì chúng ta nên chọn hostname, chỉ lựa chọn IP khi hostname không có sẵn.</p>
<p>       4.4/Các phương thức Get</p>
<p>         Lớp <em>InetAddress </em>chứa bốn phương thức Get để trả lại chuỗi hostname, địa chỉ IP cả dưới dạng chuỗi và dạng mảng byte.</p>
<p>public String getHostName()</p>
<p>public String getCanonicalHostName() public byte[] getAddress()</p>
<p>public String getHostAddress()</p>
<p>     Không có các phương thức <em>setHostName() </em>và <em>setAddress() </em>tương ứng, có nghĩa là chúng ta không thể thay đổi các trường đó từ bên ngoài gói <em>java.net</em>. Điều đó giúp cho <em>InetAddress </em>được bảo vệ tốt hơn.</p>
<p>      Phương thức <em>getHostName() </em>trả về một xâu chứa tên của host với địa chỉ IP được đại diện cho đối tượng <em>InetAddress</em>. Nếu thiết bị tương ứng không có hostname hoặc bị ngăn chặn vì vấn đề bảo mật thì phương thức này sẽ trả về xâu địa chỉ IP. Ví dụ:</p>
<p>InetAddress machine = InetAddress.getLocalHost(); String localhost = machine.getHostName();</p>
<p>Phương thức <em>getCanonicalHostName() </em>tương tự phương thức trên nhưng nó mạnh hơn một chút trong việc truy vấn DNS. Phương thức <em>getHostName() </em>chỉ thực hiện gọi DNS khi nó không chắc chắn về hostname. Trong khi đó phương thức <em>getCanonicalHostName() </em>gọi DNS khi nó có thể và có thể sẽ thay thế các kết quả trước đó về việc tìm hostname. Ví dụ:</p>
<p>InetAddress machine = InetAddress.getLocalHost();</p>
<p>String localhost = machine.getCanonicalHostName();</p>
<p>Phương thức <em>getCanonicalHostName() </em>hữu ích khi bắt đầu với một địa chỉ IP thay vì hostname. Trong ví dụ ở dưới, địa chỉ IP 45.117.83.115 được dùng để tạo một InetAddress thông qua phương thức <em>getByName() </em>và sau đó phương thức <em>getCanonicalHostName() </em>sẽ được dùng để lấy được hostname.</p>
<p><strong><em>Ví dụ 4-3</em></strong><em>. Cho địa chỉ, tìm tên miền (tên host).</em></p>
<p>import java.net.*;</p>
<p>public class ReverseTest {</p>
<p>public static void main (String[] args) throws UnknownHostException</p>
<p>{</p>
<p>InetAddress ia = InetAddress.getByName("98.138.219.231"); System.out.println(ia.getCanonicalHostName());</p>
<p>}</p>
<p>}</p>
<p>Kết quả sẽ trả về (tại thời điểm viết):</p>
<p>% java ReverseTest</p>
<p>media-router-fp1.prod1.media.vip.ne1.yahoo.com</p>
<p>         Phương thức <em>getHostAddress() </em>sẽ trả về một xâu chứa địa chỉ IP tương ứng. Ví dụ bên dưới là một ví dụ về việc sử dụng phương thức này.</p>
<p><strong><em>Ví dụ 4-4</em></strong><em>. Tìm địa chỉ IP của máy cục bộ</em></p>
<p>import java.net.*; public class MyAddress {</p>
<p>public static void main(String[] args) { try {</p>
<p>InetAddress me = InetAddress.getLocalHost(); String dottedQuad = me.getHostAddress();</p>
<p>System.out.println("Địa chỉ máy cục bộ: " + dottedQuad);</p>
<p>} catch (UnknownHostException ex) { System.out.println("Không tìm thấy kết quả.");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>     Kết quả (khác nhau trên các máy khác nhau kết nối tới các mạng khác nhau):</p>
<p>% <strong>java MyAddress</strong></p>
<p>Địa chỉ máy cục bộ: 192.168.1.21</p>
<p>        Tất nhiên là địa chỉ IP ở kết quả trên phụ thuộc vào nơi mà đoạn mã được thực thi.</p>
<p>         Nếu muốn biết địa chỉ IP của một máy (hiếm khi dùng) thì chúng ta sử dụng phương thức <em>getAddress(). </em>Phương thức này sẽ trả về một mảng kiểu byte biểu diễn địa chỉ IP của máy. Byte quan trọng nhất (hay byte đầu tiên trong địa chỉ IP) là byte đầu tiên. Nếu muốn biết chiều dài của mảng, hãy sử dụng thuộc tính <em>length </em>của mảng (sử dụng để kiểm tra loại địa chỉ IPv4 hoặc IPv6).</p>
<p>InetAddress me = InetAddress.getLocalHost();</p>
<p>byte[] address = me.getAddress();</p>
<p>        Chúng ta biết là địa chỉ IP được biểu diễn số nguyên không dấu. Nhưng không giống ngôn ngữ C, kiểu <em>byte </em>của Java có phạm vi từ -128 đến 127. Có nghĩa là những số lớn hơn 127 là những số âm trong kiểu <em>byte </em>của Java. Do đó, nếu muốn sử dụng kết quả kiểu <em>byte </em>được trả về bởi phương thức <em>getAddress() </em>để làm gì đó, chúng ta cần chuyển kiểu <em>byte </em>sang kiểu <em>int </em>bằng cách điều chỉnh thích hợp. Ví dụ như sau:</p>
<p>int unsignedByte = signedByte &lt; 0 ? signedByte + 256 : signedByte;</p>
<p>        Trong ví dụ trên, <em>signedByte </em>có thể âm hoặc dương. Phép toán điều kiện <em>? </em>sẽ kiểm tra xem nó có âm hay không. Nếu âm, nó sẽ được cộng với 256 để trở thành số dương kiểu <em>byte </em>và ngược lại thì giữ nguyên.</p>
<p>         Một lý do để sử dụng mảng <em>byte </em>trả về bởi phương thức <em>getAddress() </em>là để xác định loại địa chỉ IPv4 hay IPv6.</p>
<p><strong><em>    Ví dụ 4-5</em></strong><em>. Xác định địa chỉ IP v4 hay v6.</em></p>
<p>import java.net.*;</p>
<p>public class AddressTests {</p>
<p>public static int getVersion(InetAddress ia) { byte[] address = ia.getAddress();</p>
<p>if (address.length == 4) return 4;</p>
<p>else if (address.length == 16) return 6; else return -1;</p>
<p>}</p>
<p>}</p>
<p>        4.5/ Kiểm tra loại địa chỉ</p>
<p>Một số địa chỉ IP và một số dải địa chỉ IP có ý nghĩa đặc biệt. Ví dụ, địa chỉ 127.0.0.1 luôn là địa chỉ loopback. Địa chỉ loopback, còn gọi là localhost, là địa chỉ trỏ chính máy hiện tại. Địa chỉ IPv4 trong phạm vi 224.0.0.0 tới 239.255.255.255 là địa chỉ multicast dùng để gửi thông điệp tới nhiều host cùng lúc. Java có 10 phương thức dùng để xác định các loại địa chỉ đặc biệt.</p>
<ul>
<li><em>public boolean <strong>isAnyLocalAddress</strong>()</em></li>
<li><em>public boolean <strong>isLoopbackAddress</strong>()</em></li>
<li><em>public boolean <strong>isLinkLocalAddress</strong>()</em></li>
<li><em>public boolean <strong>isSiteLocalAddress</strong>()</em></li>
<li><em>public boolean <strong>isMulticastAddress</strong>()</em></li>
<li><em>public boolean <strong>isMCGlobal</strong>()</em></li>
<li><em>public boolean <strong>isMCNodeLocal</strong>()</em></li>
<li><em>public boolean <strong>isMCLinkLocal</strong>()</em></li>
<li><em>public boolean <strong>isMCSiteLocal</strong>()</em></li>
<li><em>public boolean <strong>isMCOrgLocal</strong>()</em></li>
</ul>
<p>       Phương thức <em>isAnyLocalAddress() </em>trả về giá trị true nếu địa chỉ là địa chỉ <em>wildcard</em>, ngược lại trả về giá trị false. Địa chỉ <em>wildcard </em>khớp với bất kỳ địa chỉ nào trên hệ thống mạng cục bộ. Điều này sẽ quan trọng khi một hệ thống có nhiều giao diện mạng, như trường hợp hệ thống máy tính có nhiều card Ethernet và/hoặc card WiFi 802.11. Trong IPv4, địa chỉ wildcard là 0.0.0.0. Trong IPv6, địa chỉ wildcard là 0:0:0:0:0:0:0:0 (hoặc kí hiệu là ∷).</p>
<p>        Phương thức <em>isLinkLocalAddress() </em>trả về giá trị true nếu địa chỉ này là một địa chỉ IPv6 dạng link-local. Đây là một địa chỉ giúp mạng IPv6 tự cấu hình, giống như DHCP trong mạng IPv4 nhưng không nhất thiết phải dùng một Server trong mạng này. Tất cả địa chỉ dạng link-local đều bắt đầu bởi tám byte FE00:0000:0000:0000. Tám byte tiếp theo là địa chỉ cục bộ, thường được sao chép thừ địa chỉ Ethernet MAC được gán bởi nhà sản xuất thiết bị mạng.</p>
<p>         Phương thức <em>isSiteLocalAddress() </em>trả về giá trị true nếu một địa chỉ IPv6 là địa chỉ site-local. Địa chỉ loại này bắt đầu bởi tám byte FEC0:0000:0000:0000. Tám byte tiếp theo cũng được sao chép từ địa chỉ Ethernet MAC.</p>
<p>         Phương thức <em>isMulticastAddress() </em>trả về giá trị true nếu địa chỉ là multicast. Những máy có địa chỉ này sẽ gửi nội dung quảng bá tới một số nhất định các máy khác đã đăng kí thay vì chỉ gửi cho một máy nhất định. Trong IPv4, dải địa chỉ multicast từ 224.0.0.0 đến 239.255.255.255. Trong IPv6, chúng luôn được bắt đầu bởi FF.</p>
<p>          Phương thức <em>isMCGlobal() </em>trả về giá trị true nếu địa chỉ này là địa chỉ multicast toàn cục (global). Địa chỉ multicast toàn cục sẽ quảng bá tới các máy đăng kí trên toàn bộ hệ thống mạng toàn cầu. Tất cả địa chỉ loại này đều bắt đầu bằng FE. Trong IPv6, chúng bắt đầu bởi FF0E hoặc FF1E phụ thuộc vào việc đó là địa chỉ multicast vĩnh viễn hoặc tạm thời. Trong IPv4, tất cả địa chỉ IPv4 đều có phạm vi toàn cầu.</p>
<p>          Phương thức <em>isMCOrgLocal() </em>trả về giá trị true nếu nó là địa chỉ dạng multicast tổ chức. Địa chỉ multicast loại này là địa chỉ multicast mà tất cả các máy đăng kí thuộc trong cùng một cơ quan, tổ chức chứ không có máy từ bên ngoài. Địa chỉ loại này bắt đầu bưởi FF08 hoặc FF18 phụ thuộc vào địa chỉ multicast là vĩnh viễn hoặc tạm thời.</p>
<p>          Phương thức <em>isMCSiteLocal() </em>trả về giá trị true nếu nó là địa chỉ dạng multicast site-wide. Những packet tới máy có địa chỉ loại này chỉ được truyền trong mạng cục bộ của nó. Địa chỉ loại này bắt đầu bưởi FF05 hoặc FF15 phụ thuộc vào địa chỉ multicast là vĩnh viễn hoặc tạm thời.</p>
<p>          Phương thức <em>isMCLinkLocal() </em>trả về giá trị true nếu nó là địa chỉ multicast subnet-wide. Packet tới địa chỉ loại này chỉ được truyền trong nội bộ mạng con (subnet). Địa chỉ loại này bắt đầu bưởi FF02 hoặc FF12 phụ thuộc vào địa chỉ multicast là vĩnh viễn hoặc tạm thời.</p>
<p>          Phương thức <em>isMCNodeLocal() </em>trả về giá trị true nếu nó là địa chỉ multicast dạng interface-local. Packet tới địa chỉ loại này không thể truyền ra khỏi giao diện mạng của nó, thậm chí không thể tới một giao diện mạng khác trong cùng node. Địa chỉ loại này bắt đầu bởi FF01 hoặc FF11 phụ thuộc vào địa chỉ multicast là vĩnh viễn hoặc tạm thời.</p>
<p><em>     Ví dụ 4-6 </em>sau đây là một chương trình đơn giản để kiểm tra địa chỉ nhập trực tiếp từ cửa sổ lệnh dùng 10 phương thức trên.</p>
<p><strong><em>  Ví dụ 4-6</em></strong><em>. Kiểm tra địa chỉ IP đặc trưng</em></p>
<p>import java.net.*;</p>
<p> </p>
<p>public class <strong>IPCharacteristics </strong>{</p>
<p> </p>
<p>public static void main(String[] args) { try {</p>
<p>InetAddress address = InetAddress.getByName(args[0]); if (address.isAnyLocalAddress()) {</p>
<p>System.out.println(address + " là địa chỉ wildcard.");</p>
<p>}</p>
<p>if (address.isLoopbackAddress()) { System.out.println(address + " là địa chỉ loopback.");</p>
<p>}</p>
<p>if (address.isLinkLocalAddress()) { System.out.println(address + " là địa chỉ link-local.");</p>
<p>} else if (address.isSiteLocalAddress()) { System.out.println(address + " là địa chỉ site-local.");</p>
<p>} else {</p>
<p>System.out.println(address + " là địa chỉ toàn cục.");</p>
<p>}</p>
<p>if (address.isMulticastAddress()) { if (address.isMCGlobal()) {</p>
<p>System.out.println(address + " là địa chỉ multicast toàn cục.");</p>
<p>} else if (address.isMCOrgLocal()) {</p>
<p>System.out.println(address + " là địa chỉ multicast tổ chức.");</p>
<p>} else if (address.isMCSiteLocal()) {</p>
<p>System.out.println(address + " là địa chỉ multicast site-wide.");</p>
<p>} else if (address.isMCLinkLocal()) {</p>
<p>System.out.println(address + " là địa chỉ multicast subnet-wide.");</p>
<p>} else if (address.isMCNodeLocal()) {</p>
<p>System.out.println(address + " là địa chỉ multicast interface-local.");</p>
<p>} else {</p>
<p>System.out.println(address + " là địa chỉ multicast</p>
<p>chưa xác định.");</p>
<p>}</p>
<p>} else {</p>
<p>System.out.println(address + " là địa chỉ unicast.");</p>
<p>}</p>
<p>} catch (UnknownHostException ex) { System.err.println("Không phân tích được địa chỉ này.");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>     Dưới đây là một số kết quả khi chạy đoạn mã trên với các địa chỉ IPv4 và IPv6 khác nhau.</p>
<p><strong>$ java IPCharacteristics 127.0.0.1</strong></p>
<p>/127.0.0.1 là địa chỉ loopback.</p>
<p>/127.0.0.1 là địa chỉ toàn cục.</p>
<p>/127.0.0.1 là địa chỉ unicast.</p>
<p><strong>$ java IPCharacteristics 192.168.254.32</strong></p>
<p>/192.168.254.32 là địa chỉ multicast site-wide.</p>
<p>/192.168.254.32 là địa chỉ unicast.</p>
<p><strong>$ java IPCharacteristics </strong><a href="http://www.oreilly.com/"><strong>www.oreilly.com</strong></a><strong> </strong><a href="http://www.oreilly.com/208.201.239.37">www.oreilly.com/208.201.239.37</a> là địa chỉ toàn cục. <a href="http://www.oreilly.com/208.201.239.37">www.oreilly.com/208.201.239.37</a> là địa chỉ unicast.</p>
<p><strong>$ java IPCharacteristics 224.0.2.1</strong></p>
<p>/224.0.2.1 là địa chỉ toàn cục.</p>
<p>/224.0.2.1 là địa chỉ multicast toàn cục.</p>
<p><strong>$ java IPCharacteristics FF01:0:0:0:0:0:0:1</strong></p>
<p>/ff01:0:0:0:0:0:0:1 là địa chỉ toàn cục.</p>
<p>/ff01:0:0:0:0:0:0:1 là địa chỉ multicast interface-local.</p>
<p><strong>$ java IPCharacteristics FF05:0:0:0:0:0:0:101</strong></p>
<p>/ff05:0:0:0:0:0:0:101 là địa chỉ toàn cục.</p>
<p>/ff05:0:0:0:0:0:0:101 là địa chỉ multicast site-wide.</p>
<p><strong>$ java IPCharacteristics 0::1</strong></p>
<p>/0:0:0:0:0:0:0:1 là địa chỉ loopback.</p>
<p>/0:0:0:0:0:0:0:1 là địa chỉ toàn cục.</p>
<p>/0:0:0:0:0:0:0:1 là địa chỉ unicast.</p>
<p>      4.6/ Kiểm tra khả năng kết nối tốt(reachable)</p>
<p>             Lớp <em>InetAddress </em>có hai phương thức <em>isReachable() </em>để kiểm tra xem một nút mạng cụ thể có kết nối từ host hiện tại được không. Kết nối có thể bị khóa vì rất nhiều lí do, có thể là firewall, máy chủ proxy, đứt cáp hay host không hoạt động tại thời điểm chúng ta thử kết nối.</p>
<p>public boolean <strong>isReachable</strong>(int timeout) throws IOException</p>
<p>public boolean <strong>isReachable</strong>(NetworkInterface interface, int ttl, int timeout) throws IOException</p>
<p>      Hai phương thức này sử dụng công cụ truy vết <em>traceroute </em>để chỉ ra một địa chỉ có phản hồi hay không. Nếu host được kiểm tra trả lời trong thời gian <em>timeout </em>tính bằng mili giây, phương thức sẽ trả về giá trị <em>true </em>và ngược lại trả về giá trị <em>false</em>. Ngoại lệ <em>IOException </em>sẽ được gọi nếu xảy ra một lỗi mạng. Phương thức thứ hai có thể tham số <em>NetworkInterface </em>để chỉ định giao diện mạng được sử dụng và thời gian tồn tại <em>ttl </em>(time-to-live) là giá trị số lớn nhất xác định thời gian kết nối trước khi nó bị bỏ qua.</p>
<p>     4.7/ Các phương thức Object</p>
<p>        Giống như những lớp khác trong Java, <em>java.net.InetAddress </em>kế thừa từ lớp <em>java.lang.Object</em>. Vì vậy, lớp này cũng kế thừa tất cả các phương thức của lớp này. Lớp <em>InetAddress </em>override ba phương thức sau:</p>
<ul>
<li><em>public boolean <strong>equals</strong>(Object o)</em></li>
<li><em>public int <strong>hashCode</strong>()</em></li>
<li><em>public String <strong>toString</strong>()</em></li>
</ul>
<p>Hai object của lớp <em>InetAddress </em>bằng nhau nếu chúng có cùng địa chỉ IP. Ví dụ, một object <em>InetAddress </em>cho <em>tbit.vn </em>sẽ bằng với một object cho <em>tuhoctin.net </em>vì cả hai tên miền này đều được trỏ về địa chỉ một địa chỉ IP. <em>Ví dụ 4-7 </em>sẽ tạo các object tương ứng với hai tên miền này và sẽ cho chúng ta biết chúng cùng một địa chỉ IP nếu không có gì thay đổi.</p>
<p><strong><em>Ví dụ 4-7</em></strong><em>. Kiểm tra <strong>tbit.vn </strong>và <strong>tuhoctin.net </strong>có cùng địa chỉ IP không?</em></p>
<p>import java.net.*;</p>
<p> </p>
<p>public class <strong>IBiblioAliases </strong>{</p>
<p>public static void main(String args[]) { try {</p>
<p>InetAddress ibiblio = InetAddress.getByName("tbit.vn"); InetAddress helios = InetAddress.getByName("tuhoctin.net"); if (ibiblio.equals(helios)) {</p>
<p>System.out.println("tbit.vn thuộc cùng máy chủ với tuhoctin.net");</p>
<p>} else {</p>
<p>System.out.println("tbit.vn không thuộc cùng máy chủ với tuhoctin.net");</p>
<p>}</p>
<p>} catch (UnknownHostException ex) { System.out.println("Không tìm thấy host tương ứng.");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>     Kết quả chạy đoạn code trên tại thời điểm viết tài liệu này:</p>
<p><strong>% java IBiblioAliases</strong></p>
<p>tbit.vn thuộc cùng máy chủ với tuhoctin.net</p>
<p>       Phương thức <em>hashcode() </em>trả về một số nguyên tương ứng với địa chỉ IP. Nếu hai object <em>InetAddress </em>cùng địa chỉ IP, chúng sẽ cùng mã hash code, mặc dù hostname có thể khác nhau.</p>
<p>        Phương thức <em>toString() </em>trả về một đoạn văn bản ngắn mô tả object. <em>Ví dụ 4- 1 </em>và <em>Ví dụ 4-2 </em>đã thực hiện gọi phương thức này. Kết quả trả về của nó dạng:</p>
<p>hostname/địa chỉ IP</p>
<p>         Không phải tất cả object <em>InetAddress </em>đều có hostname. Nếu chúng không có hostname, địa chỉ IP sẽ được dùng thay thế trong phiên bản Java 1.3 trở về trước, còn đối với Java 1.4 trở về sau nó sẽ trả về một xâu rỗng.</p>
<p>       4.8/InetAddress và Inet6Address</p>
<p>        Java sử dụng hai lớp <em>Inet4Address </em>và <em>Inet6Address </em>để phân biệt địa chỉ IPv4 và địa chỉ IPv6.</p>
<ul>
<li><em>public final class <strong>Inet4Address </strong>extends InetAddress</em></li>
<li><em>public final class <strong>Inet6Address </strong>extends InetAddress</em></li>
</ul>
<p>        Hầu hết mọi khi, chúng ta không thực sự nên quan tâm tới địa chỉ IPv4 hay IPv6. Trong tầng ứng dụng, chúng ta không cần phải biết về điều đó. Nhưng cũng có nhiều khi chúng ta cần chúng để làm mọi việc nhanh hơn. Lớp <em>Inet4Address </em>override nhiều phương thức của lớp <em>InetAddress </em>không thay đổi tới các phương thức <em>public</em>. Lớp <em>Inet6Address </em>cũng tương tự nhưng nó thêm một phương thức không có trong lớp cha:</p>
<p><em>public boolean <strong>isIPv4CompatibleAddress</strong>()</em></p>
<p>        Phương thức này trả về giá trị đúng nếu và chỉ nếu đó là một địa chỉ IPv4 có thể nằm trong một IPv6, có nghĩa là chỉ có 4 byte cuối là khác không. Do đó, địa chỉ IP sẽ có dạng 0:0:0:0:0:0:0:xxxx. Trong trường hợp này chúng ta cũng có thể tách lấy bốn byte cuối cùng từ phương thức <em>getBytes() </em>để tạo ra một object <em>Inet4Address</em>. Tuy nhiên chúng ta hiếm khi thực hiện điều này.</p>
<p>      4.9/ Lớp Network Interface</p>
<p>           Lớp <em>NetwordInterface </em>đại diện cho một địa chỉ IP cục bộ. Nó có thể là một giao diện mạng vật lý như một card Ethernet bổ sung (firewall hoặc router) hay một giao diện mạng ảo của cùng một thiết bị phần cứng với một địa chỉ IP khác. Lớp <em>NetworkInterface </em>liệt kê tất cả các địa chỉ cục bộ và tạo ra các object <em>InetAddress </em>tương ứng. Những object đó sẽ được dùng để tạo socket cho Client hoặc Server.</p>
<h3>        Một số phương thức</h3>
<p>           Vì object <em>NetworkInterface </em>đại diện cho một phần cứng vật lý hoặc địa chỉ mạng ảo nên có không được khởi tạo một cách tùy tiện. Giống như lớp <em>InetAddress</em>, có một số phương thức dùng để tạo ra object <em>NetworkInterface </em>với từng giao diện mạng cụ thể. Chúng ta có thể tạo object <em>NetworkInterface </em>từ một địa chỉ IP, từ hostname hoặc enumeration.</p>
<p><em>public static NetworkInterface <strong>getByName</strong>(String name) throws SocketException</em></p>
<p>            Phương thức <em>getByName() </em>trả về một object <em>NetworkInterface </em>từ một tên cụ thể. Nếu không có một giao diện mạng nào tương ứng, nó sẽ trả về giá trị <em>null</em>. Rất hiếm khi xảy ra lỗi, nhưng nếu có chúng sẽ được xử lý bởi <em>SocketException</em>.</p>
<p>             Định dạng tên phụ thuộc vào hệ điều hành. Trên các dòng hệ điều hành Unix, tên của các giao diện Ethernet có dạng eth0, eth1,… Địa chỉ <em>loopback </em>có tên dạng “lo”. Trên dòng hệ điều hành Windows, tên là chuỗi dạng “CE31” và “ELX100” phụ thuộc vào tên của Nhà sản xuất và dòng sản phẩm phần cứng gắn với giao diện mạng. Dưới đây là ví dụ về thao tác với <em>NetworkInterface </em>với dòng hệ điều hành Unix:</p>
<p>try {</p>
<p>NetworkInterface ni = NetworkInterface.getByName("eth0"); if (ni == null) {</p>
<p>System.err.println("No such interface: eth0");</p>
<p>}</p>
<p>} catch (SocketException ex) { System.err.println("Could not list sockets.");</p>
<p>}</p>
<p><em>         public static NetworkInterface <strong>getByInetAddress</strong>(InetAddress address) throws SocketException</em></p>
<p>             Phương thức <em>getByInetAddress() </em>trả về một object <em>NetworkInterface </em>tương ứng với một địa chỉ IP cụ thể. Nếu không có giao diện mạng nào tương ứng tại máy cục bộ, nó sẽ trả về giáo trị <em>null</em>. Nếu có lỗi nào đó, nó sẽ throws <em>SocketException</em>. Dưới đây là một ví dụ tìm một giao diện mạng tương ứng với địa chỉ loopback:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/Anh-chup-man-hinh-2024-12-26-150447.png" alt="" width="1211" height="395" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150447-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150447-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150447-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150447-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150447-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150447-2xl.png 1920w"></figure>
<p><em>public static Enumeration <strong>getNetworkInterfaces</strong>() throws SocketException</em></p>
<p>          Phương thức <em>getNetworkInterfaces() </em>trả về một đối tượng thuộc lớp <em>java.util.Enumeration </em>liệt kê tất cả các giao diện mạng trên máy cục bộ. <em>Ví dụ 4-8 </em>là một chương trình đơn giản để liệt kê các giao diện mạng trên máy cục bộ.</p>
<p><strong><em>          Ví dụ 4-8</em></strong><em>. Liệt kê các giao diện mạng của máy cục bộ.</em></p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/Anh-chup-man-hinh-2024-12-26-150602.png" alt="" width="1203" height="401" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150602-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150602-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150602-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150602-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150602-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150602-2xl.png 1920w"></figure>
<p>           Và kết quả với máy có nhiều kết nối mạng sẽ như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/Anh-chup-man-hinh-2024-12-26-150632.png" alt="" width="1216" height="241" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150632-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150632-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150632-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150632-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150632-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/6/responsive/Anh-chup-man-hinh-2024-12-26-150632-2xl.png 1920w"></figure>
<p>        Trong kết quả trên chúng ta có thể thấy máy tính có 2 kết nối mạng thông qua Ethernet với địa chỉ IP lần lượt là 192.168.210.122 và 152.2.210.122. Địa chỉ loopback cho localhost luôn là 127.0.0.1.</p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 3:LẬP TRÌNH ĐA LUỒNG TRONG JAVA</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/bai-3.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/bai-3.html</id>

        <updated>2024-12-29T11:11:12+07:00</updated>
            <summary>
                <![CDATA[
                    3.1/Giới thiệu về luồng (thread) Thread (luồng) về cơ bản là một tiến trình con (sub-process). Một đơn vị xử lý nhỏ nhất của máy tính có thể thực hiện một công việc riêng biệt. Trong Java, các luồng được quản lý bởi máy ảo&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>3.1/Giới thiệu về luồng (thread)</p>
<p><em>           Thread </em>(luồng) về cơ bản là một tiến trình con (sub-process). Một đơn vị xử lý nhỏ nhất của máy tính có thể thực hiện một công việc riêng biệt. Trong Java, các luồng được quản lý bởi máy ảo Java (JVM).</p>
<p><em>      Multi-thread </em>(đa luồng) là một tiến trình thực hiện nhiều luồng đồng thời. Một ứng dụng Java ngoài luồng chính có thể có các luồng khác thực thi đồng thời làm ứng dụng chạy nhanh và hiệu quả hơn.</p>
<p>Trình duyệt web hay các chương trình chơi nhạc là ví dụ điển hình về đa luồng:</p>
<p>+ Khi duyệt 1 trang web, có rất nhiều hình ảnh, mã CSS, mã JavaScript… được tải đồng thời bởi các luồng khác nhau.</p>
<p>+ Khi đang chơi nhạc, chúng ta vẫn có thể tương tác được với nút điều khiển như: play, pause, next, back … vì luồng phát nhạc là luồng riêng biệt với luồng tiếp nhận tương tác của người dùng.</p>
<p>          3.1.2/Đa nhiệm (multitasking)</p>
<p><em>               Multitasking </em>là khả năng chạy đồng thời một hoặc nhiều chương trình cùng một lúc trên một hệ điều hành. Hệ điều hành quản lý việc này và sắp xếp lịch phù hợp cho các chương trình đó. Ví dụ, trên hệ điều hành Windows chúng ta có làm việc đồng thời với các chương trình khác nhau như: Word, Excel, Chrome, …</p>
<p>      Chúng ta sử dụng đa nhiệm để tận dụng tính năng của CPU. Đa nhiệm có thể đạt được bằng hai cách:</p>
<ol>
<li><em> </em><em>Đa nhiệm dựa trên tiến trình (process) – Đa tiến trình (multiprocessing).</em>
<ul>
<li>Mỗi tiến trình có địa chỉ riêng trong bộ nhớ, tức là mỗi tiến trình được phân bổ vùng nhớ riêng biệt.</li>
<li>Đa nhiệm dựa trên tiến trình là <em>nặng</em>.</li>
<li>Sự giao tiếp giữa các tiến trình có <em>chi phí cao</em>.</li>
<li>Chuyển đổi từ tiến trình này sang tiến trình khác đòi hỏi thời gian để đăng ký việc lưu và tải các bản đồ bộ nhớ, các danh sách cập nhật, …</li>
</ul>
</li>
<li><em> </em><em>Đa nhiệm dựa trên luồng (thread) – Đa luồng (multithreading).</em>
<ul>
<li>Các luồng chia sẻ không gian địa chỉ ô nhớ giống</li>
<li>Đa nhiệm dựa trên luồng là <em>nhẹ</em>.</li>
</ul>
</li>
</ol>
<ul>
<li>Sự giao tiếp giữa các luồng có <em>chi phí thấp</em>.</li>
</ul>
<p>        Đa tiến trình (multiprocessing) và đa luồng (multithreading) đều được sử dụng để tạo ra hệ thống đa nhiệm (multitasking). Nhưng chúng ta sử dụng đa luồng nhiều hơn đa tiến trình bởi vì các luồng chia sẻ một vùng bộ nhớ chung. Chúng không phân bổ vùng bộ nhớ riêng biệt để tiết kiệm bộ nhớ, và chuyển đổi ngữ cảnh giữa các luồng mất ít thời gian hơn giữa các tiến trình.</p>
<p>      3.1.3/ Ưu điểm và nhược điểm đa luồng</p>
<h2>Ưu điểm:</h2>
<ul>
<li>Đa luồng không chặn người sử dụng vì các luồng là độc lập và chúng ta có thể thực hiện nhiều công việc cùng một lúc.</li>
<li>Mỗi luồng có thể dùng chung và chia sẻ nguồn tài nguyên trong quá trình chạy, nhưng có thể thực hiện một cách độc lập.</li>
<li>Luồng là độc lập vì vậy nó không ảnh hưởng đến luồng khác nếu ngoại lệ xảy ra trong một luồng duy nhất.</li>
<li>Chương trình có thể thực hiện nhiều hoạt động với nhau để tiết kiệm thời gian. Ví dụ một ứng dụng có thể được tách thành: luồng chính chạy giao diện người dùng và các luồng phụ gửi kết quả xử lý đến luồng chính.</li>
</ul>
<h2>Nhược điểm:</h2>
<ul>
<li>Càng nhiều luồng thì xử lý càng phức tạp.</li>
<li>Xử lý vấn đề về tranh chấp bộ nhớ, đồng bộ dữ liệu khá phức tạp.</li>
<li>Cần phát hiện tránh các luồng chết (deadlock) - luồng chạy mà không làm gì trong ứng dụng cả. Deadlock xảy ra khi 2 tiến trình đợi nhau hoàn thành trước khi chạy, kết quả của quá trình là cả 2 tiến trình không bao giờ kết thúc.</li>
</ul>
<p>        3.2/Vòng đời của một luồng trong Java</p>
<p>Vòng đời của luồng trong Java được kiểm soát bởi JVM. Java định nghĩa các trạng thái của luồng trong các thuộc tính <em>static </em>của lớp <em>Thread.State</em>:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/Picture5.jpg" alt="" width="387" height="257" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture5-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture5-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture5-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture5-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture5-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture5-2xl.jpg 1920w"></figure>
<p><strong>NEW</strong>: Đây là trạng thái khi luồng vừa được khởi tạo bằng phương thức khởi tạo của lớp <em>Thread </em>nhưng chưa được <em>start()</em>. Ở trạng thái này, luồng được tạo ra nhưng chưa được cấp phát tài nguyên và cũng chưa chạy. Nếu luồng đang ở trạng thái này mà ta gọi các phương thức ép buộc <em>stop()</em>, <em>resume()</em>, <em>suspend()</em>… sẽ là nguyên nhân xảy ra ngoại lệ <em>IllegalThreadStateException </em>.</p>
<p><strong>RUNNABLE</strong>: Sau khi gọi phương thức <em>start() </em>thì luồng đã được cấp phát tài nguyên và các lịch điều phối CPU cho luồng cũng bắt đầu có hiệu lực. Ở đây, chúng ta dùng trạng thái là <em>Runnable </em>chứ không phải Running, vì luồng không thực sự luôn chạy mà tùy vào hệ thống mà có sự điều phối CPU khác nhau.</p>
<p><strong>BLOCKED</strong>: Đây là 1 dạng của trạng thái <em>Not Runnable</em>. Luồng chờ được unlock mới hoạt động trở lại.</p>
<p><strong>TERMINATED</strong>: Một luồng ở trong trạng thái terminated hoặc dead khi phương thức <em>run() </em>của nó bị thoát.</p>
<p><strong>TIMED WAITING</strong>: Luồng chờ trong một thời gian nhất định, hoặc là có một luồng khác đánh thức nó.</p>
<p><strong>WAITING</strong>: Luồng chờ không giới hạn cho đến khi được một luồng khác đánh thức nó.</p>
<p>       3.3/Cách tạo luồng trong Java<br>             3.3.1/Tạo luồng bằng cách kế thừa từ lớp Thread</p>
<p>          Để tạo luồng bằng cách tạo lớp kế thừa từ lớp <em>Thread</em>, ta phải làm các công việc sau :</p>
<ol>
<li>Khai báo 1 lớp mới kế thừa từ lớp <em>Thread</em>.</li>
<li>Override lại phương thức <em>run() </em>ở lớp này, những gì trong phương thức <em>run() </em>sẽ được thực thi khi luồng bắt đầu chạy. Sau khi luồng chạy xong tất cả các câu lệnh trong phương thức <em>run() </em>thì luồng cũng tự hủy.</li>
<li>Tạo 1 instance (hay 1 đối tượng) của lớp vừa khai báo.</li>
<li>Sau đó gọi phương thức <em>start() </em>của đối tượng này để bắt đầu thực thi luồng.</li>
</ol>
<p>Ví dụ đơn giản về tạo luồng từ lớp <em>Thread</em>:</p>
<p>package vn.tbit.simple;</p>
<p> </p>
<p>public class TheadSimple extends Thread { public void run() {</p>
<p>System.out.println("Thread đang chạy...");</p>
<p>}</p>
<p>public static void main(String args[]) { TheadSimple t1 = new TheadSimple(); t1.start();</p>
<p>}</p>
<p>}</p>
<p>Lưu ý :</p>
<ul>
<li>Tuy khai báo những công việc cần làm của luồng trong phương thức <em>run() </em>nhưng khi thực thi luồng ta phải gọi phương thức <em>start()</em>. Vì đây là phương thức đặc biệt mà Java xây dựng sẵn trong lớp <em>Thread</em>, phương thức này sẽ cấp phát tài nguyên cho luồng mới rồi chạy phương thức <em>run() </em>ở luồng này. Vì vậy, nếu ta gọi phương thức <em>run() </em>mà không gọi <em>start() </em>thì cũng tương đương với việc gọi một phương thức của một đối tượng bình thường và phương thức vẫn chạy trên luồng đã gọi phương thức chứ không chạy ở luồng mới tạo Như vậy, vẫn chỉ có một luồng chính làm việc chứ ứng dụng vẫn không phải là đa luồng.</li>
<li>Sau khi gọi <em>start() </em>một luồng thì không bao giờ có thể gọi <em>start() </em>lại. Nếu làm như vậy, một ngoại lệ <em>IllegalThreadStateException </em>sẽ xảy ra.</li>
</ul>
<p>     3.3.2/Tạo luồng bằng cách hiện thực từ giao diện Runable</p>
<p>           Để tạo luồng bằng cách hiện thực từ <em>Interface Runnable</em>, ta phải làm các công việc sau :</p>
<ol>
<li>Khai báo 1 lớp mới <em>implements </em>từ <em>Interface Runnable</em>.</li>
<li>Hiện thực phương thức <em>run() </em>ở lớp này, những gì trong phương thức <em>run() </em>sẽ được thực thi khi luồng bắt đầu chạy. Sau khi luồng chạy xong tất cả các câu lệnh trong phương thức <em>run() </em>thì luồng cũng tự hủy.</li>
<li>Tạo 1 instance (hay 1 đối tượng) của lớp vừa khai báo, giả sử là <em>r1</em>.</li>
<li>Tạo 1 instance của lớp <em>Thread </em>bằng phương thức khởi tạo <em>Thread(Runnable target) </em>trong đó <em>target </em>là 1 đối tượng thuộc lớp được <em>implements </em>từ giao diện <em>Runnable</em>.</li>
</ol>
<p>         Ví dụ: <em>Thread t1 = new Thread(r1);</em></p>
<p>   5.   Gọi phương thức <em>start() </em>của đối tượng <em>t1</em>. </p>
<p>Ví dụ đơn giản về tạo luồng từ giao diện <em>Runnable</em>:<br><br></p>
<p>package vn.tbit.simple;</p>
<p> </p>
<p>public class RunnableSimple implements Runnable { public void run() {</p>
<p>System.out.println("Thread đang chạy...");</p>
<p>}</p>
<p> </p>
<p>public static void main(String args[]) { RunnableSimple runable = new RunnableSimple(); Thread t1 = new Thread(runable);</p>
<p>t1.start();</p>
<p>}</p>
<p>}</p>
<p>Khi nào <em>implements </em>từ <em>Interface Runnable</em>?</p>
<p>+ Cách hay được sử dụng và được yêu thích là dùng <em>Interface Runnable</em>, bởi vì nó không yêu cầu phải tạo một lớp kế thừa từ lớp <em>Thread</em>. Trong trường hợp ứng dụng thiết kế yêu cầu sử dụng đa kế thừa, chỉ có interface mới có thể giúp giải quyết vấn đề. Ngoài ra nó cũng rất hiệu quả và được cài đặt, sử dụng rất đơn giản.</p>
<p>+ Trong trường hợp còn lại ta có thể kế thừa từ lớp <em>Thread</em>.</p>
<p>      3.4/Ví dụ minh hoạ sử dụng đa luồng</p>
<p><strong><em>Ví dụ 3-1</em></strong><em>. Tạo luồng bằng cách </em><em>extends </em><em>từ lớp </em><em>Thread</em><em>.</em></p>
<p>Tạo lớp <em>extends </em>từ <em>Thread</em>:</p>
<p>package vn.tbit.flow;</p>
<p> </p>
<p>public class ThreadDemo extends Thread { private Thread t;</p>
<p>private String threadName;</p>
<p>ThreadDemo(String name) { threadName = name;</p>
<p>System.out.println("Creating " + threadName);</p>
<p>}</p>
<p> </p>
<p>@Override</p>
<p>public void run() {</p>
<p>System.out.println("Running " + threadName); try {</p>
<p>for (int i = 4; i &gt; 0; i--) {</p>
<p>System.out.println("Thread: " + threadName + ", " + i);</p>
<p>// Thread tạm nghỉ. Thread.sleep(50);</p>
<p>}</p>
<p>} catch (InterruptedException e) {</p>
<p>System.out.println("Thread " + threadName + " interrupted.");</p>
<p>}</p>
<p>System.out.println("Thread " + threadName + " exiting.");</p>
<p>}</p>
<p> </p>
<p>public void start() { System.out.println("Starting " + threadName); if (t == null) {</p>
<p>t = new Thread(this, threadName); t.start();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>         Chương trình sử dụng đa luồng:</p>
<p>package vn.tbit.flow;</p>
<p> </p>
<p>public class ThreadDemoTest {</p>
<p>public static void main(String args[]) { System.out.println("Main thread running... ");</p>
<p> </p>
<p>ThreadDemo T1 = new ThreadDemo("Thread-1-HR-Database"); T1.start();</p>
<p> </p>
<p>ThreadDemo T2 = new ThreadDemo("Thread-2-Send-Email"); T2.start();</p>
<p> </p>
<p>System.out.println("==&gt; Main thread stopped!!! ");</p>
<p>}</p>
<p>}</p>
<p>         Kết quả thực thi chương trình trên:</p>
<p>Main thread running...</p>
<p>Creating Thread-1-HR-Database</p>
<p>Starting Thread-1-HR-Database</p>
<p>Creating Thread-2-Send-Email</p>
<p>Starting Thread-2-Send-Email</p>
<p>==&gt; Main thread stopped!!!</p>
<p>Running Thread-1-HR-Database Running Thread-2-Send-Email Thread: Thread-2-Send-Email, 4</p>
<p>Thread: Thread-1-HR-Database, 4</p>
<p>Thread: Thread-1-HR-Database, 3</p>
<p>Thread: Thread-2-Send-Email, 3</p>
<p>Thread: Thread-2-Send-Email, 2</p>
<p>Thread: Thread-1-HR-Database, 2</p>
<p>Thread: Thread-2-Send-Email, 1</p>
<p>Thread: Thread-1-HR-Database, 1 Thread Thread-2-Send-Email exiting. Thread Thread-1-HR-Database exiting.</p>
<p>           Kết quả chương trình trên được giải thích thông qua hình bên dưới:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/Picture6-3.png" alt="" width="493" height="276" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture6-3-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture6-3-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture6-3-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture6-3-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture6-3-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture6-3-2xl.png 1920w"></figure>
<p><strong><em>Ví dụ 3-2</em></strong><em>. Tạo luồng bằng cách </em><em>implements </em><em>từ giao diện </em><em>Runnable</em><em>.</em></p>
<p>Tạo lớp <em>implements </em>từ giao diện <em>Runnable</em>:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/Anh-chup-man-hinh-2024-12-26-143223-2.png" alt="" width="1209" height="649" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143223-2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143223-2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143223-2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143223-2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143223-2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143223-2-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/Anh-chup-man-hinh-2024-12-26-143332.png" alt="" width="1223" height="580" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143332-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143332-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143332-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143332-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143332-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143332-2xl.png 1920w"></figure>
<p>Chương trình sử dụng đa luồng:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/Anh-chup-man-hinh-2024-12-26-143430.png" alt="" width="1211" height="541" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143430-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143430-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143430-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143430-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143430-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143430-2xl.png 1920w"></figure>
<p>Kết quả thực thi chương trình trên:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/Anh-chup-man-hinh-2024-12-26-143527.png" alt="" width="1210" height="651" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143527-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143527-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143527-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143527-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143527-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Anh-chup-man-hinh-2024-12-26-143527-2xl.png 1920w"></figure>
<p>Kết quả chương trình trên được giải thích thông qua hình bên dưới:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/Picture7.png" alt="" width="550" height="309" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture7-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture7-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture7-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture7-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture7-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/5/responsive/Picture7-2xl.png 1920w"></figure>
<p>     3.5/ Các phương pháp Thread thường được sử dụng</p>
<ul>
<li><em>suspend()</em>: phương thức làm tạm dừng hoạt động của 1 luồng nào đó bằng các ngưng cung cấp CPU cho luồng này. Để cung cấp lại CPU cho luồng ta sử dụng phương thức <em>resume()</em>. Cần lưu ý là ta không thể dừng ngay hoạt động của luồng bằng phương thức này. Phương thức <em>suspend() </em>không dừng ngay tức thì hoạt động của luồng mà sau khi luồng này trả CPU về cho hệ điều hành thì không cấp CPU cho luồng nữa.</li>
<li><em>resume()</em>: phương thức làm cho luồng chạy lại khi luồng bị dừng do phương thức <em>suspend() </em>bên trên. Phương thức này sẽ đưa luồng vào lại lịch điều phối CPU để luồng được cấp CPU chạy lại bình thường.</li>
<li><em>stop()</em>: phương thức này sẽ kết thúc phương thức <em>run() </em>bằng cách ném ra 1 ngoại lệ <em>ThreadDeath</em>, điều này cũng sẽ làm luồng kết thúc 1 cách ép buộc. Nếu giả sử, trước khi gọi <em>stop() </em>mà luồng đang nắm giữa 1 đối tượng nào đó hoặc 1 tài nguyên nào đó mà luồng khác đang chờ thì có thể dẫn tới việc xảy ra deadlock.</li>
<li><em>destroy()</em>: dừng hẳn luồng.</li>
<li><em>isAlive()</em>: phương thức này kiểm tra xem luồng còn <em>active </em>hay không. Phương thức sẽ trả về <em>true </em>nếu luồng đã được <em>start() </em>và chưa rơi vào trạng thái <em>dead</em>. Nếu phương thức trả về <em>false </em>thì luồng đang ở trạng thái <em>New Thread </em>hoặc là đang ở trạng thái <em>dead</em>.</li>
<li><em>yeild() </em>: hệ điều hành đa nhiệm sẽ phân phối CPU cho các tiến trình, các luồng theo vòng xoay. Mỗi luồng sẽ được cấp CPU trong 1 khoảng thời gian nhấtđịnh, sau đó trả lại CPU cho hệ điều hành, hệ điều hành sẽ cấp CPU cho luồng khác. Khi gọi phương thức này luồng sẽ bị ngừng cấp CPU và nhường cho luồng tiếp theo trong hàng chờ <em style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Ready</em><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">. Luồng không phải ngưng cấp CPU như </span><em style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">suspend() </em><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">mà chỉ ngưng cấp trong lần nhận CPU đó mà thôi.</span></li>
<li><em>sleep(long)</em>: tạm dừng luồng trong một khoảng thời gian tính bằng mili giây.</li>
<li><em>join()</em>: thông báo rằng hãy chờ luồng này hoàn thành rồi luồng cha mới được tiếp tục chạy.</li>
<li><em>join(long)</em>: luồng cha cần phải đợi sau mili giây mới được tiếp tục chạy, kể từ lúc gọi <em>join(long)</em>. Nếu tham số bằng <em>0 </em>nghĩa là đợi cho tới khi luồng này kết thúc.</li>
<li><em>getName()</em>: trả về tên của luồng.</li>
<li><em>setName(String name)</em>: thay đổi tên của luồng.</li>
<li><em>getId()</em>: trả về id của luồng.</li>
<li><em>getState()</em>: trả về trạng thái của luồng.</li>
<li><em>currentThread()</em>: trả về tham chiếu của luồngđang được thi hành.</li>
<li><em>getPriority()</em>: trả về mức độ ưu tiên của luồng.</li>
<li><em>setPriority(int)</em>: thay đổi mức độ ưu tiên của luồng.</li>
<li><em>isDaemon()</em>: kiểm tra nếu luồnglà một luồng</li>
<li><em>setDaemon(boolean)</em>: thiết lập luồnglà một luồng Daemon hay không.</li>
<li><em>interrupt()</em>: làm gián đoạn một luồng trong Java. Nếu luồng nằm trong trạng thái sleep hoặc wait, nghĩa là <em>sleep() </em>hoặc <em>wait() </em>được gọi ra. Việc gọi phương thức <em>interrupt() </em>trên luồng đó sẽ phá vỡ trạng thái sleep hoặc wait và ném ra ngoại lệ <em>InterruptedException</em>. Nếu luồng không ở trong trạng thái sleep hoặc wait, việc gọi phương thức <em>interrupt() </em>thực hiện hành vi bình thường và không làm gián đoạn luồng nhưng đặt cờ interrupt thành <em>true</em>.</li>
<li><em>isInterrupted()</em>: kiểm tra luồng nào đó đã bị ngắt hay không.</li>
<li><em>interrupted()</em>: kiểm tra xem luồng hiện tại đã bị ngắt hay không.</li>
</ul>
<p> </p>
<p> </p>
<p> </p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 2:CÁC DÒNG VÀO-RA (STREAM)</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/bai-2-2.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/bai-2-2.html</id>

        <updated>2024-12-29T11:02:32+07:00</updated>
            <summary>
                <![CDATA[
                    2.1/Các dòng ra (output stream) Lớp output cơ bản của Java là java.io.OutputStream, với khai báo như sau: public abstract class OutputStream{ } Lớp này cung cấp các phương thức cơ bản để ghi dữ liệu, đó là: Các lớp con của OutputStream sử dụng&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>2.1/Các dòng ra (output stream)</p>
<p>Lớp output cơ bản của Java là <em>java.io.OutputStream</em>, với khai báo như sau:</p>
<p>public abstract class OutputStream{</p>
<p>}</p>
<p>Lớp này cung cấp các phương thức cơ bản để ghi dữ liệu, đó là:</p>
<ul>
<li><em>public abstract void <strong>write</strong>(int b) throws IOException</em></li>
<li><em>public void <strong>write</strong>(byte[] data) throws IOException</em></li>
<li><em>public void <strong>write</strong>(byte[] data, int offset, int length) throws IOException</em></li>
<li><em>public void <strong>flush</strong>() throws IOException</em></li>
<li><em>public void <strong>close</strong>() throws IOException</em></li>
</ul>
<p>Các lớp con của <em>OutputStream </em>sử dụng các phương thức này để ghi dữ liệu lên một</p>
<p>phương tiện cụ thể. Ví dụ, một <em>FileOutputStream </em>sử dụng các phương thức này để ghi dữ liệu vào một file. Một <em>TelnetOutputStream </em>sử dụng các phương thức để ghi dữ liệu vào một kết nối mạng. Một <em>ByteArrayOutputStream </em>dùng các phương thức để ghi dữ liệu vào một mảng các byte có thể mở rộng được.</p>
<p>            Phương thức cơ bản của <em>OutputStream </em>là <em>write(int b)</em>. Phương thức này sử dụng một số nguyên có giá trị từ 0 đến 255 như là một đối số và ghi byte tương ứng vào output stream. Phương thức này được mô tả là trừu tượng (abstract) do các lớp con cần thay đổi phương thức này để kiểm soát phương tiện cụ thể. Một <em>ByteArrayOutputStream </em>có thể cài đặt phương thức với mã Java để sao chép byte vào mảng trong Java. Tuy nhiên, một <em>FileOutputStream </em>sẽ cần phải sử dụng mã riêng, mã này biết cách ghi dữ liệu trong các file trên nền của hệ điều hành.</p>
<p>           Mặc dù phương thức <em>write(int b) </em>sử dụng một số nguyên như là một đối số nhưng khi ghi sẽ ghi một byte không dấu (unsigned byte). Java không có kiểu dữ liệu byte không dấu nên phải sử dụng một số nguyên. Sự khác biệt giữa một byte không dấu và byte có dấu chính là cách diễn giải. </p>
<p>            Ví dụ: Giao thức bộ sinh ký tự (character-generator protocol) định nghĩa một Server gửi ra các văn bản mã hóa bằng mã ASCII. Một trong các biến thể của giao thức này sẽ gửi các dòng, mỗi dòng chứa 72 ký tự mã hóa bằng mã ASCII có thể in ra được. Các ký tự này có số thứ tự từ 33 đến 126 trong bảng mã ASCII ngoại trừ các ký tự trắng và các ký tự điều khiển.</p>
<ul>
<li>Dòng đầu chứa các ký tự từ 33 đến</li>
<li>Dòng thứ hai chứa các ký tự từ 34 đến</li>
<li>Dòng thứ ba chứa các ký tự từ 35 đến</li>
<li>Dòng thứ 29 chứa các ký tự từ 55 đến</li>
</ul>
<p>Đến đây, các ký tự được gói xoay vòng sao cho dòng 30 chứa các ký tự từ 56 đến 126 và sau đó lại là ký tự 33.</p>
<p>Các dòng được kết thúc bằng dấu Enter (ASCII 13) và một mã xuống dòng (ASCII 10).</p>
<p>Đoạn mã sau sẽ trình bày cách triển khai phương thức <em>write()</em>:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-134011-2.png" alt="" width="1215" height="637" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134011-2-2xl.png 1920w"></figure>
<p>Kết quả của giao thức bộ sinh ký tự là:</p>
<p>!"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh "#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghi #$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghij</p>
<p>$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijk</p>
<p>%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijkl &amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklm '()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn</p>
<p>         Trong ví dụ trên, một <em>OutputStream </em>được truyền đến phương thức <em>generateCharacters() </em>trong đối số <em>out</em>. Dữ liệu được viết lần lượt từng byte trên <em>out</em>. Các byte này được cho dưới dạng các số nguyên trong một chuỗi xoay vòng từ 33 đến 126. Sau mỗi một chuỗi 72 ký tự được viết dấu Enter (ASCII 13) và một mã xuống dòng (ASCII 10) được viết lên output stream. Ký tự kế tiếp được tính toán và vòng lặp sẽ được lặp lại. Phương thức out sử dụng throw <em>IOException</em>. Điều này rất quan trọng do Server bộ sinh ký tự sẽ chỉ kết thúc khi bên phía Client kết thúc kết nối và mã Java sẽ nhận biết việc kết thúc này như là một <em>IOException</em>.</p>
<p>         Việc ghi mỗi lần một byte thường không hiệu quả. Ví dụ, mỗi TCP segment chứa ít nhất 40 byte của phần overhead dùng cho việc định tuyến và sửa lỗi. Nếu mỗi lần chỉ gửi một byte ta có thể làm cho mạng phải tải tổng cộng 41 byte. Do đó, hầu hết các cài đặt TCP/IP sử dụng vùng đệm dữ liệu có một kích thước nào đó. Các cài đặt này sẽ tích lũy dữ liệu cần gửi trong vùng đệm (buffer) và chỉ gửi các dữ liệu này đi khi lượng dữ liệu được tích lũy hay thời gian tích lũy đã vượt một ngưỡng cho trước. Sử dụng <em>write(byte[] data) </em>hoặc <em>write(byte[] data, int offset, int length) </em>thường nhanh hơn việc ghi lần lượt từng thành phần của một mảng dữ liệu. Sau đây là ví dụ của việc cài đặt phương thức <em>generateCharacters()</em>, phương thức này gửi mỗi lần một dòng bằng cách đóng gói toàn bộ một dòng trong một mảng các byte:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-134342.png" alt="" width="1210" height="590" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134342-2xl.png 1920w"></figure>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-134357.png" alt="" width="1233" height="200" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-134357-2xl.png 1920w"></figure>
<p> Các stream cũng có thể được đưa vào vùng đệm bằng phần mềm như mã Java cũng như là trong phần cứng của mạng. Thông thường, việc đưa dữ liệu vào vùng đệm được thực hiện bằng cách gắn một <em>BufferedOutputStream </em>hay một <em>BufferedWriter </em>vào một stream lớp dưới. Để đưa dữ liệu trong một vùng đệm lên một kết nối ta sử dụng phương thức <em>flush()</em>. Phương thức <em>flush() </em>sẽ yêu cầu dòng phải gửi dữ liệu đã được đưa vào vùng đệm lên kết nối, ngay cả khi vùng đệm chưa đầy. Ta cần phải đưa hết tất cả các dữ liệu trong vùng đệm của các dòng bằng phương thức <em>flush() </em>trước khi ta đóng các dòng này, nếu không thì khi đóng các dòng, dữ liệu trong các vùng đệm sẽ bị mất.</p>
<figure class="post__image align-center"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Picture3.jpg" alt="" width="558" height="329" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture3-2xl.jpg 1920w"></figure>
<p>Khi đã làm việc xong với một stream ta có thể đóng stream này bằng cách gọi phương thức <em>close()</em>. Phương thức <em>close() </em>sẽ giải phóng tất cả các tài nguyên được liên kết với stream, chẳng hạn như các đặc tả tập tin (file handle) hay các cổng. Nếu stream có được từ một kết nối mạng thì khi đóng stream sẽ hủy bỏ kết nối mạng. Khi một output stream đã bị đóng việc ghi thêm dữ liệu vào stream sẽ đưa ra <em>IOException</em>. Tuy nhiên một vài kiểu stream vẫn cho phép chúng ta tiếp tục làm việc với đối tượng khi đã đóng stream. Ví dụ, một <em>ByteArrayOutputStream </em>đã bị đóng vẫn có thể được chuyển đổi thành mảng các byte thật sự và một <em>DigestOutputStream </em>đã bị đóng vẫn có thể trả về giá trị digest của nó.</p>
<p>            Nếu không đóng một stream trong một chương trình lớn có thể làm tiết lộ các đặc tả tập tin, các cổng mạng và các tài nguyên khác. Do đó, với Java 6 và các phiên bản trước đó, ta nên có một khối có tên là <em>finally </em>để đóng các dòng, khối này là khối cuối cùng trong một chương trình. Thông thường, ta khai báo biến <em>stream </em>bên ngoài khối <em>try </em>nhưng nên khởi tạo dòng bên trong khối <em>try</em>. Để tránh gặp phải <em>NullPointerExceptions </em>ta cần kiểm tra xem biến <em>stream </em>có phải là <em>null </em>hay không trước khi ta đóng dòng này. Ví dụ sau minh họa cách viết sử dụng <em>finally</em>:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-135039.png" alt="" width="1208" height="509" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135039-2xl.png 1920w"></figure>
<p>Kỹ thuật này đôi khi được gọi là <em>dispose pattern</em>. Dispose pattern phổ biến cho các đối tượng cần phải được dọn dẹp trước khi các dữ liệu không còn sử dụng được thu dọn. Dispose pattern không chỉ được sử dụng cho các đối tượng và còn được sử dụng cho cả các sockets, channels, JDBC connections và các statements.</p>
<p>        Java 7 giới thiệu cách sử dụng khối <em>try </em>cùng với xây dựng các tài nguyên để thu dọn dữ liệu không còn sử dụng. Với cách này, dòng được khai báo trong một danh sách đối số bên trong khối <em>try</em>. Đoạn mã trên được viết lại như sau:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-135212.png" alt="" width="1196" height="188" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135212-2xl.png 1920w"></figure>
<p>        Trong đoạn mã này ta nhận thấy khối <em>finally </em>đã không còn cần thiết. Java sẽ tự động gọi phương thức <em>close() </em>trên bất kỳ đối tượng có thuộc tính <em>AutoCloseable </em>bên trong danh sách đối số của khối <em>try</em>.</p>
<p>2.1/Các dòng vào (input stream)</p>
<p>Lớp input cơ bản của Java là <em>java.io.InputStream</em>, với khai báo như sau:</p>
<p>public abstract class InputStream{</p>
<p>}</p>
<p>Lớp này cung cấp các phương thức cơ bản để đọc dữ liệu như là các byte chưa được xử lý còn được gọi là byte thô:</p>
<ul>
<li><em>public abstract int <strong>read</strong>() throws IOException</em></li>
<li><em>public int <strong>read</strong>(byte[] input) throws IOException</em></li>
<li><em>public int <strong>read</strong>(byte[] input, int offset, int length) throws IOException</em></li>
<li><em>public long <strong>skip</strong>(long n) throws IOException</em></li>
<li><em>public int <strong>available</strong>() throws IOException</em></li>
<li><em>public void <strong>close</strong>() throws IOException</em></li>
</ul>
<p>Các lớp con cụ thể của <em>InputStream </em>sử dụng các phương thức này để đọc dữ liệu từ một phương tiện cụ thể. Ví dụ, một <em>FileOutputStream </em>sử dụng các phương thức này để đọc dữ liệu từ một file. Một <em>TelnetOutputStream </em>sử dụng các phương thức này để đọc dữ liệu từ một kết nối mạng. Một <em>ByteArrayOutputStream </em>sử dụng các phương thức này để đọc dữ liệu từ một mảng các byte.</p>
<p>         Phương thức cơ bản của <em>InputStream </em>là phương thức <em>read() </em>không có đối số. Phương thức <em>read() </em>đọc một byte dữ liệu từ nguồn của một input stream và trả lại một số nguyên nằm trong khoảng từ 0 đến 255. Kết thúc của một stream được báo hiệu bằng cách trả lại giá trị <em>-1</em>. Phương thức <em>read() </em>sẽ chờ và ngăn không cho thực thi bất kỳ đoạn mã nào sau phương thức này cho đến khi một byte dữ liệu sẵn sàng cho việc đọc.</p>
<p>         Việc đọc và ghi dữ liệu có thể chậm. Do đó nếu chương trình đang phải thực thi một đoạn mã quan trọng thì nên đặt các thao tác I/O trong một luồng (thread) riêng của thao tác I/O.</p>
<p>          Phương thức <em>read() </em>được mô tả là trừu tượng do các lớp con cần thay đổi phương thức này để quản lý các phương tiện cụ thể. Ví dụ, một <em>ByteArrayInputStream </em>có thể thực thi phương thức này bằng mã Java để sao chép byte từ một mảng. Tuy nhiên, một <em>TelnetInputStream </em>cần sử dụng một thư viện riêng để biết cách đọc dữ liệu từ một giao diện mạng trên nền của hệ điều hành.</p>
<p>          Đoạn mã sau đọc 10 byte từ <em>InputStream </em>có tên là <em>in </em>và lưu các byte trong một mảng byte có tên <em>input</em>. Trong quá trình đọc nếu phát hiện đã hết dữ liệu thì vòng lặp sẽ được kết thúc sớm hơn:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-135708.png" alt="" width="1211" height="223" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-135708-2xl.png 1920w"></figure>
<p>       Mặc dù <em>read() </em>chỉ đọc một byte, phương thức này trả lại một số nguyên, nên cần phải thực hiện chuyển đổi một số nguyên thành một byte bằng cast trước khi lưu trữ kết quả trong mảng byte. Vì <em>read() </em>trả lại một giá trị nguyên có phạm vi từ - 128 đến 127 thay vì 0 đến 255 nên ta cần phải chuyển đổi một byte có dấu thành byte không dấu như sau:</p>
<p>int i = b &gt;= 0 ? b : 256 + b;</p>
<p>      Cũng tương tự như việc ghi mỗi lần một byte trong <em>OutputStream</em>, việc đọc mỗi lần một byte sẽ là không hiệu quả. Có hai phương thức overloaded là <em>read(byte[] input) </em>và <em>read(byte[] input, int offset, int length)</em>. Hai phương thức này sẽ làm đầy một mảng các byte từ một dòng. Phương thức thứ nhất sẽ cố gắng làm đầy một mảng các byte có tên <em>input</em>. Phương thức thứ hai sẽ cố gắng làm đầy một mảng con các byte của mảng <em>input</em>, bắt đầu từ vị trí <em>offset </em>và sẽ ghi <em>length </em>byte. Việc ghi vào một mảng đôi khi sẽ không thành công vì nhiều lý do khác nhau. Ví dụ, tại một thời điểm, ta cố gắng để đọc 1024 byte từ một kết nối mạng, khi đó ta có thể nhận được 512 byte từ Server còn 512 byte đang được chuyển đến. Để biết được số lượng byte đã được đọc ta sử dụng các phương thức đọc nhiều byte. Đoạn mã sau trình bày cách đọc nhiều byte:</p>
<p>byte[] input = new byte[1024];</p>
<p>int bytesRead = in.read(input);</p>
<p>        Đoạn mã sẽ cố gắng đọc 1024 byte từ <em>InputStream </em>vào một mảng các byte có tên là <em>input</em>. Tuy nhiên, nếu chỉ có 512 byte để đọc thì <em>bytesRead </em>sẽ được thiết lập là 512.</p>
<p>        Để đảm bào đọc được tất cả các byte ta đặt thao tác đọc vào trong một vòng lặp cho đến khi mảng được làm đầy. Ví dụ:</p>
<p>int bytesRead = 0;</p>
<p>int bytesToRead = 1024;</p>
<p>byte[] input = new byte[bytesToRead]; while (bytesRead &lt; bytesToRead) {</p>
<p>bytesRead += in.read(input, bytesRead, bytesToRead - bytesRead);</p>
<p>}</p>
<p>           Tất cả các phương thức <em>read() </em>sẽ trả lại giá trị -1 để báo hiệu kết thúc một stream. Nếu một stream kết thúc trong khi vẫn còn dữ liệu chưa được đọc thì các phương thức đọc nhiều byte sẽ vẫn đọc dữ liệu cho đến khi vùng đệm trở nên trống. Khi đó việc đọc tiếp sẽ trả lại giá trị <em>-1 </em>và giá trị này sẽ không được ghi vào mảng. Do đó trong mảng chỉ chứa dữ liệu thực sự. Đoạn mã trên chưa cân nhắc đến trường hợp tất cả 1024 byte chưa đến được vùng đệm. Do đó, ta cần kiểm tra giá trị của <em>read() </em>trước khi bổ sung giá trị này vào <em>bytesRead</em>. Ví dụ:</p>
<p>int bytesRead = 0;</p>
<p>int bytesToRead = 1024;</p>
<p>byte[] input = new byte[bytesToRead]; while (bytesRead &lt; bytesToRead) {</p>
<p>int result = in.read(input, bytesRead, bytesToRead - bytesRead); if (result == -1) break; // end of stream</p>
<p>bytesRead += result;</p>
<p>}</p>
<p>       Ta có thể sử dụng phương thức <em>available() </em>để xác định số lượng byte có thể đọc ngay mà không cần phải chờ. Phương thức này trả lại số lượng byte tối thiểu mà ta có thể đọc. Ví dụ:</p>
<p>int bytesAvailable = in.available(); byte[] input = new byte[bytesAvailable];</p>
<p>int bytesRead = in.read(input, 0, bytesAvailable);</p>
<p>// continue with rest of program immediately...</p>
<p>       Trong một số ít trường hợp nếu muốn bỏ qua việc đọc dữ liệu, ta sử dụng phương thức <em>skip()</em>. Khi đã đọc xong dữ liệu từ một stream ta nên đóng stream bằng cách gọi phương thức <em>close() </em>của input stream. Phương thức này sẽ giải phóng tất cả các tài nguyên liên kết với dòng như các đặc tả tập tin hay các cổng. Khi một input strream đã bị đóng, các thao tác đọc dữ liệu tiếp theo sẽ đưa ra <em>IOException</em>. Tuy nhiên một vài kiểu stream có thể vẫn cho phép làm một số công việc với đối tượng. Ví dụ, ta sẽ không thể nhận được message digest từ một <em>java.security.DigestInputStream </em>cho đến khi dữ liệu đã được đọc và dòng bị đóng lại.</p>
<h2>Mark và Reset</h2>
<p>       Lớp <em>InputStream </em>có ba phương thức ít được sử dụng, các phương thức này cho phép các chương trình sao chép dự phòng (backup) và đọc lại dữ liệu đã được đọc trước đó:</p>
<ul>
<li><em>public void <strong>mark</strong>(int readAheadLimit)</em></li>
<li><em>public void <strong>reset</strong>() throws IOException</em></li>
<li><em>public boolean <strong>markSupported</strong>()</em></li>
</ul>
<p>        Để đọc lại dữ liệu cần đánh dấu (mark) vị trí hiện thời trong dòng bằng phương thức <em>mark()</em>. Sử dụng phương thức <em>reset() </em>để thiết lập lại (reset) dòng tại điểm đã đánh dấu. Các thao tác đọc tiếp theo sẽ trả lại dữ liệu bắt đầu từ điểm đánh dấu. Số lượng các byte có thể đọc từ vị trí đánh dấu được xác định bởi đối số <em>readAheadLimit </em>trong <em>mark()</em>. Nếu ta quay trở lại vượt quá điểm đã đánh dấu thì chương trình sẽ đưa ra <em>IOException</em>. Trong một dòng luôn chỉ tồn tại duy nhất một đánh dấu. Đánh dấu vị trí thứ hai sẽ xóa bỏ đánh dấu thứ nhất.</p>
<p> </p>
<p>      Đánh dấu và thiết lập lại thường được thực hiện bằng cách lưu trữ các byte được đọc kể từ vị trí đã được đánh dấu trong một vùng đệm bên trong chương trình. Tuy nhiên không phải tất cả các dòng đều hỗ trợ mark và reset.</p>
<p>      Để kiểm tra xem một dòng có hỗ trợ mark và reset không ta sử dụng phương thức <em>markSupported()</em>. Nếu phương thức này trả lại giá trị là <em>true </em>thì dòng có hỗ trợ mark và reset. Nếu phương thức này trả lại giá trị là <em>false </em>thì dòng không hỗ trợ mark và reset, khi đó <em>mark() </em>sẽ không làm gì và <em>reset() </em>sẽ đưa ra một <em>IOException</em>.</p>
<p>       Chỉ có các lớp <em>BufferedInputStream </em>và <em>ByteArrayInputStream </em>trong <em>java.io </em>là luôn hỗ trợ mark và reset. Tuy nhiên các input stream khác chẳng hạn như <em>TelnetInputStream </em>cũng có thể hỗ trợ mark nếu các lớp này lần đầu được gắn vào với một <em>BufferedInputStream</em>.</p>
<p>          2.3Các dòng filter stream</p>
<p><em>         InputStream </em>và <em>OutputStream </em>là các lớp tương đối đơn giản. Các lớp này chỉ thực hiện việc đọc và ghi từng byte hay một nhóm các byte. Việc xác định ý nghĩa của các byte, chẳng hạn như các byte có phải là các số nguyên, là các số thực dấu phảy động IEEE 754 hay là văn bản được mã hóa bằng bảng mã Unicode hoàn toàn phụ thuộc vào người lập trình và mã chương trình. Tuy nhiên có một vài định dạng dữ liệu vô cùng phổ biến đã được cài đặt trong thư viện lớp. Ví dụ, rất nhiều các số nguyên được truyền đi như là các phần của các giao thức mạng là các số nguyên 32 bit big-endian; nhiều văn bản được truyền trên web được mã hóa hoặc là ASCII 7-bit, Latin-1 8-bit, hay UTF-8 multibyte; nhiều file được truyền đi bằng giao thức FTP được lưu trữ dưới định dạng ZIP. Java cung cấp một số lượng các lớp lọc (filter classes) có thể được gắn vào các dòng để dịch các byte thô thành các định dạnh khác.</p>
<p>         Các filter được chia thành hai kiểu: các filter stream reader và writer. Filter stream chủ yếu làm việc với các dữ liệu thô như các byte, chẳng hạn như nén dữ liệu hoặc diễn dịch dữ liệu là các số nhị phân. Reader và writer quản lý trường hợp đặc biệt của văn bản trong nhiều cách mã hóa khác nhau như UTF-8 và ISO 8859-1.</p>
<p>          Các filter được tổ chức trong một chuỗi (chain). Mỗi liên kết trong chuỗi nhận dữ liệu từ filter trước hoặc từ dòng và truyền dữ liệu đến liên kết kế tiếp trong chuỗi. Sơ đồ sau trình bày chuỗi các filter.</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Picture4.jpg" alt="" width="307" height="591" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-xs.jpg 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-sm.jpg 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-md.jpg 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-lg.jpg 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-xl.jpg 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Picture4-2xl.jpg 1920w"></figure>
<p>Trong ví dụ trên, một file văn bản đã được mã hóa và được nén được truyền đến thông qua giao diện mạng cục bộ. Mã riêng của chương trình chuyển file này đến <em>TelnetInputStream</em>. Một <em>BufferedInputStream </em>sẽ đưa file vào vùng đệm để tăng tốc toàn bộ quá trình. Một <em>CipherInputStream </em>giải mã dữ liệu và một <em>GZIPInputStream </em>sẽ giải nén dữ liệu. Một <em>InputStreamReader </em>chuyển đổi dữ liệu đã được giải nén thành file văn bản mã hóa bằng mã Unicode. Cuối cùng, file văn bản đã sẵn sảng cho ứng dụng trong lớp ứng dụng và được xử lý.</p>
<p>Các filter output stream có cùng các phương thức như <em>write()</em>, <em>close() </em>và <em>flush() </em>như <em>java.io.OutputStream</em>. Các filter input stream có cùng các phương thức như <em>read()</em>, <em>close() </em>và <em>available() </em>như <em>java.io.InputStream</em>.</p>
<p>       2.4/Các lớp Reader and Writer</p>
<p>             2.4.1/Lớp Writter</p>
<p>          Lớp <em>Writer </em>tương ứng với lớp <em>java.io.OutputStream</em>. Lớp <em>Writer </em>là <em>abstract </em>và có hai <em>protected constructor</em>. Cũng giống như <em>OutputStream</em>, lớp <em>Writer </em>không bao giờ được sử dụng trực tiếp, thay vào đó lớp này được sử dụng theo kiểu polymorphic thông qua một trong số các lớp con của nó. Lớp <em>Writer </em>có năm phương thức <em>write() </em>và các phương thức <em>flush()</em>, <em>close()</em>:</p>
<ul>
<li><em>protected <strong>Writer</strong>()</em></li>
<li><em>protected <strong>Writer</strong>(Object lock)</em></li>
<li><em>public abstract void <strong>write</strong>(char[] text, int offset, int length) throws IOException</em></li>
<li><em>public void <strong>write</strong>(int c) throws IOException</em></li>
<li><em>public void <strong>write</strong>(char[] text) throws IOException</em></li>
<li><em>public void <strong>write</strong>(String s) throws IOException</em></li>
<li><em>public void <strong>write</strong>(String s, int offset, int length) throws IOException</em></li>
<li><em>public abstract void <strong>flush</strong>() throws IOException</em></li>
<li><em>public abstract void <strong>close</strong>() throws IOException</em></li>
</ul>
<p>           Phương thức <em>write(char[] text, int offset, int length) </em>là phương thức cơ bản để cho bốn phương thức <em>write() </em>còn lại được triển khai. Một lớp con cần phải ít nhất override phương thức này cũng như là override các phương thức <em>flush() </em>và <em>close()</em>.</p>
<p>              2.4.2/ Lớp OutputStream Writter</p>
<p><em>         OutputStreamWriter </em>là lớp con cụ thể quan trọng nhất của lớp <em>Writer</em>. Một <em>OutputStreamWriter </em>nhận các ký tự từ một chương trình Java sau đó sẽ chuyển đổi thành các byte dựa trên một cách mã hóa cụ thể và ghi các byte này lên một output stream lớp dưới. Constructor của <em>OutputStreamWriter </em>xác định output stream để ghi vào và cách mã hóa được sử dụng:</p>
<ul>
<li><em>public <strong>OutputStreamWriter</strong>(OutputStream out, String encoding) throws UnsupportedEncodingException</em></li>
</ul>
<p>           Ngoài các constructor, <em>OutputStreamWriter </em>chỉ có các phương thức <em>Writer </em>thông thường được sử dụng giống như trong lớp <em>Writer </em>và một phương thức để trả về mã hóa của đối tượng:</p>
<ul>
<li><em>public String <strong>getEncoding</strong>()</em></li>
</ul>
<p>2.4.3/ Lớp Reader</p>
<p>         Lớp <em>Reader </em>tương ứng với lớp <em>java.io.InputStream</em>. Lớp <em>Reader </em>là <em>abstract </em>và có hai <em>protected constructor</em>. Giống như <em>InputStream </em>và <em>Writer</em>, lớp <em>Reader </em>không bao giờ được dùng trực tiếp và chỉ được sử dụng thông qua một trong số các lớp con của nó. Lớp <em>Reader </em>có ba phương thức <em>read() </em>và các phương thức <em>skip()</em>, <em>close()</em>, <em>ready()</em>, <em>mark()</em>, <em>reset() </em>và <em>markSupported()</em>:</p>
<ul>
<li><em>protected <strong>Reader</strong>()</em></li>
<li><em>protected <strong>Reader</strong>(Object lock)</em></li>
<li><em>public abstract int <strong>read</strong>(char[] text, int offset, int length) throws IOException</em></li>
<li><em>public int <strong>read</strong>() throws IOException</em></li>
<li><em>public int <strong>read</strong>(char[] text) throws IOException</em></li>
<li><em>public long <strong>skip</strong>(long n) throws IOException</em></li>
<li><em>public boolean <strong>ready</strong>()</em></li>
<li><em>public boolean <strong>markSupported</strong>()</em></li>
<li><em>public void <strong>mark</strong>(int readAheadLimit) throws IOException</em></li>
<li><em>public void <strong>reset</strong>() throws IOException</em></li>
<li><em>public abstract void <strong>close</strong>() throws IOException</em></li>
</ul>
<p>        Phương thức <em>read(char[] text, int offset, int length) </em>là phương thức cơ bản qua đó hai phương thức <em>read() </em>còn lại được cài đặt. Một lớp con cần phải ít nhất override phương thức này cũng như là override phương thức <em>close()</em>.</p>
<p><em>         InputStreamReader </em>là lớp con cụ thể quan trọng nhất của <em>Reader</em>. Một <em>InputStreamReader </em>đọc các byte từ một input stream lớp dưới, chẳng hạn như một <em>FileInputStream</em><em> </em>hay <em>TelnetInputStream</em><em> </em>sau đó chuyển đổi các byte này thành các ký tự dựa trên một cách mã hóa cụ thể và trả về các ký tự này. Constructor của <em>InputStreamReader </em>xác định input stream để đọc và cách mã hóa được sử dụng:</p>
<ul>
<li><em>public <strong>InputStreamReader</strong>(InputStream in)</em></li>
<li><em>public <strong>InputStreamReader</strong>(InputStream in, String encoding) throws UnsupportedEncodingException</em></li>
</ul>
<p>             2.4.4/ Các lớp Filter Reader và Filter Writter</p>
<p>Các lớp <em>InputStreamReader </em>và <em>OutputStreamWriter </em>hoạt động trên đỉnh của các input stream và output stream. Các lớp này thay đổi giao diện từ một giao diện hướng byte (byte-oriented interface) thành một giao diện hướng ký tự (character-oriented interface). Sau khi đã thay đổi giao diện, các bộ lọc hướng ký tự (character-oriented filters) bổ sung sẽ được đặt trên đỉnh của reader và writer sử dụng các lớp <em>java.io.FilterReader </em>và <em>java.io.FilterWriter</em>. Cũng như các filter stream, có nhiều lớp con thực hiện các thao tác lọc cụ thể, bao gồm:</p>
<ul>
<li><strong><em>BufferedReader</em></strong></li>
<li><strong><em>BufferedWriter</em></strong></li>
<li><strong><em>LineNumberReader</em></strong></li>
<li><strong><em>PushbackReader</em></strong></li>
<li><strong><em>PrintWriter</em></strong></li>
</ul>
<p>Các lớp <em>BufferedReader </em>và <em>BufferedWriter </em>là các lớp dựa trên ký tự (character-based) tương đương với các lớp hướng byte (byte-oriented) <em>BufferedInputStream</em><em> </em>và <em>BufferedOutputStream</em>. Khi một chương trình đọc dữ liệu từ một <em>BufferedReader</em>, văn bản được lấy từ vùng đệm mà không phải được lấy trực tiếp từ input stream lớp dưới hay các nguồn khác. Khi vùng đệm không có dữ liệu, nó sẽ lại được làm đầy với số lượng ký tự càng nhiều càng tốt. Các ký tự này có thể sẽ không được sử dụng ngay mà có thể được sử dụng cho các lần đọc sau. Khi một chương trình ghi vào một <em>BufferedWriter</em>, văn bản sẽ được đưa vào vùng đệm. Văn bản chỉ được chuyển đến output stream lớp dưới hay các đích đến khác khi vùng đệm đã đầy hoặc khi vùng đệm được flush, điều này sẽ làm cho việc ghi trở nên nhanh hơn.</p>
<p> </p>
<p><em>BufferedReader </em>và <em>BufferedWriter </em>có những phương thức thông dụng kết hợp với các reader và writer là <em>read()</em>, <em>ready()</em>, <em>write() </em>và <em>close()</em>. Mỗi lớp có hai constructor, các constructor gắn <em>BufferedReader </em>hoặc <em>BufferedWriter </em>với reader hoặc writer lớp dưới và thiết lập kích thước của vùng đệm. Nếu kích thước của vùng đệm không được thiết lập thì kích thước mặc định của vùng đệm sẽ là 8192 ký tự:</p>
<ul>
<li><em>public <strong>BufferedReader</strong>(Reader in, int bufferSize)</em></li>
<li><em>public <strong>BufferedReader</strong>(Reader in)</em></li>
<li><em>public <strong>BufferedWriter</strong>(Writer out)</em></li>
<li><em>public <strong>BufferedWriter</strong>(Writer out, int bufferSize)</em></li>
</ul>
<p>Lớp <em>BufferedReader </em>cũng có một phương thức <em>readLine() </em>để đọc một dòng văn bản và trả về như một dòng:</p>
<ul>
<li><em>public String <strong>readLine</strong>() throws IOException</em></li>
</ul>
<p>Phương thức này thay thế cho phương thức đã bị phản đối <em>readLine() </em>trong <em>DataInputStream</em>. Sự khác biệt giữa hai phương thức này khi gắn một <em>BufferedReader </em>vào một <em>InputStreamReader </em>ta có thể đọc chính xác các dòng trong một tập hợp các ký tự thay vì cách mã hóa mặc định của hệ thống.</p>
<p>Lớp <em>BufferedWriter </em>bổ sung một phương thức mới không có trong lớp cha (superclass), được gọi là <em>newLine()</em>, phương thức này hướng đến việc ghi các dòng:</p>
<ul>
<li><em>public void <strong>newLine</strong>() throws IOException</em></li>
</ul>
<p>             2.4.5/ Lớp Scanner</p>
<p>         Lớp <em>Scanner </em>trong Java dùng để quét trên các dòng vào (bàn phím, socket, xâu kí tự…) để lấy được các giá trị mong muốn: xâu kí tự, số nguyên, số thực,…</p>
<p>Một số phương thức thường được sử dụng của lớp <em>Scanner </em>trong Java:</p>
<table>
<tbody>
<tr>
<td width="264">
<p><strong>Phương thức</strong></p>
</td>
<td width="331">
<p><strong>Mô tả</strong></p>
</td>
</tr>
<tr>
<td width="264">
<p><em>public String <strong>next</strong>()</em></p>
</td>
<td width="331">
<p>Trả về một xâu kí tự trước khoảng trắng</p>
</td>
</tr>
<tr>
<td width="264">
<p><em>public String <strong>nextLine</strong>()</em></p>
</td>
<td width="331">
<p>Trả về kết quả nội dung của một dòng</p>
</td>
</tr>
<tr>
<td width="264">
<p><em>public byte <strong>nextByte</strong>()</em></p>
</td>
<td width="331">
<p>Trả về kiểu dữ liệu byte</p>
</td>
</tr>
<tr>
<td width="264">
<p><em>public short <strong>nextShort</strong>()</em></p>
</td>
<td width="331">
<p>Trả về kiểu dữ liệu short</p>
</td>
</tr>
<tr>
<td width="264">
<p><em>public int <strong>nextInt</strong>()</em></p>
</td>
<td width="331">
<p>Trả về kiểu dữ liệu int</p>
</td>
</tr>
<tr>
<td width="264">
<p><em>public long <strong>nextLong</strong>()</em></p>
</td>
<td width="331">
<p>Trả về kiểu dữ liệu long</p>
</td>
</tr>
<tr>
<td width="264">
<p><em>public float <strong>nextFloat</strong>()</em></p>
</td>
<td width="331">
<p>Trả về kiểu dữ liệu float</p>
</td>
</tr>
<tr>
<td width="264">
<p><em>public double <strong>nextDouble</strong>()</em></p>
</td>
<td width="331">
<p>Trả về kiểu dữ liệu double</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Đoạn mã sau cho phép nhập một số nguyên từ bàn phím và in ra số đó:</p>
<figure class="post__image"><img loading="lazy"  src="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/Anh-chup-man-hinh-2024-12-26-141146.png" alt="" width="1213" height="329" sizes="(max-width: 1920px) 100vw, 1920px" srcset="file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-xs.png 640w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-sm.png 768w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-md.png 1024w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-lg.png 1366w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-xl.png 1600w ,file:///C:/Users/PHUC/Documents/Publii/sites/blog-ca-nhan/input/media/posts/3/responsive/Anh-chup-man-hinh-2024-12-26-141146-2xl.png 1920w"></figure>
<p>      2.4.6/Lớp Printer</p>
<p>Lớp <em>PrintWriter </em>thay thế cho lớp <em>PrintStream </em>trong Java 1.0. Lớp này thích hợp cho việc kiểm soát các ký tự được mã hóa bằng nhiều byte và các văn bản quốc tế.</p>
<p>Ngoài các constructor, lớp <em>PrintWriter </em>cũng có một tập hợp các phương thức tương tự như lớp <em>PrintStream</em>, đó là:</p>
<ul>
<li><em>public <strong>PrintWriter</strong>(Writer out)</em></li>
<li><em>public <strong>PrintWriter</strong>(Writer out, boolean autoFlush)</em></li>
<li><em>public <strong>PrintWriter</strong>(OutputStream out)</em></li>
<li><em>public <strong>PrintWriter</strong>(OutputStream out, boolean autoFlush)</em></li>
<li><em>public void <strong>flush</strong>()</em></li>
<li><em>public void <strong>close</strong>()</em></li>
<li><em>public boolean <strong>checkError</strong>()</em></li>
<li><em>public void <strong>write</strong>(int c)</em></li>
<li><em>public void <strong>write</strong>(char[] text, int offset, int length)</em></li>
<li><em>public void <strong>write</strong>(char[] text)</em></li>
<li><em>public void <strong>write</strong>(String s, int offset, int length)</em></li>
<li><em>public void <strong>write</strong>(String s)</em></li>
<li><em>public void <strong>print</strong>(boolean b)</em></li>
<li><em>public void <strong>print</strong>(char c)</em></li>
<li><em>public void <strong>print</strong>(int i)</em></li>
<li><em>public void <strong>print</strong>(long l)</em></li>
<li><em>public void <strong>print</strong>(float f)</em></li>
<li><em>public void <strong>print</strong>(double d)</em></li>
<li><em>public void <strong>print</strong>(char[] text)</em></li>
<li><em>public void <strong>print</strong>(String s)</em></li>
<li><em>public void <strong>print</strong>(Object o)</em></li>
<li><em>public void <strong>println</strong>()</em></li>
<li><em>public void <strong>println</strong>(boolean b)</em></li>
<li><em>public void <strong>println</strong>(char c)</em></li>
<li><em>public void <strong>println</strong>(int i)</em></li>
<li><em>public void <strong>println</strong>(long l)</em></li>
<li><em>public void <strong>println</strong>(float f)</em></li>
<li><em>public void <strong>println</strong>(double d)</em></li>
<li><em>public void <strong>println</strong>(char[] text)</em></li>
<li><em>public void <strong>println</strong>(String s)</em></li>
<li><em>public void <strong>println</strong>(Object o)</em></li>
</ul>
<p>Hầu hết các phương thức trên hoạt động tương tự như các phương thức trong <em>PrintStream </em>ngoại trừ bốn phương thức <em>write()</em>. Bốn phương thức <em>write() </em>sẽ không ghi các byte mà ghi các ký tự.</p>
<p>Trong lập trình mạng hiện nay, chúng ta thường dùng lớp <em>Scanner </em>làm input stream và <em>PrintWriter </em>làm output stream vì 2 lớp này hỗ trợ tốt việc đọc và ghi nhiều kiểu dữ liệu khác nhau với các phương thức linh hoạt, hiệu quả.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Bài 1:CÁC KHÁI NIỆM CƠ BẢN VỀ MẠNG MÁY TÍNH</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/bai-1cac-khai-niem-co-ban-ve-mang-may-tinh.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/bai-1cac-khai-niem-co-ban-ve-mang-may-tinh.html</id>

        <updated>2024-12-29T10:56:16+07:00</updated>
            <summary>
                <![CDATA[
                    Ngày này khi nói đến phát triển các ứng dụng phần mềm, đa số là người ta muốn nói đến chương trình có khả năng làm việc trong môi trường mạng tích hợp nói chung và mạng máy tính nói riêng. Từ các chương trình&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>Ngày này khi nói đến phát triển các ứng dụng phần mềm, đa số là người ta muốn nói đến chương trình có khả năng làm việc trong môi trường mạng tích hợp nói chung và mạng máy tính nói riêng. Từ các chương trình kế toán doanh nghiệp, quản lý, trò chơi, điều khiển... đều là các chương trình ứng dụng mạng</p>
<p>          Vấn đề lập trình mạng liên quan đế nhiều lĩnh vực kiến thức khác nhau. Từ kiến thức sử dụng ngôn ngữ lập trình, phân tích thiết kế hệ thống, kiến thức hệ thống mạng, mô hình xây dựng chương trình ứng dụng mạng, kiến thức về cơ sở dữ liệu... cho đến kiến thức truyền thông, các kiến thức các lĩnh vực liên quan khác như mạng điện thoại di động, PSTN, hệ thống GPS, các mạng như BlueTooth, WUSB, mạng sensor....</p>
<p>Nhưng có thể nói vấn đề lập trình mạng có 3 vấn đề chính cốt lõi tích hợp trong lập trình ứng dụng mạng và được thể hiện như hình 1.</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/123VuPhuc/myblog.git/media/posts/5/Picture1.png" alt="" width="372" height="214" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-xs.png 640w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-sm.png 768w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-md.png 1024w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-lg.png 1366w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-xl.png 1600w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-2xl.png 1920w"></figure>
<p>1.2/Các lớp của một mạng</p>
<p>         Truyền dữ liệu trên một mạng là một quá trình phức tạp. Để người phát triển ứng dụng và để người sử dụng không cần nhìn thấy sự phức tạp của quá trình truyền dữ liệu, các thành phần khác nhau của một mạng truyền thông được chia thành nhiều lớp. Mỗi một lớp biểu diễn một mức khác nhau của việc trừu tượng hóa giữa phần cứng vật lý (dây dẫn, điện…) và thông tin được truyền</p>
<figure class="post__image"><img loading="lazy"  src="https://github.com/123VuPhuc/myblog.git/media/posts/5/Picture1-2.png" alt="" width="559" height="359" sizes="(max-width: 1920px) 100vw, 1920px" srcset="https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-2-xs.png 640w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-2-sm.png 768w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-2-md.png 1024w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-2-lg.png 1366w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-2-xl.png 1600w ,https://github.com/123VuPhuc/myblog.git/media/posts/5/responsive/Picture1-2-2xl.png 1920w"></figure>
<p>Về mặt lý thuyết, mỗi một lớp chỉ trao đổi với các lớp kề ngay trên và kề ngay dưới. Việc tách một mạng thành các lớp cho phép ta sửa đổi thậm chí là thay thế phần mềm trong một lớp mà không ảnh hưởng đến các lớp khác miễn sao cho các giao diện giữa các lớp không thay đổi.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>ABOUT ME</title>
        <author>
            <name>Vũ Trần Hoàng Phúc</name>
        </author>
        <link href="https://github.com/123VuPhuc/myblog.git/about-me.html"/>
        <id>https://github.com/123VuPhuc/myblog.git/about-me.html</id>

        <updated>2024-12-29T10:52:48+07:00</updated>
            <summary></summary>
        <content></content>
    </entry>
</feed>
